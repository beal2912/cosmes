// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file nibiru/tokenfactory/v1/tx.proto (package nibiru.tokenfactory.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ModuleParams } from "./state_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Metadata } from "../../../cosmos/bank/v1beta1/bank_pb.js";

/**
 * MsgCreateDenom: sdk.Msg that registers an a token factory denom.
 * A denom has the form "tf/[creatorAddr]/[subdenom]".
 *  - Denoms become unique x/bank tokens, so the creator-subdenom pair that
 *    defines a denom cannot be reused.
 *  - The resulting denom's admin is originally set to be the creator, but the
 *    admin can be changed later.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgCreateDenom
 */
export class MsgCreateDenom extends Message<MsgCreateDenom> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * subdenom can be up to 44 "alphanumeric" characters long.
   *
   * @generated from field: string subdenom = 2;
   */
  subdenom = "";

  constructor(data?: PartialMessage<MsgCreateDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgCreateDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subdenom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDenom | PlainMessage<MsgCreateDenom> | undefined, b: MsgCreateDenom | PlainMessage<MsgCreateDenom> | undefined): boolean {
    return proto3.util.equals(MsgCreateDenom, a, b);
  }
}

/**
 * MsgCreateDenomResponse is the return value of MsgCreateDenom
 *
 * @generated from message nibiru.tokenfactory.v1.MsgCreateDenomResponse
 */
export class MsgCreateDenomResponse extends Message<MsgCreateDenomResponse> {
  /**
   * NewTokenDenom: identifier for the newly created token factory denom.
   *
   * @generated from field: string new_token_denom = 1;
   */
  newTokenDenom = "";

  constructor(data?: PartialMessage<MsgCreateDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgCreateDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_token_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDenomResponse | PlainMessage<MsgCreateDenomResponse> | undefined, b: MsgCreateDenomResponse | PlainMessage<MsgCreateDenomResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateDenomResponse, a, b);
  }
}

/**
 * MsgChangeAdmin is the sdk.Msg type for allowing an admin account to change
 * admin of a denom to a new account
 *
 * @generated from message nibiru.tokenfactory.v1.MsgChangeAdmin
 */
export class MsgChangeAdmin extends Message<MsgChangeAdmin> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * @generated from field: string new_admin = 3;
   */
  newAdmin = "";

  constructor(data?: PartialMessage<MsgChangeAdmin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgChangeAdmin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "new_admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromJsonString(jsonString, options);
  }

  static equals(a: MsgChangeAdmin | PlainMessage<MsgChangeAdmin> | undefined, b: MsgChangeAdmin | PlainMessage<MsgChangeAdmin> | undefined): boolean {
    return proto3.util.equals(MsgChangeAdmin, a, b);
  }
}

/**
 * MsgChangeAdminResponse is the gRPC response for the MsgChangeAdmin TxMsg.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgChangeAdminResponse
 */
export class MsgChangeAdminResponse extends Message<MsgChangeAdminResponse> {
  constructor(data?: PartialMessage<MsgChangeAdminResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgChangeAdminResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgChangeAdminResponse | PlainMessage<MsgChangeAdminResponse> | undefined, b: MsgChangeAdminResponse | PlainMessage<MsgChangeAdminResponse> | undefined): boolean {
    return proto3.util.equals(MsgChangeAdminResponse, a, b);
  }
}

/**
 * MsgUpdateModuleParams: sdk.Msg for updating the x/tokenfactory module params
 *
 * @generated from message nibiru.tokenfactory.v1.MsgUpdateModuleParams
 */
export class MsgUpdateModuleParams extends Message<MsgUpdateModuleParams> {
  /**
   * Authority: Address of the governance module account.
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * @generated from field: nibiru.tokenfactory.v1.ModuleParams params = 2;
   */
  params?: ModuleParams;

  constructor(data?: PartialMessage<MsgUpdateModuleParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgUpdateModuleParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: ModuleParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateModuleParams {
    return new MsgUpdateModuleParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateModuleParams {
    return new MsgUpdateModuleParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateModuleParams {
    return new MsgUpdateModuleParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateModuleParams | PlainMessage<MsgUpdateModuleParams> | undefined, b: MsgUpdateModuleParams | PlainMessage<MsgUpdateModuleParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateModuleParams, a, b);
  }
}

/**
 * MsgUpdateModuleParamsResponse is the gRPC response for the
 * MsgUpdateModuleParams TxMsg.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgUpdateModuleParamsResponse
 */
export class MsgUpdateModuleParamsResponse extends Message<MsgUpdateModuleParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateModuleParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgUpdateModuleParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateModuleParamsResponse {
    return new MsgUpdateModuleParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateModuleParamsResponse {
    return new MsgUpdateModuleParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateModuleParamsResponse {
    return new MsgUpdateModuleParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateModuleParamsResponse | PlainMessage<MsgUpdateModuleParamsResponse> | undefined, b: MsgUpdateModuleParamsResponse | PlainMessage<MsgUpdateModuleParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateModuleParamsResponse, a, b);
  }
}

/**
 * MsgMint: sdk.Msg (TxMsg) where an denom admin mints more of the token.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgMint
 */
export class MsgMint extends Message<MsgMint> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * coin: The denom identifier and amount to mint.
   *
   * @generated from field: cosmos.base.v1beta1.Coin coin = 2;
   */
  coin?: Coin;

  /**
   * mint_to_addr: An address to which tokens will be minted. If blank,
   * tokens are minted to the "sender".
   *
   * @generated from field: string mint_to = 3;
   */
  mintTo = "";

  constructor(data?: PartialMessage<MsgMint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgMint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coin", kind: "message", T: Coin },
    { no: 3, name: "mint_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMint {
    return new MsgMint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMint {
    return new MsgMint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMint {
    return new MsgMint().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMint | PlainMessage<MsgMint> | undefined, b: MsgMint | PlainMessage<MsgMint> | undefined): boolean {
    return proto3.util.equals(MsgMint, a, b);
  }
}

/**
 * @generated from message nibiru.tokenfactory.v1.MsgMintResponse
 */
export class MsgMintResponse extends Message<MsgMintResponse> {
  /**
   * @generated from field: string mint_to = 1;
   */
  mintTo = "";

  constructor(data?: PartialMessage<MsgMintResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgMintResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mint_to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMintResponse | PlainMessage<MsgMintResponse> | undefined, b: MsgMintResponse | PlainMessage<MsgMintResponse> | undefined): boolean {
    return proto3.util.equals(MsgMintResponse, a, b);
  }
}

/**
 * MsgBurn: sdk.Msg (TxMsg) where a denom admin burns some of the token.
 * The reason that the sender isn't automatically the "burn_from" address
 * is to support smart contracts (primary use case). In this situation, the
 * contract is the message signer and sender, while "burn_from" is based on the
 * contract logic.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgBurn
 */
export class MsgBurn extends Message<MsgBurn> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * coin: The denom identifier and amount to burn.
   *
   * @generated from field: cosmos.base.v1beta1.Coin coin = 2;
   */
  coin?: Coin;

  /**
   * burn_from: The address from which tokens will be burned.
   *
   * @generated from field: string burn_from = 3;
   */
  burnFrom = "";

  constructor(data?: PartialMessage<MsgBurn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgBurn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coin", kind: "message", T: Coin },
    { no: 3, name: "burn_from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurn {
    return new MsgBurn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurn {
    return new MsgBurn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurn {
    return new MsgBurn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurn | PlainMessage<MsgBurn> | undefined, b: MsgBurn | PlainMessage<MsgBurn> | undefined): boolean {
    return proto3.util.equals(MsgBurn, a, b);
  }
}

/**
 * @generated from message nibiru.tokenfactory.v1.MsgBurnResponse
 */
export class MsgBurnResponse extends Message<MsgBurnResponse> {
  constructor(data?: PartialMessage<MsgBurnResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgBurnResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurnResponse | PlainMessage<MsgBurnResponse> | undefined, b: MsgBurnResponse | PlainMessage<MsgBurnResponse> | undefined): boolean {
    return proto3.util.equals(MsgBurnResponse, a, b);
  }
}

/**
 * MsgSetDenomMetadata: sdk.Msg (TxMsg) enabling the denom admin to change its
 * bank metadata.
 *
 * @generated from message nibiru.tokenfactory.v1.MsgSetDenomMetadata
 */
export class MsgSetDenomMetadata extends Message<MsgSetDenomMetadata> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * Metadata: Official x/bank metadata for the denom. All token factory denoms
   * are standard, native assets. The "metadata.base" is the denom.
   *
   * @generated from field: cosmos.bank.v1beta1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<MsgSetDenomMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgSetDenomMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomMetadata | PlainMessage<MsgSetDenomMetadata> | undefined, b: MsgSetDenomMetadata | PlainMessage<MsgSetDenomMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomMetadata, a, b);
  }
}

/**
 * @generated from message nibiru.tokenfactory.v1.MsgSetDenomMetadataResponse
 */
export class MsgSetDenomMetadataResponse extends Message<MsgSetDenomMetadataResponse> {
  constructor(data?: PartialMessage<MsgSetDenomMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgSetDenomMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomMetadataResponse | PlainMessage<MsgSetDenomMetadataResponse> | undefined, b: MsgSetDenomMetadataResponse | PlainMessage<MsgSetDenomMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomMetadataResponse, a, b);
  }
}

/**
 * MsgSudoSetDenomMetadata: sdk.Msg (TxMsg) enabling Nibiru's "sudoers" to change
 * bank metadata.
 * [SUDO] Only callable by sudoers.
 *
 * Use Cases:
 *   - To define metadata for ICS20 assets brought
 *     over to the chain via IBC, as they don't have metadata by default.
 *   - To set metadata for Bank Coins created via the Token Factory
 *     module in case the admin forgets to do so. This is important because of
 *     the relationship Token Factory assets can have with ERC20s with the
 *     [FunToken Mechanism].
 *
 * [FunToken Mechanism]: https://nibiru.fi/docs/evm/funtoken.html
 *
 * @generated from message nibiru.tokenfactory.v1.MsgSudoSetDenomMetadata
 */
export class MsgSudoSetDenomMetadata extends Message<MsgSudoSetDenomMetadata> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * Metadata: Official x/bank metadata for the denom. The "metadata.base" is
   * the denom.
   *
   * @generated from field: cosmos.bank.v1beta1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<MsgSudoSetDenomMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgSudoSetDenomMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSudoSetDenomMetadata {
    return new MsgSudoSetDenomMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSudoSetDenomMetadata {
    return new MsgSudoSetDenomMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSudoSetDenomMetadata {
    return new MsgSudoSetDenomMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSudoSetDenomMetadata | PlainMessage<MsgSudoSetDenomMetadata> | undefined, b: MsgSudoSetDenomMetadata | PlainMessage<MsgSudoSetDenomMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSudoSetDenomMetadata, a, b);
  }
}

/**
 * @generated from message nibiru.tokenfactory.v1.MsgSudoSetDenomMetadataResponse
 */
export class MsgSudoSetDenomMetadataResponse extends Message<MsgSudoSetDenomMetadataResponse> {
  constructor(data?: PartialMessage<MsgSudoSetDenomMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgSudoSetDenomMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSudoSetDenomMetadataResponse {
    return new MsgSudoSetDenomMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSudoSetDenomMetadataResponse {
    return new MsgSudoSetDenomMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSudoSetDenomMetadataResponse {
    return new MsgSudoSetDenomMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSudoSetDenomMetadataResponse | PlainMessage<MsgSudoSetDenomMetadataResponse> | undefined, b: MsgSudoSetDenomMetadataResponse | PlainMessage<MsgSudoSetDenomMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSudoSetDenomMetadataResponse, a, b);
  }
}

/**
 * Burn a native token such as unibi
 *
 * @generated from message nibiru.tokenfactory.v1.MsgBurnNative
 */
export class MsgBurnNative extends Message<MsgBurnNative> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin coin = 2;
   */
  coin?: Coin;

  constructor(data?: PartialMessage<MsgBurnNative>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgBurnNative";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "coin", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurnNative {
    return new MsgBurnNative().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurnNative {
    return new MsgBurnNative().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurnNative {
    return new MsgBurnNative().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurnNative | PlainMessage<MsgBurnNative> | undefined, b: MsgBurnNative | PlainMessage<MsgBurnNative> | undefined): boolean {
    return proto3.util.equals(MsgBurnNative, a, b);
  }
}

/**
 * @generated from message nibiru.tokenfactory.v1.MsgBurnNativeResponse
 */
export class MsgBurnNativeResponse extends Message<MsgBurnNativeResponse> {
  constructor(data?: PartialMessage<MsgBurnNativeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "nibiru.tokenfactory.v1.MsgBurnNativeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurnNativeResponse {
    return new MsgBurnNativeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurnNativeResponse {
    return new MsgBurnNativeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurnNativeResponse {
    return new MsgBurnNativeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurnNativeResponse | PlainMessage<MsgBurnNativeResponse> | undefined, b: MsgBurnNativeResponse | PlainMessage<MsgBurnNativeResponse> | undefined): boolean {
    return proto3.util.equals(MsgBurnNativeResponse, a, b);
  }
}

