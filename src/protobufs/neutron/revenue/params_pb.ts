// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file neutron/revenue/params.proto (package neutron.revenue, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Defines the parameters for the module.
 *
 * @generated from message neutron.revenue.Params
 */
export class Params extends Message<Params> {
  /**
   * The asset used in revenue payments to validators. Expected to be a native token of the chain
   * with its denom metadata registered in the bank module. The denom metadata must have a defined
   * symbol field and contain a denom unit with an alias equal to the symbol and a specified
   * exponent.
   *
   * @generated from field: string reward_asset = 1;
   */
  rewardAsset = "";

  /**
   * Quotation of the reward asset.
   *
   * @generated from field: neutron.revenue.RewardQuote reward_quote = 2;
   */
  rewardQuote?: RewardQuote;

  /**
   * Specifies performance requirements for validators in scope of blocks signing and creation. If
   * not met, the validator is not rewarded.
   *
   * @generated from field: neutron.revenue.PerformanceRequirement blocks_performance_requirement = 3;
   */
  blocksPerformanceRequirement?: PerformanceRequirement;

  /**
   * Specifies performance requirements for validators in scope of the oracle price votes. If not
   * met, the validator is not rewarded.
   *
   * @generated from field: neutron.revenue.PerformanceRequirement oracle_votes_performance_requirement = 4;
   */
  oracleVotesPerformanceRequirement?: PerformanceRequirement;

  /**
   * Indicates the currently active type of payment schedule.
   *
   * @generated from field: neutron.revenue.PaymentScheduleType payment_schedule_type = 5;
   */
  paymentScheduleType?: PaymentScheduleType;

  /**
   * The time window, in seconds, used to calculate the TWAP of the reward asset.
   *
   * @generated from field: int64 twap_window = 6;
   */
  twapWindow = protoInt64.zero;

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reward_asset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "reward_quote", kind: "message", T: RewardQuote },
    { no: 3, name: "blocks_performance_requirement", kind: "message", T: PerformanceRequirement },
    { no: 4, name: "oracle_votes_performance_requirement", kind: "message", T: PerformanceRequirement },
    { no: 5, name: "payment_schedule_type", kind: "message", T: PaymentScheduleType },
    { no: 6, name: "twap_window", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * Defines information about the reward quote.
 *
 * @generated from message neutron.revenue.RewardQuote
 */
export class RewardQuote extends Message<RewardQuote> {
  /**
   * The compensation amount measured in the quote asset. The amount is divided by the price of
   * the reward asset to determine the base revenue amount.
   *
   * @generated from field: uint64 amount = 1;
   */
  amount = protoInt64.zero;

  /**
   * The name of the quote asset. It is used as a quote in price queries to the slinky oracle
   * module to determine the price of the reward asset.
   *
   * @generated from field: string asset = 2;
   */
  asset = "";

  constructor(data?: PartialMessage<RewardQuote>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.RewardQuote";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "asset", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardQuote {
    return new RewardQuote().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardQuote {
    return new RewardQuote().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardQuote {
    return new RewardQuote().fromJsonString(jsonString, options);
  }

  static equals(a: RewardQuote | PlainMessage<RewardQuote> | undefined, b: RewardQuote | PlainMessage<RewardQuote> | undefined): boolean {
    return proto3.util.equals(RewardQuote, a, b);
  }
}

/**
 * A model that contains information specific to the currently active payment schedule type. The
 * oneof implementations define the payment schedule that must be used currently.
 * This is a module's parameter. It's not updated automatically in runtime in contrast to the
 * payment schedule which is a state variable, but is updated via MsgUpdateParams.
 *
 * @generated from message neutron.revenue.PaymentScheduleType
 */
export class PaymentScheduleType extends Message<PaymentScheduleType> {
  /**
   * @generated from oneof neutron.revenue.PaymentScheduleType.payment_schedule_type
   */
  paymentScheduleType: {
    /**
     * @generated from field: neutron.revenue.MonthlyPaymentScheduleType monthly_payment_schedule_type = 4;
     */
    value: MonthlyPaymentScheduleType;
    case: "monthlyPaymentScheduleType";
  } | {
    /**
     * @generated from field: neutron.revenue.BlockBasedPaymentScheduleType block_based_payment_schedule_type = 5;
     */
    value: BlockBasedPaymentScheduleType;
    case: "blockBasedPaymentScheduleType";
  } | {
    /**
     * @generated from field: neutron.revenue.EmptyPaymentScheduleType empty_payment_schedule_type = 6;
     */
    value: EmptyPaymentScheduleType;
    case: "emptyPaymentScheduleType";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PaymentScheduleType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.PaymentScheduleType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "monthly_payment_schedule_type", kind: "message", T: MonthlyPaymentScheduleType, oneof: "payment_schedule_type" },
    { no: 5, name: "block_based_payment_schedule_type", kind: "message", T: BlockBasedPaymentScheduleType, oneof: "payment_schedule_type" },
    { no: 6, name: "empty_payment_schedule_type", kind: "message", T: EmptyPaymentScheduleType, oneof: "payment_schedule_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentScheduleType {
    return new PaymentScheduleType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentScheduleType {
    return new PaymentScheduleType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentScheduleType {
    return new PaymentScheduleType().fromJsonString(jsonString, options);
  }

  static equals(a: PaymentScheduleType | PlainMessage<PaymentScheduleType> | undefined, b: PaymentScheduleType | PlainMessage<PaymentScheduleType> | undefined): boolean {
    return proto3.util.equals(PaymentScheduleType, a, b);
  }
}

/**
 * Monthly periods with payments made at the end of each month.
 *
 * @generated from message neutron.revenue.MonthlyPaymentScheduleType
 */
export class MonthlyPaymentScheduleType extends Message<MonthlyPaymentScheduleType> {
  constructor(data?: PartialMessage<MonthlyPaymentScheduleType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.MonthlyPaymentScheduleType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MonthlyPaymentScheduleType {
    return new MonthlyPaymentScheduleType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MonthlyPaymentScheduleType {
    return new MonthlyPaymentScheduleType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MonthlyPaymentScheduleType {
    return new MonthlyPaymentScheduleType().fromJsonString(jsonString, options);
  }

  static equals(a: MonthlyPaymentScheduleType | PlainMessage<MonthlyPaymentScheduleType> | undefined, b: MonthlyPaymentScheduleType | PlainMessage<MonthlyPaymentScheduleType> | undefined): boolean {
    return proto3.util.equals(MonthlyPaymentScheduleType, a, b);
  }
}

/**
 * Periods defined by a specific number of blocks, with payments made when the required block
 * count is reached.
 *
 * @generated from message neutron.revenue.BlockBasedPaymentScheduleType
 */
export class BlockBasedPaymentScheduleType extends Message<BlockBasedPaymentScheduleType> {
  /**
   * The number of blocks in a payment period.
   *
   * @generated from field: uint64 blocks_per_period = 1;
   */
  blocksPerPeriod = protoInt64.zero;

  constructor(data?: PartialMessage<BlockBasedPaymentScheduleType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.BlockBasedPaymentScheduleType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blocks_per_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockBasedPaymentScheduleType {
    return new BlockBasedPaymentScheduleType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockBasedPaymentScheduleType {
    return new BlockBasedPaymentScheduleType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockBasedPaymentScheduleType {
    return new BlockBasedPaymentScheduleType().fromJsonString(jsonString, options);
  }

  static equals(a: BlockBasedPaymentScheduleType | PlainMessage<BlockBasedPaymentScheduleType> | undefined, b: BlockBasedPaymentScheduleType | PlainMessage<BlockBasedPaymentScheduleType> | undefined): boolean {
    return proto3.util.equals(BlockBasedPaymentScheduleType, a, b);
  }
}

/**
 * Endless periods with payments never made.
 *
 * @generated from message neutron.revenue.EmptyPaymentScheduleType
 */
export class EmptyPaymentScheduleType extends Message<EmptyPaymentScheduleType> {
  constructor(data?: PartialMessage<EmptyPaymentScheduleType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.EmptyPaymentScheduleType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmptyPaymentScheduleType {
    return new EmptyPaymentScheduleType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmptyPaymentScheduleType {
    return new EmptyPaymentScheduleType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmptyPaymentScheduleType {
    return new EmptyPaymentScheduleType().fromJsonString(jsonString, options);
  }

  static equals(a: EmptyPaymentScheduleType | PlainMessage<EmptyPaymentScheduleType> | undefined, b: EmptyPaymentScheduleType | PlainMessage<EmptyPaymentScheduleType> | undefined): boolean {
    return proto3.util.equals(EmptyPaymentScheduleType, a, b);
  }
}

/**
 * Specifies a performance criteria that validators must meet to qualify for network rewards.
 *
 * @generated from message neutron.revenue.PerformanceRequirement
 */
export class PerformanceRequirement extends Message<PerformanceRequirement> {
  /**
   * The fraction of the total performance a validator can miss without affecting their reward.
   * Represented as a decimal value in the range [0.0, 1.0], where 1.0 corresponds to 100%.
   *
   * @generated from field: string allowed_to_miss = 1;
   */
  allowedToMiss = "";

  /**
   * The minimum fraction of the total performance a validator must achieve to be eligible for
   * network rewards. Validators falling below this threshold will not receive any rewards.
   * Represented as a decimal value in the range [0.0, 1.0], where 1.0 corresponds to 100%.
   *
   * @generated from field: string required_at_least = 2;
   */
  requiredAtLeast = "";

  constructor(data?: PartialMessage<PerformanceRequirement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.PerformanceRequirement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "allowed_to_miss", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "required_at_least", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerformanceRequirement {
    return new PerformanceRequirement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerformanceRequirement {
    return new PerformanceRequirement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerformanceRequirement {
    return new PerformanceRequirement().fromJsonString(jsonString, options);
  }

  static equals(a: PerformanceRequirement | PlainMessage<PerformanceRequirement> | undefined, b: PerformanceRequirement | PlainMessage<PerformanceRequirement> | undefined): boolean {
    return proto3.util.equals(PerformanceRequirement, a, b);
  }
}

