// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file neutron/revenue/genesis.proto (package neutron.revenue, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";

/**
 * Defines the revenue module's genesis state.
 *
 * @generated from message neutron.revenue.GenesisState
 */
export class GenesisState extends Message<GenesisState> {
  /**
   * Revenue module parameters.
   *
   * @generated from field: neutron.revenue.Params params = 1;
   */
  params?: Params;

  /**
   * The current payment schedule. If nil, the module will use the respective payment schedule for
   * the payment schedule type specified in the params.
   *
   * @generated from field: neutron.revenue.PaymentSchedule payment_schedule = 2;
   */
  paymentSchedule?: PaymentSchedule;

  /**
   * Revenue module list of validators.
   *
   * @generated from field: repeated neutron.revenue.ValidatorInfo validators = 3;
   */
  validators: ValidatorInfo[] = [];

  constructor(data?: PartialMessage<GenesisState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.GenesisState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
    { no: 2, name: "payment_schedule", kind: "message", T: PaymentSchedule },
    { no: 3, name: "validators", kind: "message", T: ValidatorInfo, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenesisState {
    return new GenesisState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenesisState {
    return new GenesisState().fromJsonString(jsonString, options);
  }

  static equals(a: GenesisState | PlainMessage<GenesisState> | undefined, b: GenesisState | PlainMessage<GenesisState> | undefined): boolean {
    return proto3.util.equals(GenesisState, a, b);
  }
}

/**
 * A model that contains information specific to the currently active payment schedule. The oneof
 * implementations define conditions for payment periods ending and track the progress of the
 * current payment period. This is a module's state variable.
 * The inner oneof must correspond with the respective payment schedule type defined in the module
 * params. In runtime, on a mismatch due to e.g. MsgUpdateParams execution, the module will switch
 * to the payment schedule that corresponds to the payment schedule type automatically.
 *
 * @generated from message neutron.revenue.PaymentSchedule
 */
export class PaymentSchedule extends Message<PaymentSchedule> {
  /**
   * @generated from oneof neutron.revenue.PaymentSchedule.payment_schedule
   */
  paymentSchedule: {
    /**
     * @generated from field: neutron.revenue.MonthlyPaymentSchedule monthly_payment_schedule = 1;
     */
    value: MonthlyPaymentSchedule;
    case: "monthlyPaymentSchedule";
  } | {
    /**
     * @generated from field: neutron.revenue.BlockBasedPaymentSchedule block_based_payment_schedule = 2;
     */
    value: BlockBasedPaymentSchedule;
    case: "blockBasedPaymentSchedule";
  } | {
    /**
     * @generated from field: neutron.revenue.EmptyPaymentSchedule empty_payment_schedule = 3;
     */
    value: EmptyPaymentSchedule;
    case: "emptyPaymentSchedule";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PaymentSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.PaymentSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "monthly_payment_schedule", kind: "message", T: MonthlyPaymentSchedule, oneof: "payment_schedule" },
    { no: 2, name: "block_based_payment_schedule", kind: "message", T: BlockBasedPaymentSchedule, oneof: "payment_schedule" },
    { no: 3, name: "empty_payment_schedule", kind: "message", T: EmptyPaymentSchedule, oneof: "payment_schedule" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PaymentSchedule {
    return new PaymentSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PaymentSchedule {
    return new PaymentSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PaymentSchedule {
    return new PaymentSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: PaymentSchedule | PlainMessage<PaymentSchedule> | undefined, b: PaymentSchedule | PlainMessage<PaymentSchedule> | undefined): boolean {
    return proto3.util.equals(PaymentSchedule, a, b);
  }
}

/**
 * Contains information about a validator.
 *
 * @generated from message neutron.revenue.ValidatorInfo
 */
export class ValidatorInfo extends Message<ValidatorInfo> {
  /**
   * The validator's node operator address.
   *
   * @generated from field: string val_oper_address = 1;
   */
  valOperAddress = "";

  /**
   * The number of blocks the validator has committed in the current payment period.
   *
   * @generated from field: uint64 commited_blocks_in_period = 2;
   */
  commitedBlocksInPeriod = protoInt64.zero;

  /**
   * The number of oracle votes the validator has submitted in the current payment period.
   *
   * @generated from field: uint64 commited_oracle_votes_in_period = 3;
   */
  commitedOracleVotesInPeriod = protoInt64.zero;

  /**
   * The number of blocks the validator has remained in the active validator set for in the
   * current payment period.
   *
   * @generated from field: uint64 in_active_valset_for_blocks_in_period = 4;
   */
  inActiveValsetForBlocksInPeriod = protoInt64.zero;

  constructor(data?: PartialMessage<ValidatorInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.ValidatorInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val_oper_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "commited_blocks_in_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "commited_oracle_votes_in_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "in_active_valset_for_blocks_in_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorInfo {
    return new ValidatorInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorInfo | PlainMessage<ValidatorInfo> | undefined, b: ValidatorInfo | PlainMessage<ValidatorInfo> | undefined): boolean {
    return proto3.util.equals(ValidatorInfo, a, b);
  }
}

/**
 * Represents a payment schedule where revenue payments are processed once a month.
 *
 * @generated from message neutron.revenue.MonthlyPaymentSchedule
 */
export class MonthlyPaymentSchedule extends Message<MonthlyPaymentSchedule> {
  /**
   * The block height at which the current month started.
   *
   * @generated from field: uint64 current_month_start_block = 1;
   */
  currentMonthStartBlock = protoInt64.zero;

  /**
   * The timestamp of the block at which the current month started.
   *
   * @generated from field: uint64 current_month_start_block_ts = 2;
   */
  currentMonthStartBlockTs = protoInt64.zero;

  constructor(data?: PartialMessage<MonthlyPaymentSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.MonthlyPaymentSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "current_month_start_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "current_month_start_block_ts", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MonthlyPaymentSchedule {
    return new MonthlyPaymentSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MonthlyPaymentSchedule {
    return new MonthlyPaymentSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MonthlyPaymentSchedule {
    return new MonthlyPaymentSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: MonthlyPaymentSchedule | PlainMessage<MonthlyPaymentSchedule> | undefined, b: MonthlyPaymentSchedule | PlainMessage<MonthlyPaymentSchedule> | undefined): boolean {
    return proto3.util.equals(MonthlyPaymentSchedule, a, b);
  }
}

/**
 * Represents a payment schedule where revenue payments are processed after a specified number
 * of blocks.
 *
 * @generated from message neutron.revenue.BlockBasedPaymentSchedule
 */
export class BlockBasedPaymentSchedule extends Message<BlockBasedPaymentSchedule> {
  /**
   * The number of blocks in each payment period.
   *
   * @generated from field: uint64 blocks_per_period = 1;
   */
  blocksPerPeriod = protoInt64.zero;

  /**
   * The block height at which the current payment period started.
   *
   * @generated from field: uint64 current_period_start_block = 2;
   */
  currentPeriodStartBlock = protoInt64.zero;

  constructor(data?: PartialMessage<BlockBasedPaymentSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.BlockBasedPaymentSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blocks_per_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "current_period_start_block", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlockBasedPaymentSchedule {
    return new BlockBasedPaymentSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlockBasedPaymentSchedule {
    return new BlockBasedPaymentSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlockBasedPaymentSchedule {
    return new BlockBasedPaymentSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: BlockBasedPaymentSchedule | PlainMessage<BlockBasedPaymentSchedule> | undefined, b: BlockBasedPaymentSchedule | PlainMessage<BlockBasedPaymentSchedule> | undefined): boolean {
    return proto3.util.equals(BlockBasedPaymentSchedule, a, b);
  }
}

/**
 * Represents a payment schedule where revenue is never distributed.
 *
 * @generated from message neutron.revenue.EmptyPaymentSchedule
 */
export class EmptyPaymentSchedule extends Message<EmptyPaymentSchedule> {
  constructor(data?: PartialMessage<EmptyPaymentSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.EmptyPaymentSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EmptyPaymentSchedule {
    return new EmptyPaymentSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EmptyPaymentSchedule {
    return new EmptyPaymentSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EmptyPaymentSchedule {
    return new EmptyPaymentSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: EmptyPaymentSchedule | PlainMessage<EmptyPaymentSchedule> | undefined, b: EmptyPaymentSchedule | PlainMessage<EmptyPaymentSchedule> | undefined): boolean {
    return proto3.util.equals(EmptyPaymentSchedule, a, b);
  }
}

/**
 * Represents a data structure that tracks the cumulative price of an asset over the entire
 * observation period, along with the last absolute asset price and the timestamp when this
 * price was last recorded.
 *
 * @generated from message neutron.revenue.RewardAssetPrice
 */
export class RewardAssetPrice extends Message<RewardAssetPrice> {
  /**
   * The cumulative price of the reward asset within the TWAP window. It is calculated as:
   * `cumulative_price_at_timestamp_t(n)` = `last_price_at_t(n-1)` * (t(n) - t(n-1)) + `cumulative_price_at_timestamp_t(n-1)`
   *
   * @generated from field: string cumulative_price = 1;
   */
  cumulativePrice = "";

  /**
   * The price of the reward asset in reward quote asset that corresponds to the timestamp.
   *
   * @generated from field: string absolute_price = 2;
   */
  absolutePrice = "";

  /**
   * The timestamp of the last update of the absolute and cumulative price.
   *
   * @generated from field: int64 timestamp = 3;
   */
  timestamp = protoInt64.zero;

  constructor(data?: PartialMessage<RewardAssetPrice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.RewardAssetPrice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cumulative_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "absolute_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardAssetPrice {
    return new RewardAssetPrice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardAssetPrice {
    return new RewardAssetPrice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardAssetPrice {
    return new RewardAssetPrice().fromJsonString(jsonString, options);
  }

  static equals(a: RewardAssetPrice | PlainMessage<RewardAssetPrice> | undefined, b: RewardAssetPrice | PlainMessage<RewardAssetPrice> | undefined): boolean {
    return proto3.util.equals(RewardAssetPrice, a, b);
  }
}

