// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file neutron/revenue/query.proto (package neutron.revenue, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Params } from "./params_pb.js";
import { PaymentSchedule, ValidatorInfo } from "./genesis_pb.js";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * Request type for the Query/Params RPC method.
 *
 * @generated from message neutron.revenue.QueryParamsRequest
 */
export class QueryParamsRequest extends Message<QueryParamsRequest> {
  constructor(data?: PartialMessage<QueryParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined, b: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined): boolean {
    return proto3.util.equals(QueryParamsRequest, a, b);
  }
}

/**
 * Response type for the Query/Params RPC method.
 *
 * @generated from message neutron.revenue.QueryParamsResponse
 */
export class QueryParamsResponse extends Message<QueryParamsResponse> {
  /**
   * Contains all parameters of the module.
   *
   * @generated from field: neutron.revenue.Params params = 1;
   */
  params?: Params;

  constructor(data?: PartialMessage<QueryParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined, b: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined): boolean {
    return proto3.util.equals(QueryParamsResponse, a, b);
  }
}

/**
 * Request type for the Query/PaymentInfo RPC method.
 *
 * @generated from message neutron.revenue.QueryPaymentInfoRequest
 */
export class QueryPaymentInfoRequest extends Message<QueryPaymentInfoRequest> {
  constructor(data?: PartialMessage<QueryPaymentInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryPaymentInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPaymentInfoRequest {
    return new QueryPaymentInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPaymentInfoRequest {
    return new QueryPaymentInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPaymentInfoRequest {
    return new QueryPaymentInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPaymentInfoRequest | PlainMessage<QueryPaymentInfoRequest> | undefined, b: QueryPaymentInfoRequest | PlainMessage<QueryPaymentInfoRequest> | undefined): boolean {
    return proto3.util.equals(QueryPaymentInfoRequest, a, b);
  }
}

/**
 * Response type for the Query/PaymentInfo RPC method.
 *
 * @generated from message neutron.revenue.QueryPaymentInfoResponse
 */
export class QueryPaymentInfoResponse extends Message<QueryPaymentInfoResponse> {
  /**
   * The current payment schedule.
   *
   * @generated from field: neutron.revenue.PaymentSchedule payment_schedule = 1;
   */
  paymentSchedule?: PaymentSchedule;

  /**
   * Revenue amount multiplier value that corresponds to the effective payment period progress.
   *
   * @generated from field: string effective_period_progress = 2;
   */
  effectivePeriodProgress = "";

  /**
   * The current TWAP of the reward asset in quote asset. Is calculated as:
   * twap_from_time_t(n)_to_time_t(m) = (cumulative_price_at_t(n) - cumulative_price_at_t(m)) / (t(n) - t(m))
   *
   * @generated from field: string reward_asset_twap = 3;
   */
  rewardAssetTwap = "";

  /**
   * The current evaluation of the base revenue amount. This is the maximum amount a validator can
   * receive in the current price condition if not affected with reducing factors (e.g. imperfect
   * performance, incomplete payment period, partial validator set presence).
   *
   * @generated from field: cosmos.base.v1beta1.Coin base_revenue_amount = 4;
   */
  baseRevenueAmount?: Coin;

  constructor(data?: PartialMessage<QueryPaymentInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryPaymentInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "payment_schedule", kind: "message", T: PaymentSchedule },
    { no: 2, name: "effective_period_progress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reward_asset_twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "base_revenue_amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPaymentInfoResponse {
    return new QueryPaymentInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPaymentInfoResponse {
    return new QueryPaymentInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPaymentInfoResponse {
    return new QueryPaymentInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPaymentInfoResponse | PlainMessage<QueryPaymentInfoResponse> | undefined, b: QueryPaymentInfoResponse | PlainMessage<QueryPaymentInfoResponse> | undefined): boolean {
    return proto3.util.equals(QueryPaymentInfoResponse, a, b);
  }
}

/**
 * Request type for the Query/ValidatorStats RPC method.
 *
 * @generated from message neutron.revenue.QueryValidatorStatsRequest
 */
export class QueryValidatorStatsRequest extends Message<QueryValidatorStatsRequest> {
  /**
   * The validator's node operator address.
   *
   * @generated from field: string val_oper_address = 1;
   */
  valOperAddress = "";

  constructor(data?: PartialMessage<QueryValidatorStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryValidatorStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "val_oper_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorStatsRequest {
    return new QueryValidatorStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorStatsRequest {
    return new QueryValidatorStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorStatsRequest {
    return new QueryValidatorStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorStatsRequest | PlainMessage<QueryValidatorStatsRequest> | undefined, b: QueryValidatorStatsRequest | PlainMessage<QueryValidatorStatsRequest> | undefined): boolean {
    return proto3.util.equals(QueryValidatorStatsRequest, a, b);
  }
}

/**
 * Response type for the Query/ValidatorStats RPC method.
 *
 * @generated from message neutron.revenue.QueryValidatorStatsResponse
 */
export class QueryValidatorStatsResponse extends Message<QueryValidatorStatsResponse> {
  /**
   * Contains the validator's information.
   *
   * @generated from field: neutron.revenue.ValidatorStats stats = 1;
   */
  stats?: ValidatorStats;

  constructor(data?: PartialMessage<QueryValidatorStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryValidatorStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stats", kind: "message", T: ValidatorStats },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorStatsResponse {
    return new QueryValidatorStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorStatsResponse {
    return new QueryValidatorStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorStatsResponse {
    return new QueryValidatorStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorStatsResponse | PlainMessage<QueryValidatorStatsResponse> | undefined, b: QueryValidatorStatsResponse | PlainMessage<QueryValidatorStatsResponse> | undefined): boolean {
    return proto3.util.equals(QueryValidatorStatsResponse, a, b);
  }
}

/**
 * Request type for the Query/ValidatorsStats RPC method.
 *
 * @generated from message neutron.revenue.QueryValidatorsStatsRequest
 */
export class QueryValidatorsStatsRequest extends Message<QueryValidatorsStatsRequest> {
  constructor(data?: PartialMessage<QueryValidatorsStatsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryValidatorsStatsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorsStatsRequest {
    return new QueryValidatorsStatsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorsStatsRequest {
    return new QueryValidatorsStatsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorsStatsRequest {
    return new QueryValidatorsStatsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorsStatsRequest | PlainMessage<QueryValidatorsStatsRequest> | undefined, b: QueryValidatorsStatsRequest | PlainMessage<QueryValidatorsStatsRequest> | undefined): boolean {
    return proto3.util.equals(QueryValidatorsStatsRequest, a, b);
  }
}

/**
 * Response type for the Query/ValidatorsStats RPC method.
 *
 * @generated from message neutron.revenue.QueryValidatorsStatsResponse
 */
export class QueryValidatorsStatsResponse extends Message<QueryValidatorsStatsResponse> {
  /**
   * Contains the validators' information.
   *
   * @generated from field: repeated neutron.revenue.ValidatorStats stats = 1;
   */
  stats: ValidatorStats[] = [];

  constructor(data?: PartialMessage<QueryValidatorsStatsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.QueryValidatorsStatsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stats", kind: "message", T: ValidatorStats, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorsStatsResponse {
    return new QueryValidatorsStatsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorsStatsResponse {
    return new QueryValidatorsStatsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorsStatsResponse {
    return new QueryValidatorsStatsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorsStatsResponse | PlainMessage<QueryValidatorsStatsResponse> | undefined, b: QueryValidatorsStatsResponse | PlainMessage<QueryValidatorsStatsResponse> | undefined): boolean {
    return proto3.util.equals(QueryValidatorsStatsResponse, a, b);
  }
}

/**
 * Contains validator's info and their performance rating.
 *
 * @generated from message neutron.revenue.ValidatorStats
 */
export class ValidatorStats extends Message<ValidatorStats> {
  /**
   * Contains the validator's information.
   *
   * @generated from field: neutron.revenue.ValidatorInfo validator_info = 1;
   */
  validatorInfo?: ValidatorInfo;

  /**
   * The total number of blocks produced by the chain in the current payment period.
   *
   * @generated from field: uint64 total_produced_blocks_in_period = 2;
   */
  totalProducedBlocksInPeriod = protoInt64.zero;

  /**
   * The validator's performance rating. Represented as a decimal value.
   *
   * @generated from field: string performance_rating = 3;
   */
  performanceRating = "";

  /**
   * Contains expected revenue for the validator based on their performance rating in the current
   * payment period, current reward asset TWAP, and duration of validator's presence in the active
   * validator set. Does not take into account effective payment period progress.
   *
   * @generated from field: cosmos.base.v1beta1.Coin expected_revenue = 4;
   */
  expectedRevenue?: Coin;

  constructor(data?: PartialMessage<ValidatorStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.revenue.ValidatorStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_info", kind: "message", T: ValidatorInfo },
    { no: 2, name: "total_produced_blocks_in_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "performance_rating", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "expected_revenue", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorStats {
    return new ValidatorStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorStats {
    return new ValidatorStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorStats {
    return new ValidatorStats().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorStats | PlainMessage<ValidatorStats> | undefined, b: ValidatorStats | PlainMessage<ValidatorStats> | undefined): boolean {
    return proto3.util.equals(ValidatorStats, a, b);
  }
}

