// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file neutron/interchainqueries/tx.proto (package neutron.interchainqueries, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { KVKey } from "./genesis_pb.js";
import { Proof, ProofOps } from "../../tendermint/crypto/proof_pb.js";
import { ExecTxResult } from "../../tendermint/abci/types_pb.js";
import { Params } from "./params_pb.js";

/**
 * Request type for the Msg/RegisterInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgRegisterInterchainQuery
 */
export class MsgRegisterInterchainQuery extends Message<MsgRegisterInterchainQuery> {
  /**
   * The query type identifier: `kv` or `tx`.
   *
   * @generated from field: string query_type = 1;
   */
  queryType = "";

  /**
   * The KV-storage keys for which we want to get values from remote chain. Only applicable for the
   * KV Interchain Queries. Max amount of keys is limited by the module's `max_kv_query_keys_count`
   * parameters.
   *
   * @generated from field: repeated neutron.interchainqueries.KVKey keys = 2;
   */
  keys: KVKey[] = [];

  /**
   * A stringified list of filters for remote transactions search. Only applicable for the TX
   * Interchain Queries. Example: "[{\"field\":\"tx.height\",\"op\":\"Gte\",\"value\":2644737}]".
   * Supported operators: "eq", "lt", "gt", "lte", "gte". Max amount of filter conditions is
   * limited by the module's `max_transactions_filters` parameters.
   *
   * @generated from field: string transactions_filter = 3;
   */
  transactionsFilter = "";

  /**
   * The IBC connection ID to the remote chain (the source of querying data). Is used for getting
   * ConsensusState from the respective IBC client to verify query result proofs.
   *
   * @generated from field: string connection_id = 4;
   */
  connectionId = "";

  /**
   * Parameter that defines the minimal delay between consecutive query executions (i.e. the
   * minimal delay between query results update).
   *
   * @generated from field: uint64 update_period = 5;
   */
  updatePeriod = protoInt64.zero;

  /**
   * The signer of the message.
   *
   * @generated from field: string sender = 6;
   */
  sender = "";

  constructor(data?: PartialMessage<MsgRegisterInterchainQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgRegisterInterchainQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "keys", kind: "message", T: KVKey, repeated: true },
    { no: 3, name: "transactions_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "update_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterInterchainQuery {
    return new MsgRegisterInterchainQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterInterchainQuery {
    return new MsgRegisterInterchainQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterInterchainQuery {
    return new MsgRegisterInterchainQuery().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRegisterInterchainQuery | PlainMessage<MsgRegisterInterchainQuery> | undefined, b: MsgRegisterInterchainQuery | PlainMessage<MsgRegisterInterchainQuery> | undefined): boolean {
    return proto3.util.equals(MsgRegisterInterchainQuery, a, b);
  }
}

/**
 * Response type for the Msg/RegisterInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgRegisterInterchainQueryResponse
 */
export class MsgRegisterInterchainQueryResponse extends Message<MsgRegisterInterchainQueryResponse> {
  /**
   * The ID assigned to the registered Interchain Query by the module.
   *
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  constructor(data?: PartialMessage<MsgRegisterInterchainQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgRegisterInterchainQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRegisterInterchainQueryResponse {
    return new MsgRegisterInterchainQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRegisterInterchainQueryResponse {
    return new MsgRegisterInterchainQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRegisterInterchainQueryResponse {
    return new MsgRegisterInterchainQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRegisterInterchainQueryResponse | PlainMessage<MsgRegisterInterchainQueryResponse> | undefined, b: MsgRegisterInterchainQueryResponse | PlainMessage<MsgRegisterInterchainQueryResponse> | undefined): boolean {
    return proto3.util.equals(MsgRegisterInterchainQueryResponse, a, b);
  }
}

/**
 * Request type for the Msg/SubmitQueryResult RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgSubmitQueryResult
 */
export class MsgSubmitQueryResult extends Message<MsgSubmitQueryResult> {
  /**
   * The ID of the Interchain Query.
   *
   * @generated from field: uint64 query_id = 1;
   */
  queryId = protoInt64.zero;

  /**
   * The signer of the message.
   *
   * @generated from field: string sender = 2;
   */
  sender = "";

  /**
   * The IBC client ID that corresponds to the IBC connection to the remote chain (where the
   * query result is coming from).
   * Deprecated: populating this field does not make any affect
   *
   * @generated from field: string client_id = 3 [deprecated = true];
   * @deprecated
   */
  clientId = "";

  /**
   * The result of the Interchain Query execution.
   *
   * @generated from field: neutron.interchainqueries.QueryResult result = 4;
   */
  result?: QueryResult;

  constructor(data?: PartialMessage<MsgSubmitQueryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgSubmitQueryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "client_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "result", kind: "message", T: QueryResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSubmitQueryResult {
    return new MsgSubmitQueryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSubmitQueryResult {
    return new MsgSubmitQueryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSubmitQueryResult {
    return new MsgSubmitQueryResult().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSubmitQueryResult | PlainMessage<MsgSubmitQueryResult> | undefined, b: MsgSubmitQueryResult | PlainMessage<MsgSubmitQueryResult> | undefined): boolean {
    return proto3.util.equals(MsgSubmitQueryResult, a, b);
  }
}

/**
 * Contains different information about a single Interchain Query execution result. Currently,
 * this structure is used both in query result submission via an ICQ Relayer and as a query result
 * storage for read/write operations to interchainqueries module, but the structure fields are
 * populated in a bit different ways. When submitting a query result, all fields are populated and
 * provided to the interchainqueries module in order to verify the result against the IBC client's
 * state. But in order to lighten the chain state, the interchainqueries module removes the block
 * field and proofs from the kv_results.
 *
 * @generated from message neutron.interchainqueries.QueryResult
 */
export class QueryResult extends Message<QueryResult> {
  /**
   * A list of a KV Interchain Query execution results. Each result contains query parameters, a
   * response value and a proof.
   *
   * @generated from field: repeated neutron.interchainqueries.StorageValue kv_results = 1;
   */
  kvResults: StorageValue[] = [];

  /**
   * A TX Interchain Query execution result. Contains metainformation about the blocks of the query
   * execution height. Only populated when submitting an Interchain Query result for verification
   * and emptied when saving the result on chain.
   *
   * @generated from field: neutron.interchainqueries.Block block = 2;
   */
  block?: Block;

  /**
   * The height of the chain at the moment of the Interchain Query execution.
   *
   * @generated from field: uint64 height = 3;
   */
  height = protoInt64.zero;

  /**
   * The revision number of the chain at the moment of the Interchain Query execution.
   *
   * @generated from field: uint64 revision = 4;
   */
  revision = protoInt64.zero;

  /**
   * Whether to send the query result to the owner contract as a sudo message. Only applicable for
   * KV type of Interchain Queries.
   *
   * @generated from field: bool allow_kv_callbacks = 5;
   */
  allowKvCallbacks = false;

  constructor(data?: PartialMessage<QueryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.QueryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kv_results", kind: "message", T: StorageValue, repeated: true },
    { no: 2, name: "block", kind: "message", T: Block },
    { no: 3, name: "height", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "revision", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "allow_kv_callbacks", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResult {
    return new QueryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResult {
    return new QueryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResult {
    return new QueryResult().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResult | PlainMessage<QueryResult> | undefined, b: QueryResult | PlainMessage<QueryResult> | undefined): boolean {
    return proto3.util.equals(QueryResult, a, b);
  }
}

/**
 * A verifiable result of performing a single KVKey read.
 *
 * @generated from message neutron.interchainqueries.StorageValue
 */
export class StorageValue extends Message<StorageValue> {
  /**
   * The substore name used in the read operation. Typically, this corresponds to the keeper's
   * storeKey, usually the module's name, such as "bank", "staking", etc.
   *
   * @generated from field: string storage_prefix = 1;
   */
  storagePrefix = "";

  /**
   * A bytes field representing the key of the data read from the module's storage.
   *
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  /**
   * A bytes field containing the value associated with the key in the store.
   *
   * @generated from field: bytes value = 3;
   */
  value = new Uint8Array(0);

  /**
   * The Merkle Proof which proves existence/nonexistence of key-value pair in IAVL storage. Is
   * used to verify
   * the pair against the respective remote chain's header.
   *
   * @generated from field: tendermint.crypto.ProofOps Proof = 4;
   */
  Proof?: ProofOps;

  constructor(data?: PartialMessage<StorageValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.StorageValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storage_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "Proof", kind: "message", T: ProofOps },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageValue {
    return new StorageValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageValue {
    return new StorageValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageValue {
    return new StorageValue().fromJsonString(jsonString, options);
  }

  static equals(a: StorageValue | PlainMessage<StorageValue> | undefined, b: StorageValue | PlainMessage<StorageValue> | undefined): boolean {
    return proto3.util.equals(StorageValue, a, b);
  }
}

/**
 * A single verifiable result of an Interchain Query of TX type.
 *
 * @generated from message neutron.interchainqueries.Block
 */
export class Block extends Message<Block> {
  /**
   * The header of the block next to the block the transaction is included in. It is needed to know
   * block X+1 header to verify response of transaction for block X since LastResultsHash is root
   * hash of all results of the txs from the previous block.
   *
   * @generated from field: google.protobuf.Any next_block_header = 1;
   */
  nextBlockHeader?: Any;

  /**
   * The header of the block the transaction is included in. It is needed to know block header to
   * verify inclusion of the transaction.
   *
   * @generated from field: google.protobuf.Any header = 2;
   */
  header?: Any;

  /**
   * The transaction matched by the Interchain Query's transaction filter.
   *
   * @generated from field: neutron.interchainqueries.TxValue tx = 3;
   */
  tx?: TxValue;

  constructor(data?: PartialMessage<Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_block_header", kind: "message", T: Any },
    { no: 2, name: "header", kind: "message", T: Any },
    { no: 3, name: "tx", kind: "message", T: TxValue },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Block {
    return new Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJsonString(jsonString, options);
  }

  static equals(a: Block | PlainMessage<Block> | undefined, b: Block | PlainMessage<Block> | undefined): boolean {
    return proto3.util.equals(Block, a, b);
  }
}

/**
 * Contains transaction body, response, and proofs of inclusion and delivery.
 *
 * @generated from message neutron.interchainqueries.TxValue
 */
export class TxValue extends Message<TxValue> {
  /**
   * The result of the transaction execution.
   *
   * @generated from field: tendermint.abci.ExecTxResult response = 1;
   */
  response?: ExecTxResult;

  /**
   * The Merkle Proof which proves existence of response in the block next to the block the
   * transaction is included in.
   *
   * @generated from field: tendermint.crypto.Proof delivery_proof = 2;
   */
  deliveryProof?: Proof;

  /**
   * The Merkle Proof which proves inclusion of the transaction in the block.
   *
   * @generated from field: tendermint.crypto.Proof inclusion_proof = 3;
   */
  inclusionProof?: Proof;

  /**
   * The arbitrary data typed body of the transaction.
   *
   * @generated from field: bytes data = 4;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<TxValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.TxValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "response", kind: "message", T: ExecTxResult },
    { no: 2, name: "delivery_proof", kind: "message", T: Proof },
    { no: 3, name: "inclusion_proof", kind: "message", T: Proof },
    { no: 4, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TxValue {
    return new TxValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TxValue {
    return new TxValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TxValue {
    return new TxValue().fromJsonString(jsonString, options);
  }

  static equals(a: TxValue | PlainMessage<TxValue> | undefined, b: TxValue | PlainMessage<TxValue> | undefined): boolean {
    return proto3.util.equals(TxValue, a, b);
  }
}

/**
 * Response type for the Msg/SubmitQueryResult RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgSubmitQueryResultResponse
 */
export class MsgSubmitQueryResultResponse extends Message<MsgSubmitQueryResultResponse> {
  constructor(data?: PartialMessage<MsgSubmitQueryResultResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgSubmitQueryResultResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSubmitQueryResultResponse {
    return new MsgSubmitQueryResultResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSubmitQueryResultResponse {
    return new MsgSubmitQueryResultResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSubmitQueryResultResponse {
    return new MsgSubmitQueryResultResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSubmitQueryResultResponse | PlainMessage<MsgSubmitQueryResultResponse> | undefined, b: MsgSubmitQueryResultResponse | PlainMessage<MsgSubmitQueryResultResponse> | undefined): boolean {
    return proto3.util.equals(MsgSubmitQueryResultResponse, a, b);
  }
}

/**
 * Request type for the Msg/RemoveInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgRemoveInterchainQueryRequest
 */
export class MsgRemoveInterchainQueryRequest extends Message<MsgRemoveInterchainQueryRequest> {
  /**
   * The ID of the query to remove.
   *
   * @generated from field: uint64 query_id = 1;
   */
  queryId = protoInt64.zero;

  /**
   * The signer of the message.
   *
   * @generated from field: string sender = 2;
   */
  sender = "";

  constructor(data?: PartialMessage<MsgRemoveInterchainQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgRemoveInterchainQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRemoveInterchainQueryRequest {
    return new MsgRemoveInterchainQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRemoveInterchainQueryRequest {
    return new MsgRemoveInterchainQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRemoveInterchainQueryRequest {
    return new MsgRemoveInterchainQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRemoveInterchainQueryRequest | PlainMessage<MsgRemoveInterchainQueryRequest> | undefined, b: MsgRemoveInterchainQueryRequest | PlainMessage<MsgRemoveInterchainQueryRequest> | undefined): boolean {
    return proto3.util.equals(MsgRemoveInterchainQueryRequest, a, b);
  }
}

/**
 * Response type for the Msg/RemoveInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgRemoveInterchainQueryResponse
 */
export class MsgRemoveInterchainQueryResponse extends Message<MsgRemoveInterchainQueryResponse> {
  constructor(data?: PartialMessage<MsgRemoveInterchainQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgRemoveInterchainQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgRemoveInterchainQueryResponse {
    return new MsgRemoveInterchainQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgRemoveInterchainQueryResponse {
    return new MsgRemoveInterchainQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgRemoveInterchainQueryResponse {
    return new MsgRemoveInterchainQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgRemoveInterchainQueryResponse | PlainMessage<MsgRemoveInterchainQueryResponse> | undefined, b: MsgRemoveInterchainQueryResponse | PlainMessage<MsgRemoveInterchainQueryResponse> | undefined): boolean {
    return proto3.util.equals(MsgRemoveInterchainQueryResponse, a, b);
  }
}

/**
 * Request type for the Msg/UpdateInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgUpdateInterchainQueryRequest
 */
export class MsgUpdateInterchainQueryRequest extends Message<MsgUpdateInterchainQueryRequest> {
  /**
   * The ID of the query to update.
   *
   * @generated from field: uint64 query_id = 1;
   */
  queryId = protoInt64.zero;

  /**
   * A new list of KV-storage keys for which to get values from the remote chain. Only applicable
   * for a KV Interchain Query. Max amount of keys is limited by the module's `max_kv_query_keys_count`
   * parameters.
   *
   * @generated from field: repeated neutron.interchainqueries.KVKey new_keys = 2;
   */
  newKeys: KVKey[] = [];

  /**
   * A new minimal delay between consecutive query executions.
   *
   * @generated from field: uint64 new_update_period = 3;
   */
  newUpdatePeriod = protoInt64.zero;

  /**
   * A new list of filters for remote transactions search. Only applicable for a TX Interchain
   * Query. Example: "[{\"field\":\"tx.height\",\"op\":\"Gte\",\"value\":2644737}]".
   * Supported operators: "eq", "lt", "gt", "lte", "gte". Max amount of filter conditions is
   * limited by the module's `max_transactions_filters` parameters.
   *
   * @generated from field: string new_transactions_filter = 4;
   */
  newTransactionsFilter = "";

  /**
   * The signer of the message.
   *
   * @generated from field: string sender = 5;
   */
  sender = "";

  constructor(data?: PartialMessage<MsgUpdateInterchainQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgUpdateInterchainQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "new_keys", kind: "message", T: KVKey, repeated: true },
    { no: 3, name: "new_update_period", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "new_transactions_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateInterchainQueryRequest {
    return new MsgUpdateInterchainQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateInterchainQueryRequest {
    return new MsgUpdateInterchainQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateInterchainQueryRequest {
    return new MsgUpdateInterchainQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateInterchainQueryRequest | PlainMessage<MsgUpdateInterchainQueryRequest> | undefined, b: MsgUpdateInterchainQueryRequest | PlainMessage<MsgUpdateInterchainQueryRequest> | undefined): boolean {
    return proto3.util.equals(MsgUpdateInterchainQueryRequest, a, b);
  }
}

/**
 * Response type for the Msg/UpdateInterchainQuery RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgUpdateInterchainQueryResponse
 */
export class MsgUpdateInterchainQueryResponse extends Message<MsgUpdateInterchainQueryResponse> {
  constructor(data?: PartialMessage<MsgUpdateInterchainQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgUpdateInterchainQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateInterchainQueryResponse {
    return new MsgUpdateInterchainQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateInterchainQueryResponse {
    return new MsgUpdateInterchainQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateInterchainQueryResponse {
    return new MsgUpdateInterchainQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateInterchainQueryResponse | PlainMessage<MsgUpdateInterchainQueryResponse> | undefined, b: MsgUpdateInterchainQueryResponse | PlainMessage<MsgUpdateInterchainQueryResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateInterchainQueryResponse, a, b);
  }
}

/**
 * Request type for the Msg/UpdateParams RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * The address of the authority of the module.
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * The new parameters of the module. All parameters must be supplied.
   *
   * @generated from field: neutron.interchainqueries.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * Response type for the Msg/UpdateParams RPC method.
 *
 * @generated from message neutron.interchainqueries.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "neutron.interchainqueries.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

