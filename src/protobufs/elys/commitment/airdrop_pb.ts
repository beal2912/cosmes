// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file elys/commitment/airdrop.proto (package elys.commitment, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message elys.commitment.AtomStaker
 */
export class AtomStaker extends Message<AtomStaker> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<AtomStaker>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.AtomStaker";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AtomStaker {
    return new AtomStaker().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AtomStaker {
    return new AtomStaker().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AtomStaker {
    return new AtomStaker().fromJsonString(jsonString, options);
  }

  static equals(a: AtomStaker | PlainMessage<AtomStaker> | undefined, b: AtomStaker | PlainMessage<AtomStaker> | undefined): boolean {
    return proto3.util.equals(AtomStaker, a, b);
  }
}

/**
 * @generated from message elys.commitment.NftHolder
 */
export class NftHolder extends Message<NftHolder> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<NftHolder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.NftHolder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NftHolder {
    return new NftHolder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NftHolder {
    return new NftHolder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NftHolder {
    return new NftHolder().fromJsonString(jsonString, options);
  }

  static equals(a: NftHolder | PlainMessage<NftHolder> | undefined, b: NftHolder | PlainMessage<NftHolder> | undefined): boolean {
    return proto3.util.equals(NftHolder, a, b);
  }
}

/**
 * @generated from message elys.commitment.Cadet
 */
export class Cadet extends Message<Cadet> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<Cadet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.Cadet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cadet {
    return new Cadet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cadet {
    return new Cadet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cadet {
    return new Cadet().fromJsonString(jsonString, options);
  }

  static equals(a: Cadet | PlainMessage<Cadet> | undefined, b: Cadet | PlainMessage<Cadet> | undefined): boolean {
    return proto3.util.equals(Cadet, a, b);
  }
}

/**
 * @generated from message elys.commitment.Governor
 */
export class Governor extends Message<Governor> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<Governor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.Governor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Governor {
    return new Governor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Governor {
    return new Governor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Governor {
    return new Governor().fromJsonString(jsonString, options);
  }

  static equals(a: Governor | PlainMessage<Governor> | undefined, b: Governor | PlainMessage<Governor> | undefined): boolean {
    return proto3.util.equals(Governor, a, b);
  }
}

/**
 * @generated from message elys.commitment.AirdropClaimed
 */
export class AirdropClaimed extends Message<AirdropClaimed> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: bool claimed = 2;
   */
  claimed = false;

  constructor(data?: PartialMessage<AirdropClaimed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.AirdropClaimed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "claimed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AirdropClaimed {
    return new AirdropClaimed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AirdropClaimed {
    return new AirdropClaimed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AirdropClaimed {
    return new AirdropClaimed().fromJsonString(jsonString, options);
  }

  static equals(a: AirdropClaimed | PlainMessage<AirdropClaimed> | undefined, b: AirdropClaimed | PlainMessage<AirdropClaimed> | undefined): boolean {
    return proto3.util.equals(AirdropClaimed, a, b);
  }
}

/**
 * @generated from message elys.commitment.TotalClaimed
 */
export class TotalClaimed extends Message<TotalClaimed> {
  /**
   * @generated from field: string total_elys_claimed = 1;
   */
  totalElysClaimed = "";

  /**
   * @generated from field: string total_eden_claimed = 2;
   */
  totalEdenClaimed = "";

  constructor(data?: PartialMessage<TotalClaimed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.TotalClaimed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "total_elys_claimed", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "total_eden_claimed", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TotalClaimed {
    return new TotalClaimed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TotalClaimed {
    return new TotalClaimed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TotalClaimed {
    return new TotalClaimed().fromJsonString(jsonString, options);
  }

  static equals(a: TotalClaimed | PlainMessage<TotalClaimed> | undefined, b: TotalClaimed | PlainMessage<TotalClaimed> | undefined): boolean {
    return proto3.util.equals(TotalClaimed, a, b);
  }
}

/**
 * @generated from message elys.commitment.KolList
 */
export class KolList extends Message<KolList> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  /**
   * @generated from field: bool claimed = 3;
   */
  claimed = false;

  /**
   * @generated from field: bool refunded = 4;
   */
  refunded = false;

  constructor(data?: PartialMessage<KolList>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.KolList";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "claimed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "refunded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KolList {
    return new KolList().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KolList {
    return new KolList().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KolList {
    return new KolList().fromJsonString(jsonString, options);
  }

  static equals(a: KolList | PlainMessage<KolList> | undefined, b: KolList | PlainMessage<KolList> | undefined): boolean {
    return proto3.util.equals(KolList, a, b);
  }
}

/**
 * @generated from message elys.commitment.RewardProgram
 */
export class RewardProgram extends Message<RewardProgram> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  /**
   * @generated from field: bool claimed = 3;
   */
  claimed = false;

  constructor(data?: PartialMessage<RewardProgram>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "elys.commitment.RewardProgram";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "claimed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RewardProgram {
    return new RewardProgram().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RewardProgram {
    return new RewardProgram().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RewardProgram {
    return new RewardProgram().fromJsonString(jsonString, options);
  }

  static equals(a: RewardProgram | PlainMessage<RewardProgram> | undefined, b: RewardProgram | PlainMessage<RewardProgram> | undefined): boolean {
    return proto3.util.equals(RewardProgram, a, b);
  }
}

