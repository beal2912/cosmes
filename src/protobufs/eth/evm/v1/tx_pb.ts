// Copyright (c) 2023-2024 Nibi, Inc.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file eth/evm/v1/tx.proto (package eth.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AccessTuple, FunToken, Log, Params } from "./evm_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * MsgEthereumTx encapsulates an Ethereum transaction as an SDK message.
 *
 * @generated from message eth.evm.v1.MsgEthereumTx
 */
export class MsgEthereumTx extends Message<MsgEthereumTx> {
  /**
   * data is inner transaction data of the Ethereum transaction
   *
   * @generated from field: google.protobuf.Any data = 1;
   */
  data?: Any;

  /**
   * size is the encoded storage size of the transaction (DEPRECATED)
   *
   * @generated from field: double size = 2;
   */
  size = 0;

  /**
   * hash of the transaction in hex format
   *
   * @generated from field: string hash = 3;
   */
  hash = "";

  /**
   * from is the ethereum signer address in hex format. This address value is
   * checked against the address derived from the signature (V, R, S) using the
   * secp256k1 elliptic curve
   *
   * @generated from field: string from = 4;
   */
  from = "";

  constructor(data?: PartialMessage<MsgEthereumTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgEthereumTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Any },
    { no: 2, name: "size", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEthereumTx | PlainMessage<MsgEthereumTx> | undefined, b: MsgEthereumTx | PlainMessage<MsgEthereumTx> | undefined): boolean {
    return proto3.util.equals(MsgEthereumTx, a, b);
  }
}

/**
 * LegacyTx is the transaction data of regular Ethereum transactions.
 *
 * Note that setting "evm.Params.AllowUnprotectedTxs" to false will cause all
 * non-EIP155 signed transactions to fail, as they'll lack replay protection.
 *
 * LegacyTx is a custom implementation of "LegacyTx" from
 * "github.com/ethereum/go-ethereum/core/types".
 *
 * @generated from message eth.evm.v1.LegacyTx
 */
export class LegacyTx extends Message<LegacyTx> {
  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * gas_price defines the value for each gas unit
   *
   * @generated from field: string gas_price = 2;
   */
  gasPrice = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 3;
   */
  gas = protoInt64.zero;

  /**
   * to is the hex formatted address of the recipient
   *
   * @generated from field: string to = 4;
   */
  to = "";

  /**
   * value defines the unsigned integer value of the transaction amount.
   *
   * @generated from field: string value = 5;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 6;
   */
  data = new Uint8Array(0);

  /**
   * v defines the recovery id as the "v" signature value from the elliptic
   * curve digital signatute algorithm (ECDSA). It indicates which of two
   * possible solutions should be used to reconstruct the public key from the
   * signature. In Ethereum, "v" takes the value 27 or 28 for transactions that
   * are not relay-protected.
   *
   * @generated from field: bytes v = 7;
   */
  v = new Uint8Array(0);

  /**
   * r defines the x-coordinate of a point on the elliptic curve in the elliptic
   * curve digital signatute algorithm (ECDSA). It's crucial in ensuring
   * uniqueness of the signature.
   *
   * @generated from field: bytes r = 8;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value derived from the private key, message hash,
   * and the value of "r". It ensures that the signature is tied to both the
   * message and the private key of the sender.
   *
   * @generated from field: bytes s = 9;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<LegacyTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.LegacyTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LegacyTx {
    return new LegacyTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LegacyTx {
    return new LegacyTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LegacyTx {
    return new LegacyTx().fromJsonString(jsonString, options);
  }

  static equals(a: LegacyTx | PlainMessage<LegacyTx> | undefined, b: LegacyTx | PlainMessage<LegacyTx> | undefined): boolean {
    return proto3.util.equals(LegacyTx, a, b);
  }
}

/**
 * AccessListTx is the data of EIP-2930 access list transactions.
 * It is a custom implementation of "AccessListTx" from
 * "github.com/ethereum/go-ethereum/core/types".
 *
 * @generated from message eth.evm.v1.AccessListTx
 */
export class AccessListTx extends Message<AccessListTx> {
  /**
   * chain_id of the destination EVM chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * gas_price defines the value for each gas unit
   *
   * @generated from field: string gas_price = 3;
   */
  gasPrice = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 4;
   */
  gas = protoInt64.zero;

  /**
   * to is the recipient address in hex format
   *
   * @generated from field: string to = 5;
   */
  to = "";

  /**
   * value defines the unsigned integer value of the transaction amount.
   *
   * @generated from field: string value = 6;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 7;
   */
  data = new Uint8Array(0);

  /**
   * accesses is an array of access tuples
   *
   * @generated from field: repeated eth.evm.v1.AccessTuple accesses = 8;
   */
  accesses: AccessTuple[] = [];

  /**
   * v defines the recovery id and "v" signature value from the elliptic curve
   * digital signatute algorithm (ECDSA). It indicates which of two possible
   * solutions should be used to reconstruct the public key from the signature.
   * In Ethereum, "v" takes the value 27 or 28 for transactions that are not
   * relay-protected.
   *
   * @generated from field: bytes v = 9;
   */
  v = new Uint8Array(0);

  /**
   * r defines the x-coordinate of a point on the elliptic curve in the elliptic
   * curve digital signatute algorithm (ECDSA). It's crucial in ensuring
   * uniqueness of the signature.
   *
   * @generated from field: bytes r = 10;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value derived from the private key, message hash,
   * and the value of "r". It ensures that the signature is tied to both the
   * message and the private key of the sender.
   *
   * @generated from field: bytes s = 11;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<AccessListTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.AccessListTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "accesses", kind: "message", T: AccessTuple, repeated: true },
    { no: 9, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListTx {
    return new AccessListTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListTx {
    return new AccessListTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListTx {
    return new AccessListTx().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListTx | PlainMessage<AccessListTx> | undefined, b: AccessListTx | PlainMessage<AccessListTx> | undefined): boolean {
    return proto3.util.equals(AccessListTx, a, b);
  }
}

/**
 * DynamicFeeTx is the data of EIP-1559 dynamic fee transactions. It is a custom
 * implementation of "DynamicFeeTx" from
 * "github.com/ethereum/go-ethereum/core/types".
 *
 * @generated from message eth.evm.v1.DynamicFeeTx
 */
export class DynamicFeeTx extends Message<DynamicFeeTx> {
  /**
   * chain_id of the destination EVM chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * gas_tip_cap defines the max value for the gas tip
   *
   * @generated from field: string gas_tip_cap = 3;
   */
  gasTipCap = "";

  /**
   * gas_fee_cap defines the max value for the gas fee
   *
   * @generated from field: string gas_fee_cap = 4;
   */
  gasFeeCap = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 5;
   */
  gas = protoInt64.zero;

  /**
   * to is the hex formatted address of the recipient
   *
   * @generated from field: string to = 6;
   */
  to = "";

  /**
   * value defines the the transaction amount.
   *
   * @generated from field: string value = 7;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 8;
   */
  data = new Uint8Array(0);

  /**
   * accesses is an array of access tuples
   *
   * @generated from field: repeated eth.evm.v1.AccessTuple accesses = 9;
   */
  accesses: AccessTuple[] = [];

  /**
   * v defines the recovery id and "v" signature value from the elliptic curve
   * digital signatute algorithm (ECDSA). It indicates which of two possible
   * solutions should be used to reconstruct the public key from the signature.
   * In Ethereum, "v" takes the value 27 or 28 for transactions that are not
   * relay-protected.
   *
   * @generated from field: bytes v = 10;
   */
  v = new Uint8Array(0);

  /**
   * r defines the x-coordinate of a point on the elliptic curve in the elliptic
   * curve digital signatute algorithm (ECDSA). It's crucial in ensuring
   * uniqueness of the signature.
   *
   * @generated from field: bytes r = 11;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value derived from the private key, message hash,
   * and the value of "r". It ensures that the signature is tied to both the
   * message and the private key of the sender.
   *
   * @generated from field: bytes s = 12;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<DynamicFeeTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.DynamicFeeTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_tip_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gas_fee_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "accesses", kind: "message", T: AccessTuple, repeated: true },
    { no: 10, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 12, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicFeeTx | PlainMessage<DynamicFeeTx> | undefined, b: DynamicFeeTx | PlainMessage<DynamicFeeTx> | undefined): boolean {
    return proto3.util.equals(DynamicFeeTx, a, b);
  }
}

/**
 * ExtensionOptionsEthereumTx is an extension option for ethereum transactions
 *
 * @generated from message eth.evm.v1.ExtensionOptionsEthereumTx
 */
export class ExtensionOptionsEthereumTx extends Message<ExtensionOptionsEthereumTx> {
  constructor(data?: PartialMessage<ExtensionOptionsEthereumTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.ExtensionOptionsEthereumTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromJsonString(jsonString, options);
  }

  static equals(a: ExtensionOptionsEthereumTx | PlainMessage<ExtensionOptionsEthereumTx> | undefined, b: ExtensionOptionsEthereumTx | PlainMessage<ExtensionOptionsEthereumTx> | undefined): boolean {
    return proto3.util.equals(ExtensionOptionsEthereumTx, a, b);
  }
}

/**
 * MsgEthereumTxResponse defines the Msg/EthereumTx response type.
 *
 * @generated from message eth.evm.v1.MsgEthereumTxResponse
 */
export class MsgEthereumTxResponse extends Message<MsgEthereumTxResponse> {
  /**
   * hash of the ethereum transaction in hex format. This hash differs from the
   * Tendermint sha256 hash of the transaction bytes. See
   * https://github.com/tendermint/tendermint/issues/6539 for reference
   *
   * @generated from field: string hash = 1;
   */
  hash = "";

  /**
   * logs contains the transaction hash and the proto-compatible ethereum
   * logs.
   *
   * @generated from field: repeated eth.evm.v1.Log logs = 2;
   */
  logs: Log[] = [];

  /**
   * ret is the returned data from evm function (result or data supplied with
   * revert opcode)
   *
   * @generated from field: bytes ret = 3;
   */
  ret = new Uint8Array(0);

  /**
   * vm_error is the error returned by vm execution
   *
   * @generated from field: string vm_error = 4;
   */
  vmError = "";

  /**
   * gas_used specifies how much gas was consumed by the transaction
   *
   * @generated from field: uint64 gas_used = 5;
   */
  gasUsed = protoInt64.zero;

  constructor(data?: PartialMessage<MsgEthereumTxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgEthereumTxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "logs", kind: "message", T: Log, repeated: true },
    { no: 3, name: "ret", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "vm_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEthereumTxResponse | PlainMessage<MsgEthereumTxResponse> | undefined, b: MsgEthereumTxResponse | PlainMessage<MsgEthereumTxResponse> | undefined): boolean {
    return proto3.util.equals(MsgEthereumTxResponse, a, b);
  }
}

/**
 * MsgUpdateParams defines a Msg for updating the x/evm module parameters.
 *
 * @generated from message eth.evm.v1.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address of the governance account.
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the x/evm parameters to update.
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: eth.evm.v1.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from message eth.evm.v1.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

/**
 * MsgCreateFunToken: Arguments to create a "FunToken" mapping. Either the ERC20
 * contract address can be given to create the mapping to a Bank Coin, or the
 * denomination for a Bank Coin can be given to create the mapping to an ERC20.
 *
 * @generated from message eth.evm.v1.MsgCreateFunToken
 */
export class MsgCreateFunToken extends Message<MsgCreateFunToken> {
  /**
   * Hexadecimal address of the ERC20 token to which the `FunToken` maps
   *
   * @generated from field: string from_erc20 = 1;
   */
  fromErc20 = "";

  /**
   * Coin denomination in the Bank Module.
   *
   * @generated from field: string from_bank_denom = 2;
   */
  fromBankDenom = "";

  /**
   * Sender: Address for the signer of the transaction.
   *
   * @generated from field: string sender = 3;
   */
  sender = "";

  /**
   * Optional flag to allow the `FunToken` mapping to be created with 0 decimals
   * in the ERC20 sense. Often times, tokens are meant to behave like money and
   * be divisible, meaning "decimals = 0" is often a mistake. This field defaults
   * to false as a safety guard against accidental creation of FunTokens with
   * missing metadata.
   * Set this to true if the token is truly intended to have 0 decimals.
   *
   * @generated from field: bool allow_zero_decimals = 4;
   */
  allowZeroDecimals = false;

  constructor(data?: PartialMessage<MsgCreateFunToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgCreateFunToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from_erc20", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "from_bank_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "allow_zero_decimals", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateFunToken {
    return new MsgCreateFunToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateFunToken {
    return new MsgCreateFunToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateFunToken {
    return new MsgCreateFunToken().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateFunToken | PlainMessage<MsgCreateFunToken> | undefined, b: MsgCreateFunToken | PlainMessage<MsgCreateFunToken> | undefined): boolean {
    return proto3.util.equals(MsgCreateFunToken, a, b);
  }
}

/**
 * @generated from message eth.evm.v1.MsgCreateFunTokenResponse
 */
export class MsgCreateFunTokenResponse extends Message<MsgCreateFunTokenResponse> {
  /**
   * Fungible token mapping corresponding to ERC20 tokens.
   *
   * @generated from field: eth.evm.v1.FunToken funtoken_mapping = 1;
   */
  funtokenMapping?: FunToken;

  constructor(data?: PartialMessage<MsgCreateFunTokenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgCreateFunTokenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "funtoken_mapping", kind: "message", T: FunToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateFunTokenResponse {
    return new MsgCreateFunTokenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateFunTokenResponse {
    return new MsgCreateFunTokenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateFunTokenResponse {
    return new MsgCreateFunTokenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateFunTokenResponse | PlainMessage<MsgCreateFunTokenResponse> | undefined, b: MsgCreateFunTokenResponse | PlainMessage<MsgCreateFunTokenResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateFunTokenResponse, a, b);
  }
}

/**
 * MsgConvertCoinToEvm: Arguments to send a Bank Coin to ERC-20 representation
 *
 * @generated from message eth.evm.v1.MsgConvertCoinToEvm
 */
export class MsgConvertCoinToEvm extends Message<MsgConvertCoinToEvm> {
  /**
   * Hexadecimal address of the ERC20 token to which the `FunToken` maps
   *
   * @generated from field: string to_eth_addr = 1;
   */
  toEthAddr = "";

  /**
   * Sender: Address for the signer of the transaction.
   *
   * @generated from field: string sender = 2;
   */
  sender = "";

  /**
   * Bank Coin to get converted to ERC20
   *
   * @generated from field: cosmos.base.v1beta1.Coin bank_coin = 3;
   */
  bankCoin?: Coin;

  constructor(data?: PartialMessage<MsgConvertCoinToEvm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgConvertCoinToEvm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "to_eth_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "bank_coin", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertCoinToEvm {
    return new MsgConvertCoinToEvm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertCoinToEvm {
    return new MsgConvertCoinToEvm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertCoinToEvm {
    return new MsgConvertCoinToEvm().fromJsonString(jsonString, options);
  }

  static equals(a: MsgConvertCoinToEvm | PlainMessage<MsgConvertCoinToEvm> | undefined, b: MsgConvertCoinToEvm | PlainMessage<MsgConvertCoinToEvm> | undefined): boolean {
    return proto3.util.equals(MsgConvertCoinToEvm, a, b);
  }
}

/**
 * @generated from message eth.evm.v1.MsgConvertCoinToEvmResponse
 */
export class MsgConvertCoinToEvmResponse extends Message<MsgConvertCoinToEvmResponse> {
  constructor(data?: PartialMessage<MsgConvertCoinToEvmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgConvertCoinToEvmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertCoinToEvmResponse {
    return new MsgConvertCoinToEvmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertCoinToEvmResponse {
    return new MsgConvertCoinToEvmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertCoinToEvmResponse {
    return new MsgConvertCoinToEvmResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgConvertCoinToEvmResponse | PlainMessage<MsgConvertCoinToEvmResponse> | undefined, b: MsgConvertCoinToEvmResponse | PlainMessage<MsgConvertCoinToEvmResponse> | undefined): boolean {
    return proto3.util.equals(MsgConvertCoinToEvmResponse, a, b);
  }
}

/**
 * MsgConvertEvmToCoin: Arguments to send an ERC20 token to bank coin representation
 *
 * @generated from message eth.evm.v1.MsgConvertEvmToCoin
 */
export class MsgConvertEvmToCoin extends Message<MsgConvertEvmToCoin> {
  /**
   * Sender: "nibi"-prefixed Bech32 address for the signer of the transaction.
   * This is also the address whose ERC20 balance will be deducted.
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * Hexadecimal address of the ERC20 token to be converted and sent
   *
   * @generated from field: string erc20_addr = 2;
   */
  erc20Addr = "";

  /**
   * Amount of ERC20 tokens to convert
   *
   * @generated from field: string amount = 3;
   */
  amount = "";

  /**
   * Recipient address for the bank coins in Ethereum hexadecimal or
   * nibi-prefixed Bech32 format.
   *
   * Currently, accounts corresponding to Wasm contracts cannot hold ERC20 tokens
   * because the function that maps between Bech32 and Eth hex addresses is not
   * bijective for these types of accounts.
   *
   * See [bug(evm): nibid q evm account is not symmetric for wasm
   * addresses](https://github.com/NibiruChain/nibiru/issues/2138)
   *
   * @generated from field: string to_addr = 4;
   */
  toAddr = "";

  constructor(data?: PartialMessage<MsgConvertEvmToCoin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgConvertEvmToCoin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "erc20_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "to_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertEvmToCoin {
    return new MsgConvertEvmToCoin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertEvmToCoin {
    return new MsgConvertEvmToCoin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertEvmToCoin {
    return new MsgConvertEvmToCoin().fromJsonString(jsonString, options);
  }

  static equals(a: MsgConvertEvmToCoin | PlainMessage<MsgConvertEvmToCoin> | undefined, b: MsgConvertEvmToCoin | PlainMessage<MsgConvertEvmToCoin> | undefined): boolean {
    return proto3.util.equals(MsgConvertEvmToCoin, a, b);
  }
}

/**
 * @generated from message eth.evm.v1.MsgConvertEvmToCoinResponse
 */
export class MsgConvertEvmToCoinResponse extends Message<MsgConvertEvmToCoinResponse> {
  constructor(data?: PartialMessage<MsgConvertEvmToCoinResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.MsgConvertEvmToCoinResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgConvertEvmToCoinResponse {
    return new MsgConvertEvmToCoinResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgConvertEvmToCoinResponse {
    return new MsgConvertEvmToCoinResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgConvertEvmToCoinResponse {
    return new MsgConvertEvmToCoinResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgConvertEvmToCoinResponse | PlainMessage<MsgConvertEvmToCoinResponse> | undefined, b: MsgConvertEvmToCoinResponse | PlainMessage<MsgConvertEvmToCoinResponse> | undefined): boolean {
    return proto3.util.equals(MsgConvertEvmToCoinResponse, a, b);
  }
}

