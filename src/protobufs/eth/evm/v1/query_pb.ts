// Copyright (c) 2023-2024 Nibi, Inc.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file eth/evm/v1/query.proto (package eth.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination_pb.js";
import { FunToken, Log, Params, TraceConfig } from "./evm_pb.js";
import { MsgEthereumTx } from "./tx_pb.js";

/**
 * QueryEthAccountRequest: Request type for "/eth.evm.v1.Query/EthAccount"
 *
 * @generated from message eth.evm.v1.QueryEthAccountRequest
 */
export class QueryEthAccountRequest extends Message<QueryEthAccountRequest> {
  /**
   * address is the Ethereum hex address or nibi Bech32 address to query the account for.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryEthAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryEthAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryEthAccountRequest {
    return new QueryEthAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryEthAccountRequest {
    return new QueryEthAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryEthAccountRequest {
    return new QueryEthAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryEthAccountRequest | PlainMessage<QueryEthAccountRequest> | undefined, b: QueryEthAccountRequest | PlainMessage<QueryEthAccountRequest> | undefined): boolean {
    return proto3.util.equals(QueryEthAccountRequest, a, b);
  }
}

/**
 * QueryEthAccountResponse: Response type for "/eth.evm.v1.Query/EthAccount"
 *
 * @generated from message eth.evm.v1.QueryEthAccountResponse
 */
export class QueryEthAccountResponse extends Message<QueryEthAccountResponse> {
  /**
   * balance_wei is the balance of wei (attoNIBI, since NIBI is ether).
   *
   * @generated from field: string balance_wei = 2;
   */
  balanceWei = "";

  /**
   * code_hash is the hex-encoded hash of the contract bytecode for the
   * account. Ethereum defines a code hash as the keccack 256 hash of the bytes.
   * Note that externally owned accounts (EOAs) have the empty/nil code hash
   * (`crypto.Keccak256(nil)`).
   *
   * @generated from field: string code_hash = 3;
   */
  codeHash = "";

  /**
   * nonce is the account's sequence number.
   *
   * @generated from field: uint64 nonce = 4;
   */
  nonce = protoInt64.zero;

  /**
   * eth_address: The hexadecimal-encoded string representing the 20 byte
   * address of a Nibiru EVM account. Note that this field may be empty if the
   * account queried is a Wasm contract (32 byte address).
   *
   * @generated from field: string eth_address = 5;
   */
  ethAddress = "";

  /**
   * bech32_address is the nibi-prefixed address of the account that can receive
   * bank transfers ("cosmos.bank.v1beta1.MsgSend").
   *
   * @generated from field: string bech32_address = 6;
   */
  bech32Address = "";

  constructor(data?: PartialMessage<QueryEthAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryEthAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "balance_wei", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "eth_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "bech32_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryEthAccountResponse {
    return new QueryEthAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryEthAccountResponse {
    return new QueryEthAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryEthAccountResponse {
    return new QueryEthAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryEthAccountResponse | PlainMessage<QueryEthAccountResponse> | undefined, b: QueryEthAccountResponse | PlainMessage<QueryEthAccountResponse> | undefined): boolean {
    return proto3.util.equals(QueryEthAccountResponse, a, b);
  }
}

/**
 * QueryValidatorAccountRequest is the request type for the
 * Query/ValidatorAccount RPC method.
 *
 * @generated from message eth.evm.v1.QueryValidatorAccountRequest
 */
export class QueryValidatorAccountRequest extends Message<QueryValidatorAccountRequest> {
  /**
   * cons_address is the validator cons address to query the account for.
   *
   * @generated from field: string cons_address = 1;
   */
  consAddress = "";

  constructor(data?: PartialMessage<QueryValidatorAccountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryValidatorAccountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cons_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorAccountRequest {
    return new QueryValidatorAccountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorAccountRequest {
    return new QueryValidatorAccountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorAccountRequest {
    return new QueryValidatorAccountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorAccountRequest | PlainMessage<QueryValidatorAccountRequest> | undefined, b: QueryValidatorAccountRequest | PlainMessage<QueryValidatorAccountRequest> | undefined): boolean {
    return proto3.util.equals(QueryValidatorAccountRequest, a, b);
  }
}

/**
 * QueryValidatorAccountResponse is the response type for the
 * Query/ValidatorAccount RPC method.
 *
 * @generated from message eth.evm.v1.QueryValidatorAccountResponse
 */
export class QueryValidatorAccountResponse extends Message<QueryValidatorAccountResponse> {
  /**
   * account_address is the Nibiru address of the account in bech32 format.
   *
   * @generated from field: string account_address = 1;
   */
  accountAddress = "";

  /**
   * sequence is the account's sequence number.
   *
   * @generated from field: uint64 sequence = 2;
   */
  sequence = protoInt64.zero;

  /**
   * account_number is the account number
   *
   * @generated from field: uint64 account_number = 3;
   */
  accountNumber = protoInt64.zero;

  constructor(data?: PartialMessage<QueryValidatorAccountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryValidatorAccountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "account_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryValidatorAccountResponse {
    return new QueryValidatorAccountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryValidatorAccountResponse {
    return new QueryValidatorAccountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryValidatorAccountResponse {
    return new QueryValidatorAccountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryValidatorAccountResponse | PlainMessage<QueryValidatorAccountResponse> | undefined, b: QueryValidatorAccountResponse | PlainMessage<QueryValidatorAccountResponse> | undefined): boolean {
    return proto3.util.equals(QueryValidatorAccountResponse, a, b);
  }
}

/**
 * QueryBalanceRequest: Response type for "/eth.evm.v1.Query/Balance"
 *
 * @generated from message eth.evm.v1.QueryBalanceRequest
 */
export class QueryBalanceRequest extends Message<QueryBalanceRequest> {
  /**
   * address is the ethereum hex address to query the balance for.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryBalanceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryBalanceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceRequest {
    return new QueryBalanceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceRequest {
    return new QueryBalanceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceRequest {
    return new QueryBalanceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceRequest | PlainMessage<QueryBalanceRequest> | undefined, b: QueryBalanceRequest | PlainMessage<QueryBalanceRequest> | undefined): boolean {
    return proto3.util.equals(QueryBalanceRequest, a, b);
  }
}

/**
 * QueryBalanceResponse: Response type for "/eth.evm.v1.Query/Balance"
 *
 * @generated from message eth.evm.v1.QueryBalanceResponse
 */
export class QueryBalanceResponse extends Message<QueryBalanceResponse> {
  /**
   * balance is the balance of the EVM denomination in units of wei. 1 wei is 1
   * attoNIBI.
   *
   * @generated from field: string balance_wei = 2;
   */
  balanceWei = "";

  constructor(data?: PartialMessage<QueryBalanceResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryBalanceResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "balance_wei", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBalanceResponse {
    return new QueryBalanceResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBalanceResponse {
    return new QueryBalanceResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBalanceResponse {
    return new QueryBalanceResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBalanceResponse | PlainMessage<QueryBalanceResponse> | undefined, b: QueryBalanceResponse | PlainMessage<QueryBalanceResponse> | undefined): boolean {
    return proto3.util.equals(QueryBalanceResponse, a, b);
  }
}

/**
 * QueryStorageRequest is the request type for the Query/Storage RPC method.
 *
 * @generated from message eth.evm.v1.QueryStorageRequest
 */
export class QueryStorageRequest extends Message<QueryStorageRequest> {
  /**
   * address is the ethereum hex address to query the storage state for.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * key defines the key of the storage state
   *
   * @generated from field: string key = 2;
   */
  key = "";

  constructor(data?: PartialMessage<QueryStorageRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryStorageRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryStorageRequest {
    return new QueryStorageRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryStorageRequest {
    return new QueryStorageRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryStorageRequest {
    return new QueryStorageRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryStorageRequest | PlainMessage<QueryStorageRequest> | undefined, b: QueryStorageRequest | PlainMessage<QueryStorageRequest> | undefined): boolean {
    return proto3.util.equals(QueryStorageRequest, a, b);
  }
}

/**
 * QueryStorageResponse is the response type for the Query/Storage RPC
 * method.
 *
 * @generated from message eth.evm.v1.QueryStorageResponse
 */
export class QueryStorageResponse extends Message<QueryStorageResponse> {
  /**
   * value defines the storage state value hash associated with the given key.
   *
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<QueryStorageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryStorageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryStorageResponse {
    return new QueryStorageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryStorageResponse {
    return new QueryStorageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryStorageResponse {
    return new QueryStorageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryStorageResponse | PlainMessage<QueryStorageResponse> | undefined, b: QueryStorageResponse | PlainMessage<QueryStorageResponse> | undefined): boolean {
    return proto3.util.equals(QueryStorageResponse, a, b);
  }
}

/**
 * QueryCodeRequest is the request type for the Query/Code RPC method.
 *
 * @generated from message eth.evm.v1.QueryCodeRequest
 */
export class QueryCodeRequest extends Message<QueryCodeRequest> {
  /**
   * address is the ethereum hex address to query the code for.
   *
   * @generated from field: string address = 1;
   */
  address = "";

  constructor(data?: PartialMessage<QueryCodeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryCodeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCodeRequest {
    return new QueryCodeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCodeRequest {
    return new QueryCodeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCodeRequest {
    return new QueryCodeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCodeRequest | PlainMessage<QueryCodeRequest> | undefined, b: QueryCodeRequest | PlainMessage<QueryCodeRequest> | undefined): boolean {
    return proto3.util.equals(QueryCodeRequest, a, b);
  }
}

/**
 * QueryCodeResponse is the response type for the Query/Code RPC
 * method.
 *
 * @generated from message eth.evm.v1.QueryCodeResponse
 */
export class QueryCodeResponse extends Message<QueryCodeResponse> {
  /**
   * code represents the code bytes from an ethereum address.
   *
   * @generated from field: bytes code = 1;
   */
  code = new Uint8Array(0);

  constructor(data?: PartialMessage<QueryCodeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryCodeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryCodeResponse {
    return new QueryCodeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryCodeResponse {
    return new QueryCodeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryCodeResponse {
    return new QueryCodeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryCodeResponse | PlainMessage<QueryCodeResponse> | undefined, b: QueryCodeResponse | PlainMessage<QueryCodeResponse> | undefined): boolean {
    return proto3.util.equals(QueryCodeResponse, a, b);
  }
}

/**
 * QueryTxLogsRequest is the request type for the Query/TxLogs RPC method.
 *
 * @generated from message eth.evm.v1.QueryTxLogsRequest
 */
export class QueryTxLogsRequest extends Message<QueryTxLogsRequest> {
  /**
   * hash is the ethereum transaction hex hash to query the logs for.
   *
   * @generated from field: string hash = 1;
   */
  hash = "";

  /**
   * pagination defines an optional pagination for the request.
   *
   * @generated from field: cosmos.base.query.v1beta1.PageRequest pagination = 2;
   */
  pagination?: PageRequest;

  constructor(data?: PartialMessage<QueryTxLogsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTxLogsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pagination", kind: "message", T: PageRequest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTxLogsRequest {
    return new QueryTxLogsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTxLogsRequest {
    return new QueryTxLogsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTxLogsRequest {
    return new QueryTxLogsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTxLogsRequest | PlainMessage<QueryTxLogsRequest> | undefined, b: QueryTxLogsRequest | PlainMessage<QueryTxLogsRequest> | undefined): boolean {
    return proto3.util.equals(QueryTxLogsRequest, a, b);
  }
}

/**
 * QueryTxLogsResponse is the response type for the Query/TxLogs RPC method.
 *
 * @generated from message eth.evm.v1.QueryTxLogsResponse
 */
export class QueryTxLogsResponse extends Message<QueryTxLogsResponse> {
  /**
   * logs represents the ethereum logs generated from the given transaction.
   *
   * @generated from field: repeated eth.evm.v1.Log logs = 1;
   */
  logs: Log[] = [];

  /**
   * pagination defines the pagination in the response.
   *
   * @generated from field: cosmos.base.query.v1beta1.PageResponse pagination = 2;
   */
  pagination?: PageResponse;

  constructor(data?: PartialMessage<QueryTxLogsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTxLogsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "logs", kind: "message", T: Log, repeated: true },
    { no: 2, name: "pagination", kind: "message", T: PageResponse },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTxLogsResponse {
    return new QueryTxLogsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTxLogsResponse {
    return new QueryTxLogsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTxLogsResponse {
    return new QueryTxLogsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTxLogsResponse | PlainMessage<QueryTxLogsResponse> | undefined, b: QueryTxLogsResponse | PlainMessage<QueryTxLogsResponse> | undefined): boolean {
    return proto3.util.equals(QueryTxLogsResponse, a, b);
  }
}

/**
 * QueryParamsRequest defines the request type for querying x/evm parameters.
 *
 * @generated from message eth.evm.v1.QueryParamsRequest
 */
export class QueryParamsRequest extends Message<QueryParamsRequest> {
  constructor(data?: PartialMessage<QueryParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsRequest {
    return new QueryParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined, b: QueryParamsRequest | PlainMessage<QueryParamsRequest> | undefined): boolean {
    return proto3.util.equals(QueryParamsRequest, a, b);
  }
}

/**
 * QueryParamsResponse defines the response type for querying x/evm parameters.
 *
 * @generated from message eth.evm.v1.QueryParamsResponse
 */
export class QueryParamsResponse extends Message<QueryParamsResponse> {
  /**
   * params define the evm module parameters.
   *
   * @generated from field: eth.evm.v1.Params params = 1;
   */
  params?: Params;

  constructor(data?: PartialMessage<QueryParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryParamsResponse {
    return new QueryParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined, b: QueryParamsResponse | PlainMessage<QueryParamsResponse> | undefined): boolean {
    return proto3.util.equals(QueryParamsResponse, a, b);
  }
}

/**
 * EthCallRequest defines EthCall request
 *
 * @generated from message eth.evm.v1.EthCallRequest
 */
export class EthCallRequest extends Message<EthCallRequest> {
  /**
   * args uses the same json format as the json rpc api.
   *
   * @generated from field: bytes args = 1;
   */
  args = new Uint8Array(0);

  /**
   * gas_cap defines the default gas cap to be used
   *
   * @generated from field: uint64 gas_cap = 2;
   */
  gasCap = protoInt64.zero;

  /**
   * proposer_address of the requested block in hex format
   *
   * @generated from field: bytes proposer_address = 3;
   */
  proposerAddress = new Uint8Array(0);

  /**
   * chain_id is the eip155 chain id parsed from the requested block header
   *
   * @generated from field: int64 chain_id = 4;
   */
  chainId = protoInt64.zero;

  constructor(data?: PartialMessage<EthCallRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EthCallRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "args", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "gas_cap", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "proposer_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EthCallRequest {
    return new EthCallRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EthCallRequest {
    return new EthCallRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EthCallRequest {
    return new EthCallRequest().fromJsonString(jsonString, options);
  }

  static equals(a: EthCallRequest | PlainMessage<EthCallRequest> | undefined, b: EthCallRequest | PlainMessage<EthCallRequest> | undefined): boolean {
    return proto3.util.equals(EthCallRequest, a, b);
  }
}

/**
 * EstimateGasResponse defines EstimateGas response
 *
 * @generated from message eth.evm.v1.EstimateGasResponse
 */
export class EstimateGasResponse extends Message<EstimateGasResponse> {
  /**
   * gas returns the estimated gas
   *
   * @generated from field: uint64 gas = 1;
   */
  gas = protoInt64.zero;

  constructor(data?: PartialMessage<EstimateGasResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EstimateGasResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EstimateGasResponse {
    return new EstimateGasResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EstimateGasResponse {
    return new EstimateGasResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EstimateGasResponse {
    return new EstimateGasResponse().fromJsonString(jsonString, options);
  }

  static equals(a: EstimateGasResponse | PlainMessage<EstimateGasResponse> | undefined, b: EstimateGasResponse | PlainMessage<EstimateGasResponse> | undefined): boolean {
    return proto3.util.equals(EstimateGasResponse, a, b);
  }
}

/**
 * QueryTraceTxRequest defines TraceTx request
 *
 * @generated from message eth.evm.v1.QueryTraceTxRequest
 */
export class QueryTraceTxRequest extends Message<QueryTraceTxRequest> {
  /**
   * msg is the MsgEthereumTx for the requested transaction
   *
   * @generated from field: eth.evm.v1.MsgEthereumTx msg = 1;
   */
  msg?: MsgEthereumTx;

  /**
   * trace_config holds extra parameters to trace functions.
   *
   * @generated from field: eth.evm.v1.TraceConfig trace_config = 3;
   */
  traceConfig?: TraceConfig;

  /**
   * predecessors is an array of transactions included in the same block
   * need to be replayed first to get correct context for tracing.
   *
   * @generated from field: repeated eth.evm.v1.MsgEthereumTx predecessors = 4;
   */
  predecessors: MsgEthereumTx[] = [];

  /**
   * block_number of requested transaction
   *
   * @generated from field: int64 block_number = 5;
   */
  blockNumber = protoInt64.zero;

  /**
   * block_hash of requested transaction
   *
   * @generated from field: string block_hash = 6;
   */
  blockHash = "";

  /**
   * block_time of requested transaction
   *
   * @generated from field: google.protobuf.Timestamp block_time = 7;
   */
  blockTime?: Timestamp;

  /**
   * proposer_address is the proposer of the requested block
   *
   * @generated from field: bytes proposer_address = 8;
   */
  proposerAddress = new Uint8Array(0);

  /**
   * chain_id is the the eip155 chain id parsed from the requested block header
   *
   * @generated from field: int64 chain_id = 9;
   */
  chainId = protoInt64.zero;

  /**
   * block_max_gas of the block of the requested transaction
   *
   * @generated from field: int64 block_max_gas = 10;
   */
  blockMaxGas = protoInt64.zero;

  constructor(data?: PartialMessage<QueryTraceTxRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTraceTxRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msg", kind: "message", T: MsgEthereumTx },
    { no: 3, name: "trace_config", kind: "message", T: TraceConfig },
    { no: 4, name: "predecessors", kind: "message", T: MsgEthereumTx, repeated: true },
    { no: 5, name: "block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "block_time", kind: "message", T: Timestamp },
    { no: 8, name: "proposer_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "block_max_gas", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraceTxRequest {
    return new QueryTraceTxRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraceTxRequest {
    return new QueryTraceTxRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraceTxRequest {
    return new QueryTraceTxRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraceTxRequest | PlainMessage<QueryTraceTxRequest> | undefined, b: QueryTraceTxRequest | PlainMessage<QueryTraceTxRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraceTxRequest, a, b);
  }
}

/**
 * QueryTraceTxResponse defines TraceTx response
 *
 * @generated from message eth.evm.v1.QueryTraceTxResponse
 */
export class QueryTraceTxResponse extends Message<QueryTraceTxResponse> {
  /**
   * data is the response serialized in bytes
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<QueryTraceTxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTraceTxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraceTxResponse {
    return new QueryTraceTxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraceTxResponse {
    return new QueryTraceTxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraceTxResponse {
    return new QueryTraceTxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraceTxResponse | PlainMessage<QueryTraceTxResponse> | undefined, b: QueryTraceTxResponse | PlainMessage<QueryTraceTxResponse> | undefined): boolean {
    return proto3.util.equals(QueryTraceTxResponse, a, b);
  }
}

/**
 * QueryTraceBlockRequest defines TraceTx request
 *
 * @generated from message eth.evm.v1.QueryTraceBlockRequest
 */
export class QueryTraceBlockRequest extends Message<QueryTraceBlockRequest> {
  /**
   * txs is an array of messages in the block
   *
   * @generated from field: repeated eth.evm.v1.MsgEthereumTx txs = 1;
   */
  txs: MsgEthereumTx[] = [];

  /**
   * trace_config holds extra parameters to trace functions.
   *
   * @generated from field: eth.evm.v1.TraceConfig trace_config = 3;
   */
  traceConfig?: TraceConfig;

  /**
   * block_number of the traced block
   *
   * @generated from field: int64 block_number = 5;
   */
  blockNumber = protoInt64.zero;

  /**
   * block_hash (hex) of the traced block
   *
   * @generated from field: string block_hash = 6;
   */
  blockHash = "";

  /**
   * block_time of the traced block
   *
   * @generated from field: google.protobuf.Timestamp block_time = 7;
   */
  blockTime?: Timestamp;

  /**
   * proposer_address is the address of the requested block
   *
   * @generated from field: bytes proposer_address = 8;
   */
  proposerAddress = new Uint8Array(0);

  /**
   * chain_id is the eip155 chain id parsed from the requested block header
   *
   * @generated from field: int64 chain_id = 9;
   */
  chainId = protoInt64.zero;

  /**
   * block_max_gas of the traced block
   *
   * @generated from field: int64 block_max_gas = 10;
   */
  blockMaxGas = protoInt64.zero;

  constructor(data?: PartialMessage<QueryTraceBlockRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTraceBlockRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "txs", kind: "message", T: MsgEthereumTx, repeated: true },
    { no: 3, name: "trace_config", kind: "message", T: TraceConfig },
    { no: 5, name: "block_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "block_time", kind: "message", T: Timestamp },
    { no: 8, name: "proposer_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "chain_id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "block_max_gas", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraceBlockRequest {
    return new QueryTraceBlockRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraceBlockRequest {
    return new QueryTraceBlockRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraceBlockRequest {
    return new QueryTraceBlockRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraceBlockRequest | PlainMessage<QueryTraceBlockRequest> | undefined, b: QueryTraceBlockRequest | PlainMessage<QueryTraceBlockRequest> | undefined): boolean {
    return proto3.util.equals(QueryTraceBlockRequest, a, b);
  }
}

/**
 * QueryTraceBlockResponse defines TraceBlock response
 *
 * @generated from message eth.evm.v1.QueryTraceBlockResponse
 */
export class QueryTraceBlockResponse extends Message<QueryTraceBlockResponse> {
  /**
   * data is the response serialized in bytes
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<QueryTraceBlockResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryTraceBlockResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryTraceBlockResponse {
    return new QueryTraceBlockResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryTraceBlockResponse {
    return new QueryTraceBlockResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryTraceBlockResponse {
    return new QueryTraceBlockResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryTraceBlockResponse | PlainMessage<QueryTraceBlockResponse> | undefined, b: QueryTraceBlockResponse | PlainMessage<QueryTraceBlockResponse> | undefined): boolean {
    return proto3.util.equals(QueryTraceBlockResponse, a, b);
  }
}

/**
 * QueryBaseFeeRequest defines the request type for querying the EIP1559 base
 * fee.
 *
 * @generated from message eth.evm.v1.QueryBaseFeeRequest
 */
export class QueryBaseFeeRequest extends Message<QueryBaseFeeRequest> {
  constructor(data?: PartialMessage<QueryBaseFeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryBaseFeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBaseFeeRequest {
    return new QueryBaseFeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBaseFeeRequest {
    return new QueryBaseFeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBaseFeeRequest {
    return new QueryBaseFeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBaseFeeRequest | PlainMessage<QueryBaseFeeRequest> | undefined, b: QueryBaseFeeRequest | PlainMessage<QueryBaseFeeRequest> | undefined): boolean {
    return proto3.util.equals(QueryBaseFeeRequest, a, b);
  }
}

/**
 * QueryBaseFeeResponse returns the EIP1559 base fee.
 * See https://github.com/ethereum/EIPs/blob/ba6c342c23164072adb500c3136e3ae6eabff306/EIPS/eip-1559.md.
 *
 * @generated from message eth.evm.v1.QueryBaseFeeResponse
 */
export class QueryBaseFeeResponse extends Message<QueryBaseFeeResponse> {
  /**
   * base_fee is the EIP1559 base fee in units of wei.
   *
   * @generated from field: string base_fee = 1;
   */
  baseFee = "";

  /**
   * base_fee is the EIP1559 base fee in units of micronibi ("unibi").
   *
   * @generated from field: string base_fee_unibi = 2;
   */
  baseFeeUnibi = "";

  constructor(data?: PartialMessage<QueryBaseFeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryBaseFeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "base_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_fee_unibi", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryBaseFeeResponse {
    return new QueryBaseFeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryBaseFeeResponse {
    return new QueryBaseFeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryBaseFeeResponse {
    return new QueryBaseFeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryBaseFeeResponse | PlainMessage<QueryBaseFeeResponse> | undefined, b: QueryBaseFeeResponse | PlainMessage<QueryBaseFeeResponse> | undefined): boolean {
    return proto3.util.equals(QueryBaseFeeResponse, a, b);
  }
}

/**
 * @generated from message eth.evm.v1.QueryFunTokenMappingRequest
 */
export class QueryFunTokenMappingRequest extends Message<QueryFunTokenMappingRequest> {
  /**
   * Either the hexadecimal-encoded ERC20 contract address or denomination of the
   * Bank Coin.
   *
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<QueryFunTokenMappingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryFunTokenMappingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFunTokenMappingRequest {
    return new QueryFunTokenMappingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFunTokenMappingRequest {
    return new QueryFunTokenMappingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFunTokenMappingRequest {
    return new QueryFunTokenMappingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFunTokenMappingRequest | PlainMessage<QueryFunTokenMappingRequest> | undefined, b: QueryFunTokenMappingRequest | PlainMessage<QueryFunTokenMappingRequest> | undefined): boolean {
    return proto3.util.equals(QueryFunTokenMappingRequest, a, b);
  }
}

/**
 * @generated from message eth.evm.v1.QueryFunTokenMappingResponse
 */
export class QueryFunTokenMappingResponse extends Message<QueryFunTokenMappingResponse> {
  /**
   * fun_token is a mapping between the Bank Coin and the ERC20 contract address
   *
   * @generated from field: eth.evm.v1.FunToken fun_token = 1;
   */
  funToken?: FunToken;

  constructor(data?: PartialMessage<QueryFunTokenMappingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.QueryFunTokenMappingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fun_token", kind: "message", T: FunToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryFunTokenMappingResponse {
    return new QueryFunTokenMappingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryFunTokenMappingResponse {
    return new QueryFunTokenMappingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryFunTokenMappingResponse {
    return new QueryFunTokenMappingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryFunTokenMappingResponse | PlainMessage<QueryFunTokenMappingResponse> | undefined, b: QueryFunTokenMappingResponse | PlainMessage<QueryFunTokenMappingResponse> | undefined): boolean {
    return proto3.util.equals(QueryFunTokenMappingResponse, a, b);
  }
}

