// Copyright (c) 2023-2024 Nibi, Inc.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file eth/evm/v1/events.proto (package eth.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Log, LogLite } from "./evm_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * EventEthereumTx defines the event for an Ethereum transaction
 *
 * @generated from message eth.evm.v1.EventEthereumTx
 */
export class EventEthereumTx extends Message<EventEthereumTx> {
  /**
   * amount
   *
   * @generated from field: string amount = 1;
   */
  amount = "";

  /**
   * eth_hash is the Ethereum hash of the transaction
   *
   * @generated from field: string eth_hash = 2;
   */
  ethHash = "";

  /**
   * index of the transaction in the block
   *
   * @generated from field: string index = 3;
   */
  index = "";

  /**
   * gas_used is the amount of gas used by the transaction
   *
   * @generated from field: string gas_used = 4;
   */
  gasUsed = "";

  /**
   * hash is the Tendermint hash of the transaction
   *
   * @generated from field: string hash = 5;
   */
  hash = "";

  /**
   * recipient of the transaction
   *
   * @generated from field: string recipient = 6;
   */
  recipient = "";

  /**
   * vm_error contains a VM error should it occur
   *
   * @generated from field: string vm_error = 7;
   */
  vmError = "";

  constructor(data?: PartialMessage<EventEthereumTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventEthereumTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "eth_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "index", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gas_used", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "vm_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventEthereumTx {
    return new EventEthereumTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventEthereumTx {
    return new EventEthereumTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventEthereumTx {
    return new EventEthereumTx().fromJsonString(jsonString, options);
  }

  static equals(a: EventEthereumTx | PlainMessage<EventEthereumTx> | undefined, b: EventEthereumTx | PlainMessage<EventEthereumTx> | undefined): boolean {
    return proto3.util.equals(EventEthereumTx, a, b);
  }
}

/**
 * EventTxLog defines the event for an Ethereum transaction log
 *
 * @generated from message eth.evm.v1.EventTxLog
 */
export class EventTxLog extends Message<EventTxLog> {
  /**
   * tx_logs is an array of transaction logs
   *
   * @generated from field: repeated eth.evm.v1.Log logs = 1;
   */
  logs: Log[] = [];

  constructor(data?: PartialMessage<EventTxLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventTxLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "logs", kind: "message", T: Log, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTxLog {
    return new EventTxLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTxLog {
    return new EventTxLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTxLog {
    return new EventTxLog().fromJsonString(jsonString, options);
  }

  static equals(a: EventTxLog | PlainMessage<EventTxLog> | undefined, b: EventTxLog | PlainMessage<EventTxLog> | undefined): boolean {
    return proto3.util.equals(EventTxLog, a, b);
  }
}

/**
 * EventBlockBloom contains the bloom filter for an Ethereum block.
 * The bloom filter encodes logs for efficient event filtering.
 *
 * @generated from message eth.evm.v1.EventBlockBloom
 */
export class EventBlockBloom extends Message<EventBlockBloom> {
  /**
   * bloom is the bloom filter of the block
   *
   * @generated from field: string bloom = 1;
   */
  bloom = "";

  constructor(data?: PartialMessage<EventBlockBloom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventBlockBloom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bloom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBlockBloom {
    return new EventBlockBloom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBlockBloom {
    return new EventBlockBloom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBlockBloom {
    return new EventBlockBloom().fromJsonString(jsonString, options);
  }

  static equals(a: EventBlockBloom | PlainMessage<EventBlockBloom> | undefined, b: EventBlockBloom | PlainMessage<EventBlockBloom> | undefined): boolean {
    return proto3.util.equals(EventBlockBloom, a, b);
  }
}

/**
 * EventFunTokenCreated defines a fun token creation event.
 *
 * @generated from message eth.evm.v1.EventFunTokenCreated
 */
export class EventFunTokenCreated extends Message<EventFunTokenCreated> {
  /**
   * @generated from field: string bank_denom = 1;
   */
  bankDenom = "";

  /**
   * @generated from field: string erc20_contract_address = 2;
   */
  erc20ContractAddress = "";

  /**
   * @generated from field: string creator = 3;
   */
  creator = "";

  /**
   * @generated from field: bool is_made_from_coin = 4;
   */
  isMadeFromCoin = false;

  constructor(data?: PartialMessage<EventFunTokenCreated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventFunTokenCreated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bank_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "erc20_contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "creator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "is_made_from_coin", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventFunTokenCreated {
    return new EventFunTokenCreated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventFunTokenCreated {
    return new EventFunTokenCreated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventFunTokenCreated {
    return new EventFunTokenCreated().fromJsonString(jsonString, options);
  }

  static equals(a: EventFunTokenCreated | PlainMessage<EventFunTokenCreated> | undefined, b: EventFunTokenCreated | PlainMessage<EventFunTokenCreated> | undefined): boolean {
    return proto3.util.equals(EventFunTokenCreated, a, b);
  }
}

/**
 * EventConvertCoinToEvm is an event emitted when converting Bank Coins into
 * ERC20 tokens with the "eth.evm.v1.MsgConvertCoinToEvm" transaction message.
 *
 * @generated from message eth.evm.v1.EventConvertCoinToEvm
 */
export class EventConvertCoinToEvm extends Message<EventConvertCoinToEvm> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string erc20_contract_address = 2;
   */
  erc20ContractAddress = "";

  /**
   * @generated from field: string to_eth_addr = 3;
   */
  toEthAddr = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin bank_coin = 4;
   */
  bankCoin?: Coin;

  /**
   * @generated from field: repeated eth.evm.v1.LogLite evm_logs = 5;
   */
  evmLogs: LogLite[] = [];

  constructor(data?: PartialMessage<EventConvertCoinToEvm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventConvertCoinToEvm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "erc20_contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "to_eth_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "bank_coin", kind: "message", T: Coin },
    { no: 5, name: "evm_logs", kind: "message", T: LogLite, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConvertCoinToEvm {
    return new EventConvertCoinToEvm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConvertCoinToEvm {
    return new EventConvertCoinToEvm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConvertCoinToEvm {
    return new EventConvertCoinToEvm().fromJsonString(jsonString, options);
  }

  static equals(a: EventConvertCoinToEvm | PlainMessage<EventConvertCoinToEvm> | undefined, b: EventConvertCoinToEvm | PlainMessage<EventConvertCoinToEvm> | undefined): boolean {
    return proto3.util.equals(EventConvertCoinToEvm, a, b);
  }
}

/**
 * EventTransfer defines event for EVM transfer
 *
 * @generated from message eth.evm.v1.EventTransfer
 */
export class EventTransfer extends Message<EventTransfer> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string recipient = 2;
   */
  recipient = "";

  /**
   * @generated from field: string amount = 3;
   */
  amount = "";

  constructor(data?: PartialMessage<EventTransfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventTransfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTransfer {
    return new EventTransfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTransfer {
    return new EventTransfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTransfer {
    return new EventTransfer().fromJsonString(jsonString, options);
  }

  static equals(a: EventTransfer | PlainMessage<EventTransfer> | undefined, b: EventTransfer | PlainMessage<EventTransfer> | undefined): boolean {
    return proto3.util.equals(EventTransfer, a, b);
  }
}

/**
 * EventContractDeployed defines event for EVM contract deployment
 *
 * @generated from message eth.evm.v1.EventContractDeployed
 */
export class EventContractDeployed extends Message<EventContractDeployed> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string contract_addr = 2;
   */
  contractAddr = "";

  constructor(data?: PartialMessage<EventContractDeployed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventContractDeployed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contract_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventContractDeployed {
    return new EventContractDeployed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventContractDeployed {
    return new EventContractDeployed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventContractDeployed {
    return new EventContractDeployed().fromJsonString(jsonString, options);
  }

  static equals(a: EventContractDeployed | PlainMessage<EventContractDeployed> | undefined, b: EventContractDeployed | PlainMessage<EventContractDeployed> | undefined): boolean {
    return proto3.util.equals(EventContractDeployed, a, b);
  }
}

/**
 * EventContractExecuted defines event for EVM contract execution
 *
 * @generated from message eth.evm.v1.EventContractExecuted
 */
export class EventContractExecuted extends Message<EventContractExecuted> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string contract_addr = 2;
   */
  contractAddr = "";

  constructor(data?: PartialMessage<EventContractExecuted>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventContractExecuted";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contract_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventContractExecuted {
    return new EventContractExecuted().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventContractExecuted {
    return new EventContractExecuted().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventContractExecuted {
    return new EventContractExecuted().fromJsonString(jsonString, options);
  }

  static equals(a: EventContractExecuted | PlainMessage<EventContractExecuted> | undefined, b: EventContractExecuted | PlainMessage<EventContractExecuted> | undefined): boolean {
    return proto3.util.equals(EventContractExecuted, a, b);
  }
}

/**
 * EventConvertEvmToCoin is an event emitted when converting ERC20 tokens to Bank
 * Coins with the "eth.evm.v1.MsgConvertEvmToCoin" transaction message.
 *
 * @generated from message eth.evm.v1.EventConvertEvmToCoin
 */
export class EventConvertEvmToCoin extends Message<EventConvertEvmToCoin> {
  /**
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * @generated from field: string erc20_contract_address = 2;
   */
  erc20ContractAddress = "";

  /**
   * @generated from field: string to_address = 3;
   */
  toAddress = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin bank_coin = 4;
   */
  bankCoin?: Coin;

  /**
   * @generated from field: string sender_eth_addr = 6;
   */
  senderEthAddr = "";

  /**
   * @generated from field: repeated eth.evm.v1.LogLite evm_logs = 7;
   */
  evmLogs: LogLite[] = [];

  constructor(data?: PartialMessage<EventConvertEvmToCoin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventConvertEvmToCoin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "erc20_contract_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "to_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "bank_coin", kind: "message", T: Coin },
    { no: 6, name: "sender_eth_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "evm_logs", kind: "message", T: LogLite, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConvertEvmToCoin {
    return new EventConvertEvmToCoin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConvertEvmToCoin {
    return new EventConvertEvmToCoin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConvertEvmToCoin {
    return new EventConvertEvmToCoin().fromJsonString(jsonString, options);
  }

  static equals(a: EventConvertEvmToCoin | PlainMessage<EventConvertEvmToCoin> | undefined, b: EventConvertEvmToCoin | PlainMessage<EventConvertEvmToCoin> | undefined): boolean {
    return proto3.util.equals(EventConvertEvmToCoin, a, b);
  }
}

/**
 * EventWeiBlockDelta is an event emitted when there is a non-zero value for
 * block delta (change) in wei in the EVM end block handler.
 *
 * @generated from message eth.evm.v1.EventWeiBlockDelta
 */
export class EventWeiBlockDelta extends Message<EventWeiBlockDelta> {
  /**
   * net_wei_block_delta is the new sum of all "wei_block_delta" changes up to
   * this point. It is the value for "NetWeiBlockDelta" in the EVM state.
   *
   * @generated from field: string net_wei_block_delta = 1;
   */
  netWeiBlockDelta = "";

  /**
   * WeiBlockDelta is the net sum of all calls of "AddWei" and "SubWei" in the
   * current block. There is no guarantee in the functional sense that the EVM
   * State DB will add the same amount it subtracts. It is possible for the total
   * amount of wei (NIBI) across all accounts to diverge from the initial supply.
   * "WeiBlockDelta" is a mechanism for recording that if it happens.
   *
   * @generated from field: string wei_block_delta = 2;
   */
  weiBlockDelta = "";

  /**
   * block_number for which this event is emitted during EVM EndBlock
   *
   * @generated from field: uint64 block_number = 3;
   */
  blockNumber = protoInt64.zero;

  constructor(data?: PartialMessage<EventWeiBlockDelta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.EventWeiBlockDelta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "net_wei_block_delta", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wei_block_delta", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "block_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventWeiBlockDelta {
    return new EventWeiBlockDelta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventWeiBlockDelta {
    return new EventWeiBlockDelta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventWeiBlockDelta {
    return new EventWeiBlockDelta().fromJsonString(jsonString, options);
  }

  static equals(a: EventWeiBlockDelta | PlainMessage<EventWeiBlockDelta> | undefined, b: EventWeiBlockDelta | PlainMessage<EventWeiBlockDelta> | undefined): boolean {
    return proto3.util.equals(EventWeiBlockDelta, a, b);
  }
}

