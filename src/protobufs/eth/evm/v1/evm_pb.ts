// Copyright (c) 2023-2024 Nibi, Inc.

// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file eth/evm/v1/evm.proto (package eth.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * FunToken is a fungible token mapping between a Bank Coin and a corresponding
 * ERC-20 smart contract. Bank Coins here refer to tokens like NIBI, IBC
 * coins (ICS-20), and token factory coins, which are each represented by the
 * "Coin" type in Golang.
 *
 * @generated from message eth.evm.v1.FunToken
 */
export class FunToken extends Message<FunToken> {
  /**
   * Hexadecimal address of the ERC20 token to which the `FunToken` maps
   *
   * @generated from field: string erc20_addr = 1;
   */
  erc20Addr = "";

  /**
   * bank_denom: Coin denomination in the Bank Module.
   *
   * @generated from field: string bank_denom = 2;
   */
  bankDenom = "";

  /**
   * True if the `FunToken` mapping was created from an existing Bank Coin and
   * the ERC-20 contract gets deployed by the module account. False if the
   * mapping was created from an externally owned ERC-20 contract.
   *
   * @generated from field: bool is_made_from_coin = 3;
   */
  isMadeFromCoin = false;

  constructor(data?: PartialMessage<FunToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.FunToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "erc20_addr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "bank_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_made_from_coin", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FunToken {
    return new FunToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FunToken {
    return new FunToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FunToken {
    return new FunToken().fromJsonString(jsonString, options);
  }

  static equals(a: FunToken | PlainMessage<FunToken> | undefined, b: FunToken | PlainMessage<FunToken> | undefined): boolean {
    return proto3.util.equals(FunToken, a, b);
  }
}

/**
 * Params defines the EVM module parameters
 *
 * @generated from message eth.evm.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * extra_eips defines the additional EIPs for the vm.Config
   *
   * @generated from field: repeated int64 extra_eips = 4;
   */
  extraEips: bigint[] = [];

  /**
   * evm_channels is the list of channel identifiers from EVM compatible chains
   *
   * @generated from field: repeated string evm_channels = 8;
   */
  evmChannels: string[] = [];

  /**
   * Fee deducted and burned when calling "CreateFunToken" in units of
   * "evm_denom".
   *
   * @generated from field: string create_funtoken_fee = 9;
   */
  createFuntokenFee = "";

  /**
   * Hexadecimal address of the canonical WNIBI contract on Nibiru mainnet
   *
   * @generated from field: string canonical_wnibi = 10;
   */
  canonicalWnibi = "";

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "extra_eips", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 8, name: "evm_channels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "create_funtoken_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "canonical_wnibi", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * State represents a single Storage key value pair item.
 *
 * @generated from message eth.evm.v1.State
 */
export class State extends Message<State> {
  /**
   * key is the stored key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * value is the stored value for the given key
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<State>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.State";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): State {
    return new State().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): State {
    return new State().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): State {
    return new State().fromJsonString(jsonString, options);
  }

  static equals(a: State | PlainMessage<State> | undefined, b: State | PlainMessage<State> | undefined): boolean {
    return proto3.util.equals(State, a, b);
  }
}

/**
 * Log represents an protobuf compatible Ethereum Log that defines a contract
 * log event. These events are generated by the LOG opcode and stored/indexed by
 * the node.
 *
 * NOTE: address, topics and data are consensus fields. The rest of the fields
 * are derived, i.e. filled in by the nodes, but not secured by consensus.
 *
 * @generated from message eth.evm.v1.Log
 */
export class Log extends Message<Log> {
  /**
   * address of the contract that generated the event
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * topics is a list of topics provided by the contract.
   *
   * @generated from field: repeated string topics = 2;
   */
  topics: string[] = [];

  /**
   * data which is supplied by the contract, usually ABI-encoded
   *
   * @generated from field: bytes data = 3;
   */
  data = new Uint8Array(0);

  /**
   * block_number of the block in which the transaction was included
   *
   * @generated from field: uint64 block_number = 4;
   */
  blockNumber = protoInt64.zero;

  /**
   * tx_hash is the transaction hash
   *
   * @generated from field: string tx_hash = 5;
   */
  txHash = "";

  /**
   * tx_index of the transaction in the block
   *
   * @generated from field: uint64 tx_index = 6;
   */
  txIndex = protoInt64.zero;

  /**
   * block_hash of the block in which the transaction was included
   *
   * @generated from field: string block_hash = 7;
   */
  blockHash = "";

  /**
   * index of the log in the block
   *
   * @generated from field: uint64 index = 8;
   */
  index = protoInt64.zero;

  /**
   * removed is true if this log was reverted due to a chain
   * reorganisation. You must pay attention to this field if you receive logs
   * through a filter query.
   *
   * @generated from field: bool removed = 9;
   */
  removed = false;

  constructor(data?: PartialMessage<Log>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.Log";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topics", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "block_number", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "tx_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tx_index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 7, name: "block_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "index", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 9, name: "removed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Log {
    return new Log().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Log {
    return new Log().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Log {
    return new Log().fromJsonString(jsonString, options);
  }

  static equals(a: Log | PlainMessage<Log> | undefined, b: Log | PlainMessage<Log> | undefined): boolean {
    return proto3.util.equals(Log, a, b);
  }
}

/**
 * LogLite holds the consensus fields from an Ethereum log for a contract
 * event. This structure is used to record EVM logs emitted within non-Ethreum
 * transactions, such as "eth.evm.v1.MsgConvertCoinToEvm". Similar to full logs,
 * these events are generated by the LOG opcode, however [LogLite] instances are
 * not stored/indexed by the node.
 *
 * @generated from message eth.evm.v1.LogLite
 */
export class LogLite extends Message<LogLite> {
  /**
   * address of the contract that generated the event
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * topics is a list of topics provided by the contract.
   *
   * @generated from field: repeated string topics = 2;
   */
  topics: string[] = [];

  /**
   * data which is supplied by the contract, usually ABI-encoded
   *
   * @generated from field: bytes data = 3;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<LogLite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.LogLite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topics", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogLite {
    return new LogLite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogLite {
    return new LogLite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogLite {
    return new LogLite().fromJsonString(jsonString, options);
  }

  static equals(a: LogLite | PlainMessage<LogLite> | undefined, b: LogLite | PlainMessage<LogLite> | undefined): boolean {
    return proto3.util.equals(LogLite, a, b);
  }
}

/**
 * AccessTuple is the element type of an access list.
 *
 * @generated from message eth.evm.v1.AccessTuple
 */
export class AccessTuple extends Message<AccessTuple> {
  /**
   * address is a hex formatted ethereum address
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * storage_keys are hex formatted hashes of the storage keys
   *
   * @generated from field: repeated string storage_keys = 2;
   */
  storageKeys: string[] = [];

  constructor(data?: PartialMessage<AccessTuple>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.AccessTuple";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "storage_keys", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessTuple {
    return new AccessTuple().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessTuple {
    return new AccessTuple().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessTuple {
    return new AccessTuple().fromJsonString(jsonString, options);
  }

  static equals(a: AccessTuple | PlainMessage<AccessTuple> | undefined, b: AccessTuple | PlainMessage<AccessTuple> | undefined): boolean {
    return proto3.util.equals(AccessTuple, a, b);
  }
}

/**
 * TracerConfig stores additional tracer args. For geth it's only one attr:
 * onlyTopCall
 *
 * @generated from message eth.evm.v1.TracerConfig
 */
export class TracerConfig extends Message<TracerConfig> {
  /**
   * @generated from field: bool only_top_call = 1;
   */
  onlyTopCall = false;

  constructor(data?: PartialMessage<TracerConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.TracerConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "only_top_call", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TracerConfig {
    return new TracerConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TracerConfig {
    return new TracerConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TracerConfig {
    return new TracerConfig().fromJsonString(jsonString, options);
  }

  static equals(a: TracerConfig | PlainMessage<TracerConfig> | undefined, b: TracerConfig | PlainMessage<TracerConfig> | undefined): boolean {
    return proto3.util.equals(TracerConfig, a, b);
  }
}

/**
 * TraceConfig holds extra parameters to trace functions.
 *
 * @generated from message eth.evm.v1.TraceConfig
 */
export class TraceConfig extends Message<TraceConfig> {
  /**
   * tracer is a custom javascript tracer
   *
   * @generated from field: string tracer = 1;
   */
  tracer = "";

  /**
   * timeout overrides the default timeout of 5 seconds for JavaScript-based
   * tracing calls
   *
   * @generated from field: string timeout = 2;
   */
  timeout = "";

  /**
   * reexec defines the number of blocks the tracer is willing to go back
   *
   * @generated from field: uint64 reexec = 3;
   */
  reexec = protoInt64.zero;

  /**
   * disable_stack switches stack capture
   *
   * @generated from field: bool disable_stack = 5;
   */
  disableStack = false;

  /**
   * disable_storage switches storage capture
   *
   * @generated from field: bool disable_storage = 6;
   */
  disableStorage = false;

  /**
   * debug can be used to print output during capture end
   *
   * @generated from field: bool debug = 8;
   */
  debug = false;

  /**
   * limit defines the maximum length of output, but zero means unlimited
   *
   * @generated from field: int32 limit = 9;
   */
  limit = 0;

  /**
   * enable_memory switches memory capture
   *
   * @generated from field: bool enable_memory = 11;
   */
  enableMemory = false;

  /**
   * enable_return_data switches the capture of return data
   *
   * @generated from field: bool enable_return_data = 12;
   */
  enableReturnData = false;

  /**
   * tracer_config configures the tracer options
   *
   * @generated from field: eth.evm.v1.TracerConfig tracer_config = 13;
   */
  tracerConfig?: TracerConfig;

  constructor(data?: PartialMessage<TraceConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "eth.evm.v1.TraceConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tracer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timeout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reexec", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "disable_stack", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "disable_storage", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "debug", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "enable_memory", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 12, name: "enable_return_data", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 13, name: "tracer_config", kind: "message", T: TracerConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TraceConfig {
    return new TraceConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TraceConfig {
    return new TraceConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TraceConfig {
    return new TraceConfig().fromJsonString(jsonString, options);
  }

  static equals(a: TraceConfig | PlainMessage<TraceConfig> | undefined, b: TraceConfig | PlainMessage<TraceConfig> | undefined): boolean {
    return proto3.util.equals(TraceConfig, a, b);
  }
}

