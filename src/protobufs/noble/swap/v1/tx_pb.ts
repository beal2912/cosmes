// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file noble/swap/v1/tx.proto (package noble.swap.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Route, Swap } from "./swap_pb.js";
import { Algorithm } from "./algorithm_pb.js";

/**
 * @generated from message noble.swap.v1.MsgWithdrawProtocolFees
 */
export class MsgWithdrawProtocolFees extends Message<MsgWithdrawProtocolFees> {
  /**
   * Address of the signer who is requesting the fee withdrawal.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * Address to which the withdrawn fees will be sent.
   *
   * @generated from field: string to = 2;
   */
  to = "";

  constructor(data?: PartialMessage<MsgWithdrawProtocolFees>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgWithdrawProtocolFees";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgWithdrawProtocolFees {
    return new MsgWithdrawProtocolFees().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgWithdrawProtocolFees {
    return new MsgWithdrawProtocolFees().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgWithdrawProtocolFees {
    return new MsgWithdrawProtocolFees().fromJsonString(jsonString, options);
  }

  static equals(a: MsgWithdrawProtocolFees | PlainMessage<MsgWithdrawProtocolFees> | undefined, b: MsgWithdrawProtocolFees | PlainMessage<MsgWithdrawProtocolFees> | undefined): boolean {
    return proto3.util.equals(MsgWithdrawProtocolFees, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgWithdrawProtocolFeesResponse
 */
export class MsgWithdrawProtocolFeesResponse extends Message<MsgWithdrawProtocolFeesResponse> {
  constructor(data?: PartialMessage<MsgWithdrawProtocolFeesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgWithdrawProtocolFeesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgWithdrawProtocolFeesResponse {
    return new MsgWithdrawProtocolFeesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgWithdrawProtocolFeesResponse {
    return new MsgWithdrawProtocolFeesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgWithdrawProtocolFeesResponse {
    return new MsgWithdrawProtocolFeesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgWithdrawProtocolFeesResponse | PlainMessage<MsgWithdrawProtocolFeesResponse> | undefined, b: MsgWithdrawProtocolFeesResponse | PlainMessage<MsgWithdrawProtocolFeesResponse> | undefined): boolean {
    return proto3.util.equals(MsgWithdrawProtocolFeesResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgWithdrawRewards
 */
export class MsgWithdrawRewards extends Message<MsgWithdrawRewards> {
  /**
   * Address of the signer who is requesting the reward withdrawal.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  constructor(data?: PartialMessage<MsgWithdrawRewards>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgWithdrawRewards";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgWithdrawRewards {
    return new MsgWithdrawRewards().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgWithdrawRewards {
    return new MsgWithdrawRewards().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgWithdrawRewards {
    return new MsgWithdrawRewards().fromJsonString(jsonString, options);
  }

  static equals(a: MsgWithdrawRewards | PlainMessage<MsgWithdrawRewards> | undefined, b: MsgWithdrawRewards | PlainMessage<MsgWithdrawRewards> | undefined): boolean {
    return proto3.util.equals(MsgWithdrawRewards, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgWithdrawRewardsResponse
 */
export class MsgWithdrawRewardsResponse extends Message<MsgWithdrawRewardsResponse> {
  /**
   * List of rewards withdrawn by the user.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin rewards = 1;
   */
  rewards: Coin[] = [];

  constructor(data?: PartialMessage<MsgWithdrawRewardsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgWithdrawRewardsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rewards", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgWithdrawRewardsResponse {
    return new MsgWithdrawRewardsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgWithdrawRewardsResponse {
    return new MsgWithdrawRewardsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgWithdrawRewardsResponse {
    return new MsgWithdrawRewardsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgWithdrawRewardsResponse | PlainMessage<MsgWithdrawRewardsResponse> | undefined, b: MsgWithdrawRewardsResponse | PlainMessage<MsgWithdrawRewardsResponse> | undefined): boolean {
    return proto3.util.equals(MsgWithdrawRewardsResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgSwap
 */
export class MsgSwap extends Message<MsgSwap> {
  /**
   * Address of the signer who is initiating the swap.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The coin to be swapped.
   *
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  /**
   * The routes through which the swap will occur.
   *
   * @generated from field: repeated noble.swap.v1.Route routes = 3;
   */
  routes: Route[] = [];

  /**
   * The minimum amount of tokens expected after the swap.
   *
   * @generated from field: cosmos.base.v1beta1.Coin min = 4;
   */
  min?: Coin;

  constructor(data?: PartialMessage<MsgSwap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgSwap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
    { no: 3, name: "routes", kind: "message", T: Route, repeated: true },
    { no: 4, name: "min", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwap {
    return new MsgSwap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwap {
    return new MsgSwap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwap {
    return new MsgSwap().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwap | PlainMessage<MsgSwap> | undefined, b: MsgSwap | PlainMessage<MsgSwap> | undefined): boolean {
    return proto3.util.equals(MsgSwap, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgSwapResponse
 */
export class MsgSwapResponse extends Message<MsgSwapResponse> {
  /**
   * The resulting amount of tokens after the swap.
   *
   * @generated from field: cosmos.base.v1beta1.Coin result = 1;
   */
  result?: Coin;

  /**
   * Details of each individual swap involved in the process.
   *
   * @generated from field: repeated noble.swap.v1.Swap swaps = 2;
   */
  swaps: Swap[] = [];

  constructor(data?: PartialMessage<MsgSwapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgSwapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: Coin },
    { no: 2, name: "swaps", kind: "message", T: Swap, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSwapResponse {
    return new MsgSwapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSwapResponse {
    return new MsgSwapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSwapResponse {
    return new MsgSwapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSwapResponse | PlainMessage<MsgSwapResponse> | undefined, b: MsgSwapResponse | PlainMessage<MsgSwapResponse> | undefined): boolean {
    return proto3.util.equals(MsgSwapResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgPauseByAlgorithm
 */
export class MsgPauseByAlgorithm extends Message<MsgPauseByAlgorithm> {
  /**
   * Address of the signer who is requesting to pause the pools.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The algorithm used by the pools to be paused.
   *
   * @generated from field: noble.swap.v1.Algorithm algorithm = 2;
   */
  algorithm = Algorithm.UNSPECIFIED;

  constructor(data?: PartialMessage<MsgPauseByAlgorithm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgPauseByAlgorithm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPauseByAlgorithm {
    return new MsgPauseByAlgorithm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPauseByAlgorithm {
    return new MsgPauseByAlgorithm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPauseByAlgorithm {
    return new MsgPauseByAlgorithm().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPauseByAlgorithm | PlainMessage<MsgPauseByAlgorithm> | undefined, b: MsgPauseByAlgorithm | PlainMessage<MsgPauseByAlgorithm> | undefined): boolean {
    return proto3.util.equals(MsgPauseByAlgorithm, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgPauseByAlgorithmResponse
 */
export class MsgPauseByAlgorithmResponse extends Message<MsgPauseByAlgorithmResponse> {
  /**
   * List of IDs of the paused pools.
   *
   * @generated from field: repeated uint64 paused_pools = 1;
   */
  pausedPools: bigint[] = [];

  constructor(data?: PartialMessage<MsgPauseByAlgorithmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgPauseByAlgorithmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "paused_pools", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPauseByAlgorithmResponse {
    return new MsgPauseByAlgorithmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPauseByAlgorithmResponse {
    return new MsgPauseByAlgorithmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPauseByAlgorithmResponse {
    return new MsgPauseByAlgorithmResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPauseByAlgorithmResponse | PlainMessage<MsgPauseByAlgorithmResponse> | undefined, b: MsgPauseByAlgorithmResponse | PlainMessage<MsgPauseByAlgorithmResponse> | undefined): boolean {
    return proto3.util.equals(MsgPauseByAlgorithmResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgPauseByPoolIds
 */
export class MsgPauseByPoolIds extends Message<MsgPauseByPoolIds> {
  /**
   * Address of the signer who is requesting to pause the pools.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * List of IDs of the pools to be paused.
   *
   * @generated from field: repeated uint64 pool_ids = 2;
   */
  poolIds: bigint[] = [];

  constructor(data?: PartialMessage<MsgPauseByPoolIds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgPauseByPoolIds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pool_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPauseByPoolIds {
    return new MsgPauseByPoolIds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPauseByPoolIds {
    return new MsgPauseByPoolIds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPauseByPoolIds {
    return new MsgPauseByPoolIds().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPauseByPoolIds | PlainMessage<MsgPauseByPoolIds> | undefined, b: MsgPauseByPoolIds | PlainMessage<MsgPauseByPoolIds> | undefined): boolean {
    return proto3.util.equals(MsgPauseByPoolIds, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgPauseByPoolIdsResponse
 */
export class MsgPauseByPoolIdsResponse extends Message<MsgPauseByPoolIdsResponse> {
  /**
   * List of IDs of the paused pools.
   *
   * @generated from field: repeated uint64 paused_pools = 1;
   */
  pausedPools: bigint[] = [];

  constructor(data?: PartialMessage<MsgPauseByPoolIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgPauseByPoolIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "paused_pools", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgPauseByPoolIdsResponse {
    return new MsgPauseByPoolIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgPauseByPoolIdsResponse {
    return new MsgPauseByPoolIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgPauseByPoolIdsResponse {
    return new MsgPauseByPoolIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgPauseByPoolIdsResponse | PlainMessage<MsgPauseByPoolIdsResponse> | undefined, b: MsgPauseByPoolIdsResponse | PlainMessage<MsgPauseByPoolIdsResponse> | undefined): boolean {
    return proto3.util.equals(MsgPauseByPoolIdsResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgUnpauseByAlgorithm
 */
export class MsgUnpauseByAlgorithm extends Message<MsgUnpauseByAlgorithm> {
  /**
   * Address of the signer who is requesting to unpause the pools.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * The algorithm used by the pools to be unpaused.
   *
   * @generated from field: noble.swap.v1.Algorithm algorithm = 2;
   */
  algorithm = Algorithm.UNSPECIFIED;

  constructor(data?: PartialMessage<MsgUnpauseByAlgorithm>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgUnpauseByAlgorithm";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUnpauseByAlgorithm {
    return new MsgUnpauseByAlgorithm().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUnpauseByAlgorithm {
    return new MsgUnpauseByAlgorithm().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUnpauseByAlgorithm {
    return new MsgUnpauseByAlgorithm().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUnpauseByAlgorithm | PlainMessage<MsgUnpauseByAlgorithm> | undefined, b: MsgUnpauseByAlgorithm | PlainMessage<MsgUnpauseByAlgorithm> | undefined): boolean {
    return proto3.util.equals(MsgUnpauseByAlgorithm, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgUnpauseByAlgorithmResponse
 */
export class MsgUnpauseByAlgorithmResponse extends Message<MsgUnpauseByAlgorithmResponse> {
  /**
   * List of IDs of the unpaused pools.
   *
   * @generated from field: repeated uint64 unpaused_pools = 1;
   */
  unpausedPools: bigint[] = [];

  constructor(data?: PartialMessage<MsgUnpauseByAlgorithmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgUnpauseByAlgorithmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unpaused_pools", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUnpauseByAlgorithmResponse {
    return new MsgUnpauseByAlgorithmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUnpauseByAlgorithmResponse {
    return new MsgUnpauseByAlgorithmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUnpauseByAlgorithmResponse {
    return new MsgUnpauseByAlgorithmResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUnpauseByAlgorithmResponse | PlainMessage<MsgUnpauseByAlgorithmResponse> | undefined, b: MsgUnpauseByAlgorithmResponse | PlainMessage<MsgUnpauseByAlgorithmResponse> | undefined): boolean {
    return proto3.util.equals(MsgUnpauseByAlgorithmResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgUnpauseByPoolIds
 */
export class MsgUnpauseByPoolIds extends Message<MsgUnpauseByPoolIds> {
  /**
   * Address of the signer who is requesting to unpause the pools.
   *
   * @generated from field: string signer = 1;
   */
  signer = "";

  /**
   * List of IDs of the pools to be unpaused.
   *
   * @generated from field: repeated uint64 pool_ids = 2;
   */
  poolIds: bigint[] = [];

  constructor(data?: PartialMessage<MsgUnpauseByPoolIds>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgUnpauseByPoolIds";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pool_ids", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUnpauseByPoolIds {
    return new MsgUnpauseByPoolIds().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUnpauseByPoolIds {
    return new MsgUnpauseByPoolIds().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUnpauseByPoolIds {
    return new MsgUnpauseByPoolIds().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUnpauseByPoolIds | PlainMessage<MsgUnpauseByPoolIds> | undefined, b: MsgUnpauseByPoolIds | PlainMessage<MsgUnpauseByPoolIds> | undefined): boolean {
    return proto3.util.equals(MsgUnpauseByPoolIds, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.MsgUnpauseByPoolIdsResponse
 */
export class MsgUnpauseByPoolIdsResponse extends Message<MsgUnpauseByPoolIdsResponse> {
  /**
   * List of IDs of the unpaused pools.
   *
   * @generated from field: repeated uint64 unpaused_pools = 1;
   */
  unpausedPools: bigint[] = [];

  constructor(data?: PartialMessage<MsgUnpauseByPoolIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.MsgUnpauseByPoolIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "unpaused_pools", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUnpauseByPoolIdsResponse {
    return new MsgUnpauseByPoolIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUnpauseByPoolIdsResponse {
    return new MsgUnpauseByPoolIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUnpauseByPoolIdsResponse {
    return new MsgUnpauseByPoolIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUnpauseByPoolIdsResponse | PlainMessage<MsgUnpauseByPoolIdsResponse> | undefined, b: MsgUnpauseByPoolIdsResponse | PlainMessage<MsgUnpauseByPoolIdsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUnpauseByPoolIdsResponse, a, b);
  }
}

