// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file noble/swap/v1/query.proto (package noble.swap.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Algorithm } from "./algorithm_pb.js";
import { Rate } from "./rate_pb.js";
import { PoolDetails } from "./pool_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Route } from "./swap_pb.js";

/**
 * @generated from message noble.swap.v1.QueryRates
 */
export class QueryRates extends Message<QueryRates> {
  /**
   * @generated from field: noble.swap.v1.Algorithm algorithm = 1;
   */
  algorithm = Algorithm.UNSPECIFIED;

  constructor(data?: PartialMessage<QueryRates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryRates";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRates {
    return new QueryRates().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRates {
    return new QueryRates().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRates {
    return new QueryRates().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRates | PlainMessage<QueryRates> | undefined, b: QueryRates | PlainMessage<QueryRates> | undefined): boolean {
    return proto3.util.equals(QueryRates, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryRatesResponse
 */
export class QueryRatesResponse extends Message<QueryRatesResponse> {
  /**
   * @generated from field: repeated noble.swap.v1.Rate rates = 1;
   */
  rates: Rate[] = [];

  constructor(data?: PartialMessage<QueryRatesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryRatesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rates", kind: "message", T: Rate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRatesResponse {
    return new QueryRatesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRatesResponse {
    return new QueryRatesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRatesResponse {
    return new QueryRatesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRatesResponse | PlainMessage<QueryRatesResponse> | undefined, b: QueryRatesResponse | PlainMessage<QueryRatesResponse> | undefined): boolean {
    return proto3.util.equals(QueryRatesResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryRate
 */
export class QueryRate extends Message<QueryRate> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: noble.swap.v1.Algorithm algorithm = 2;
   */
  algorithm = Algorithm.UNSPECIFIED;

  constructor(data?: PartialMessage<QueryRate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryRate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "algorithm", kind: "enum", T: proto3.getEnumType(Algorithm) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRate {
    return new QueryRate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRate {
    return new QueryRate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRate {
    return new QueryRate().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRate | PlainMessage<QueryRate> | undefined, b: QueryRate | PlainMessage<QueryRate> | undefined): boolean {
    return proto3.util.equals(QueryRate, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryRateResponse
 */
export class QueryRateResponse extends Message<QueryRateResponse> {
  /**
   * @generated from field: repeated noble.swap.v1.Rate rates = 1;
   */
  rates: Rate[] = [];

  constructor(data?: PartialMessage<QueryRateResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryRateResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "rates", kind: "message", T: Rate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRateResponse {
    return new QueryRateResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRateResponse {
    return new QueryRateResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRateResponse {
    return new QueryRateResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRateResponse | PlainMessage<QueryRateResponse> | undefined, b: QueryRateResponse | PlainMessage<QueryRateResponse> | undefined): boolean {
    return proto3.util.equals(QueryRateResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPaused
 */
export class QueryPaused extends Message<QueryPaused> {
  constructor(data?: PartialMessage<QueryPaused>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPaused";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPaused {
    return new QueryPaused().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPaused {
    return new QueryPaused().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPaused {
    return new QueryPaused().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPaused | PlainMessage<QueryPaused> | undefined, b: QueryPaused | PlainMessage<QueryPaused> | undefined): boolean {
    return proto3.util.equals(QueryPaused, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPausedResponse
 */
export class QueryPausedResponse extends Message<QueryPausedResponse> {
  /**
   * @generated from field: repeated uint64 paused_pools = 1;
   */
  pausedPools: bigint[] = [];

  constructor(data?: PartialMessage<QueryPausedResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPausedResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "paused_pools", kind: "scalar", T: 4 /* ScalarType.UINT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPausedResponse {
    return new QueryPausedResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPausedResponse {
    return new QueryPausedResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPausedResponse {
    return new QueryPausedResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPausedResponse | PlainMessage<QueryPausedResponse> | undefined, b: QueryPausedResponse | PlainMessage<QueryPausedResponse> | undefined): boolean {
    return proto3.util.equals(QueryPausedResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPools
 */
export class QueryPools extends Message<QueryPools> {
  constructor(data?: PartialMessage<QueryPools>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPools";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPools {
    return new QueryPools().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPools {
    return new QueryPools().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPools {
    return new QueryPools().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPools | PlainMessage<QueryPools> | undefined, b: QueryPools | PlainMessage<QueryPools> | undefined): boolean {
    return proto3.util.equals(QueryPools, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPoolsResponse
 */
export class QueryPoolsResponse extends Message<QueryPoolsResponse> {
  /**
   * @generated from field: repeated noble.swap.v1.PoolDetails pools = 1;
   */
  pools: PoolDetails[] = [];

  constructor(data?: PartialMessage<QueryPoolsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPoolsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pools", kind: "message", T: PoolDetails, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPoolsResponse {
    return new QueryPoolsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPoolsResponse {
    return new QueryPoolsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPoolsResponse {
    return new QueryPoolsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPoolsResponse | PlainMessage<QueryPoolsResponse> | undefined, b: QueryPoolsResponse | PlainMessage<QueryPoolsResponse> | undefined): boolean {
    return proto3.util.equals(QueryPoolsResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPool
 */
export class QueryPool extends Message<QueryPool> {
  /**
   * @generated from field: uint64 pool_id = 1;
   */
  poolId = protoInt64.zero;

  constructor(data?: PartialMessage<QueryPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPool {
    return new QueryPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPool {
    return new QueryPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPool {
    return new QueryPool().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPool | PlainMessage<QueryPool> | undefined, b: QueryPool | PlainMessage<QueryPool> | undefined): boolean {
    return proto3.util.equals(QueryPool, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QueryPoolResponse
 */
export class QueryPoolResponse extends Message<QueryPoolResponse> {
  /**
   * @generated from field: noble.swap.v1.PoolDetails pool = 1;
   */
  pool?: PoolDetails;

  constructor(data?: PartialMessage<QueryPoolResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QueryPoolResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool", kind: "message", T: PoolDetails },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryPoolResponse {
    return new QueryPoolResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryPoolResponse {
    return new QueryPoolResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryPoolResponse {
    return new QueryPoolResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryPoolResponse | PlainMessage<QueryPoolResponse> | undefined, b: QueryPoolResponse | PlainMessage<QueryPoolResponse> | undefined): boolean {
    return proto3.util.equals(QueryPoolResponse, a, b);
  }
}

/**
 * @generated from message noble.swap.v1.QuerySimulateSwap
 */
export class QuerySimulateSwap extends Message<QuerySimulateSwap> {
  /**
   * @generated from field: string signer = 1 [deprecated = true];
   * @deprecated
   */
  signer = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  /**
   * @generated from field: repeated noble.swap.v1.Route routes = 3;
   */
  routes: Route[] = [];

  /**
   * @generated from field: cosmos.base.v1beta1.Coin min = 4;
   */
  min?: Coin;

  constructor(data?: PartialMessage<QuerySimulateSwap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "noble.swap.v1.QuerySimulateSwap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "signer", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
    { no: 3, name: "routes", kind: "message", T: Route, repeated: true },
    { no: 4, name: "min", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QuerySimulateSwap {
    return new QuerySimulateSwap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QuerySimulateSwap {
    return new QuerySimulateSwap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QuerySimulateSwap {
    return new QuerySimulateSwap().fromJsonString(jsonString, options);
  }

  static equals(a: QuerySimulateSwap | PlainMessage<QuerySimulateSwap> | undefined, b: QuerySimulateSwap | PlainMessage<QuerySimulateSwap> | undefined): boolean {
    return proto3.util.equals(QuerySimulateSwap, a, b);
  }
}

