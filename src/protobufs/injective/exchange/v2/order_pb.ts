// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v2/order.proto (package injective.exchange.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum injective.exchange.v2.OrderType
 */
export enum OrderType {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: BUY = 1;
   */
  BUY = 1,

  /**
   * @generated from enum value: SELL = 2;
   */
  SELL = 2,

  /**
   * @generated from enum value: STOP_BUY = 3;
   */
  STOP_BUY = 3,

  /**
   * @generated from enum value: STOP_SELL = 4;
   */
  STOP_SELL = 4,

  /**
   * @generated from enum value: TAKE_BUY = 5;
   */
  TAKE_BUY = 5,

  /**
   * @generated from enum value: TAKE_SELL = 6;
   */
  TAKE_SELL = 6,

  /**
   * @generated from enum value: BUY_PO = 7;
   */
  BUY_PO = 7,

  /**
   * @generated from enum value: SELL_PO = 8;
   */
  SELL_PO = 8,

  /**
   * @generated from enum value: BUY_ATOMIC = 9;
   */
  BUY_ATOMIC = 9,

  /**
   * @generated from enum value: SELL_ATOMIC = 10;
   */
  SELL_ATOMIC = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderType)
proto3.util.setEnumType(OrderType, "injective.exchange.v2.OrderType", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "BUY" },
  { no: 2, name: "SELL" },
  { no: 3, name: "STOP_BUY" },
  { no: 4, name: "STOP_SELL" },
  { no: 5, name: "TAKE_BUY" },
  { no: 6, name: "TAKE_SELL" },
  { no: 7, name: "BUY_PO" },
  { no: 8, name: "SELL_PO" },
  { no: 9, name: "BUY_ATOMIC" },
  { no: 10, name: "SELL_ATOMIC" },
]);

/**
 * @generated from enum injective.exchange.v2.OrderMask
 */
export enum OrderMask {
  /**
   * @generated from enum value: UNUSED = 0;
   */
  UNUSED = 0,

  /**
   * @generated from enum value: ANY = 1;
   */
  ANY = 1,

  /**
   * @generated from enum value: REGULAR = 2;
   */
  REGULAR = 2,

  /**
   * @generated from enum value: CONDITIONAL = 4;
   */
  CONDITIONAL = 4,

  /**
   * for conditional orders means HIGHER
   *
   * @generated from enum value: DIRECTION_BUY_OR_HIGHER = 8;
   */
  DIRECTION_BUY_OR_HIGHER = 8,

  /**
   * for conditional orders means LOWER
   *
   * @generated from enum value: DIRECTION_SELL_OR_LOWER = 16;
   */
  DIRECTION_SELL_OR_LOWER = 16,

  /**
   * @generated from enum value: TYPE_MARKET = 32;
   */
  TYPE_MARKET = 32,

  /**
   * @generated from enum value: TYPE_LIMIT = 64;
   */
  TYPE_LIMIT = 64,
}
// Retrieve enum metadata with: proto3.getEnumType(OrderMask)
proto3.util.setEnumType(OrderMask, "injective.exchange.v2.OrderMask", [
  { no: 0, name: "UNUSED" },
  { no: 1, name: "ANY" },
  { no: 2, name: "REGULAR" },
  { no: 4, name: "CONDITIONAL" },
  { no: 8, name: "DIRECTION_BUY_OR_HIGHER" },
  { no: 16, name: "DIRECTION_SELL_OR_LOWER" },
  { no: 32, name: "TYPE_MARKET" },
  { no: 64, name: "TYPE_LIMIT" },
]);

/**
 * @generated from enum injective.exchange.v2.AtomicMarketOrderAccessLevel
 */
export enum AtomicMarketOrderAccessLevel {
  /**
   * @generated from enum value: Nobody = 0;
   */
  Nobody = 0,

  /**
   * currently unsupported
   *
   * @generated from enum value: BeginBlockerSmartContractsOnly = 1;
   */
  BeginBlockerSmartContractsOnly = 1,

  /**
   * @generated from enum value: SmartContractsOnly = 2;
   */
  SmartContractsOnly = 2,

  /**
   * @generated from enum value: Everyone = 3;
   */
  Everyone = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AtomicMarketOrderAccessLevel)
proto3.util.setEnumType(AtomicMarketOrderAccessLevel, "injective.exchange.v2.AtomicMarketOrderAccessLevel", [
  { no: 0, name: "Nobody" },
  { no: 1, name: "BeginBlockerSmartContractsOnly" },
  { no: 2, name: "SmartContractsOnly" },
  { no: 3, name: "Everyone" },
]);

/**
 * @generated from message injective.exchange.v2.OrderInfo
 */
export class OrderInfo extends Message<OrderInfo> {
  /**
   * bytes32 subaccount ID that created the order
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * address fee_recipient address that will receive fees for the order
   *
   * @generated from field: string fee_recipient = 2;
   */
  feeRecipient = "";

  /**
   * price of the order (in human readable format)
   *
   * @generated from field: string price = 3;
   */
  price = "";

  /**
   * quantity of the order (in human readable format)
   *
   * @generated from field: string quantity = 4;
   */
  quantity = "";

  /**
   * the client order ID (optional)
   *
   * @generated from field: string cid = 5;
   */
  cid = "";

  constructor(data?: PartialMessage<OrderInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.OrderInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_recipient", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderInfo {
    return new OrderInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderInfo {
    return new OrderInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderInfo {
    return new OrderInfo().fromJsonString(jsonString, options);
  }

  static equals(a: OrderInfo | PlainMessage<OrderInfo> | undefined, b: OrderInfo | PlainMessage<OrderInfo> | undefined): boolean {
    return proto3.util.equals(OrderInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SpotOrder
 */
export class SpotOrder extends Message<SpotOrder> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 2;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 3;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * trigger_price is the trigger price used by stop/take orders (in human
   * readable format) (optional)
   *
   * @generated from field: string trigger_price = 4;
   */
  triggerPrice = "";

  /**
   * expiration block is the block number at which the order will expire
   *
   * @generated from field: int64 expiration_block = 5;
   */
  expirationBlock = protoInt64.zero;

  constructor(data?: PartialMessage<SpotOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SpotOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "expiration_block", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrder {
    return new SpotOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrder {
    return new SpotOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrder | PlainMessage<SpotOrder> | undefined, b: SpotOrder | PlainMessage<SpotOrder> | undefined): boolean {
    return proto3.util.equals(SpotOrder, a, b);
  }
}

/**
 * A valid Spot market order with Metadata.
 *
 * @generated from message injective.exchange.v2.SpotMarketOrder
 */
export class SpotMarketOrder extends Message<SpotMarketOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * @generated from field: string balance_hold = 2;
   */
  balanceHold = "";

  /**
   * @generated from field: bytes order_hash = 3;
   */
  orderHash = new Uint8Array(0);

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 4;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  constructor(data?: PartialMessage<SpotMarketOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SpotMarketOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "balance_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarketOrder {
    return new SpotMarketOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarketOrder | PlainMessage<SpotMarketOrder> | undefined, b: SpotMarketOrder | PlainMessage<SpotMarketOrder> | undefined): boolean {
    return proto3.util.equals(SpotMarketOrder, a, b);
  }
}

/**
 * A valid Spot limit order with Metadata.
 *
 * @generated from message injective.exchange.v2.SpotLimitOrder
 */
export class SpotLimitOrder extends Message<SpotLimitOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 3;
   */
  fillable = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 4;
   */
  triggerPrice = "";

  /**
   * order hash
   *
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  /**
   * expiration block is the block number at which the order will expire
   *
   * @generated from field: int64 expiration_block = 6;
   */
  expirationBlock = protoInt64.zero;

  constructor(data?: PartialMessage<SpotLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SpotLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "expiration_block", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotLimitOrder {
    return new SpotLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SpotLimitOrder | PlainMessage<SpotLimitOrder> | undefined, b: SpotLimitOrder | PlainMessage<SpotLimitOrder> | undefined): boolean {
    return proto3.util.equals(SpotLimitOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativeOrder
 */
export class DerivativeOrder extends Message<DerivativeOrder> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 2;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 3;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * margin is the margin used by the limit order (in human readable format)
   *
   * @generated from field: string margin = 4;
   */
  margin = "";

  /**
   * trigger_price is the trigger price used by stop/take orders (in human
   * readable format) (optional)
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  /**
   * expiration block is the block number at which the order will expire
   *
   * @generated from field: int64 expiration_block = 6;
   */
  expirationBlock = protoInt64.zero;

  constructor(data?: PartialMessage<DerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order_info", kind: "message", T: OrderInfo },
    { no: 3, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "expiration_block", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrder {
    return new DerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined, b: DerivativeOrder | PlainMessage<DerivativeOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeOrder, a, b);
  }
}

/**
 * A valid Derivative market order with Metadata.
 *
 * @generated from message injective.exchange.v2.DerivativeMarketOrder
 */
export class DerivativeMarketOrder extends Message<DerivativeMarketOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * @generated from field: string margin_hold = 4;
   */
  marginHold = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  /**
   * @generated from field: bytes order_hash = 6;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<DerivativeMarketOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeMarketOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin_hold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketOrder {
    return new DerivativeMarketOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketOrder | PlainMessage<DerivativeMarketOrder> | undefined, b: DerivativeMarketOrder | PlainMessage<DerivativeMarketOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketOrder, a, b);
  }
}

/**
 * A valid Derivative limit order with Metadata.
 *
 * @generated from message injective.exchange.v2.DerivativeLimitOrder
 */
export class DerivativeLimitOrder extends Message<DerivativeLimitOrder> {
  /**
   * order_info contains the information of the order
   *
   * @generated from field: injective.exchange.v2.OrderInfo order_info = 1;
   */
  orderInfo?: OrderInfo;

  /**
   * order types
   *
   * @generated from field: injective.exchange.v2.OrderType order_type = 2;
   */
  orderType = OrderType.UNSPECIFIED;

  /**
   * margin is the margin used by the limit order
   *
   * @generated from field: string margin = 3;
   */
  margin = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string fillable = 4;
   */
  fillable = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string trigger_price = 5;
   */
  triggerPrice = "";

  /**
   * @generated from field: bytes order_hash = 6;
   */
  orderHash = new Uint8Array(0);

  /**
   * expiration block is the block number at which the order will expire
   *
   * @generated from field: int64 expiration_block = 7;
   */
  expirationBlock = protoInt64.zero;

  constructor(data?: PartialMessage<DerivativeLimitOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeLimitOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order_info", kind: "message", T: OrderInfo },
    { no: 2, name: "order_type", kind: "enum", T: proto3.getEnumType(OrderType) },
    { no: 3, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fillable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "trigger_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "expiration_block", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeLimitOrder {
    return new DerivativeLimitOrder().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeLimitOrder | PlainMessage<DerivativeLimitOrder> | undefined, b: DerivativeLimitOrder | PlainMessage<DerivativeLimitOrder> | undefined): boolean {
    return proto3.util.equals(DerivativeLimitOrder, a, b);
  }
}

