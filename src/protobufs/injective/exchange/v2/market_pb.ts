// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v2/market.proto (package injective.exchange.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { OracleType } from "../../oracle/v1beta1/oracle_pb.js";

/**
 * @generated from enum injective.exchange.v2.MarketStatus
 */
export enum MarketStatus {
  /**
   * @generated from enum value: Unspecified = 0;
   */
  Unspecified = 0,

  /**
   * @generated from enum value: Active = 1;
   */
  Active = 1,

  /**
   * @generated from enum value: Paused = 2;
   */
  Paused = 2,

  /**
   * @generated from enum value: Demolished = 3;
   */
  Demolished = 3,

  /**
   * @generated from enum value: Expired = 4;
   */
  Expired = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MarketStatus)
proto3.util.setEnumType(MarketStatus, "injective.exchange.v2.MarketStatus", [
  { no: 0, name: "Unspecified" },
  { no: 1, name: "Active" },
  { no: 2, name: "Paused" },
  { no: 3, name: "Demolished" },
  { no: 4, name: "Expired" },
]);

/**
 * @generated from message injective.exchange.v2.OpenNotionalCap
 */
export class OpenNotionalCap extends Message<OpenNotionalCap> {
  /**
   * @generated from oneof injective.exchange.v2.OpenNotionalCap.cap
   */
  cap: {
    /**
     * @generated from field: injective.exchange.v2.OpenNotionalCapUncapped uncapped = 1;
     */
    value: OpenNotionalCapUncapped;
    case: "uncapped";
  } | {
    /**
     * @generated from field: injective.exchange.v2.OpenNotionalCapCapped capped = 2;
     */
    value: OpenNotionalCapCapped;
    case: "capped";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OpenNotionalCap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.OpenNotionalCap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uncapped", kind: "message", T: OpenNotionalCapUncapped, oneof: "cap" },
    { no: 2, name: "capped", kind: "message", T: OpenNotionalCapCapped, oneof: "cap" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenNotionalCap {
    return new OpenNotionalCap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenNotionalCap {
    return new OpenNotionalCap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenNotionalCap {
    return new OpenNotionalCap().fromJsonString(jsonString, options);
  }

  static equals(a: OpenNotionalCap | PlainMessage<OpenNotionalCap> | undefined, b: OpenNotionalCap | PlainMessage<OpenNotionalCap> | undefined): boolean {
    return proto3.util.equals(OpenNotionalCap, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.OpenNotionalCapUncapped
 */
export class OpenNotionalCapUncapped extends Message<OpenNotionalCapUncapped> {
  constructor(data?: PartialMessage<OpenNotionalCapUncapped>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.OpenNotionalCapUncapped";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenNotionalCapUncapped {
    return new OpenNotionalCapUncapped().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenNotionalCapUncapped {
    return new OpenNotionalCapUncapped().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenNotionalCapUncapped {
    return new OpenNotionalCapUncapped().fromJsonString(jsonString, options);
  }

  static equals(a: OpenNotionalCapUncapped | PlainMessage<OpenNotionalCapUncapped> | undefined, b: OpenNotionalCapUncapped | PlainMessage<OpenNotionalCapUncapped> | undefined): boolean {
    return proto3.util.equals(OpenNotionalCapUncapped, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.OpenNotionalCapCapped
 */
export class OpenNotionalCapCapped extends Message<OpenNotionalCapCapped> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<OpenNotionalCapCapped>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.OpenNotionalCapCapped";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenNotionalCapCapped {
    return new OpenNotionalCapCapped().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenNotionalCapCapped {
    return new OpenNotionalCapCapped().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenNotionalCapCapped {
    return new OpenNotionalCapCapped().fromJsonString(jsonString, options);
  }

  static equals(a: OpenNotionalCapCapped | PlainMessage<OpenNotionalCapCapped> | undefined, b: OpenNotionalCapCapped | PlainMessage<OpenNotionalCapCapped> | undefined): boolean {
    return proto3.util.equals(OpenNotionalCapCapped, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.MarketFeeMultiplier
 */
export class MarketFeeMultiplier extends Message<MarketFeeMultiplier> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string fee_multiplier = 2;
   */
  feeMultiplier = "";

  constructor(data?: PartialMessage<MarketFeeMultiplier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.MarketFeeMultiplier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketFeeMultiplier {
    return new MarketFeeMultiplier().fromJsonString(jsonString, options);
  }

  static equals(a: MarketFeeMultiplier | PlainMessage<MarketFeeMultiplier> | undefined, b: MarketFeeMultiplier | PlainMessage<MarketFeeMultiplier> | undefined): boolean {
    return proto3.util.equals(MarketFeeMultiplier, a, b);
  }
}

/**
 * An object describing trade pair of two assets.
 *
 * @generated from message injective.exchange.v2.SpotMarket
 */
export class SpotMarket extends Message<SpotMarket> {
  /**
   * A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
   * asset.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Coin denom used for the base asset
   *
   * @generated from field: string base_denom = 2;
   */
  baseDenom = "";

  /**
   * Coin used for the quote asset
   *
   * @generated from field: string quote_denom = 3;
   */
  quoteDenom = "";

  /**
   * maker_fee_rate defines the fee percentage makers pay when trading
   *
   * @generated from field: string maker_fee_rate = 4;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the fee percentage takers pay when trading
   *
   * @generated from field: string taker_fee_rate = 5;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 6;
   */
  relayerFeeShareRate = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 7;
   */
  marketId = "";

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v2.MarketStatus status = 8;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price required
   * for orders in the market (in human readable format)
   *
   * @generated from field: string min_price_tick_size = 9;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market (in human readable format)
   *
   * @generated from field: string min_quantity_tick_size = 10;
   */
  minQuantityTickSize = "";

  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market (in human readable format)
   *
   * @generated from field: string min_notional = 11;
   */
  minNotional = "";

  /**
   * current market admin
   *
   * @generated from field: string admin = 12;
   */
  admin = "";

  /**
   * level of admin permissions
   *
   * @generated from field: uint32 admin_permissions = 13;
   */
  adminPermissions = 0;

  /**
   * base token decimals
   *
   * @generated from field: uint32 base_decimals = 14;
   */
  baseDecimals = 0;

  /**
   * quote token decimals
   *
   * @generated from field: uint32 quote_decimals = 15;
   */
  quoteDecimals = 0;

  constructor(data?: PartialMessage<SpotMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SpotMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 9, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "min_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "admin_permissions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 14, name: "base_decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "quote_decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotMarket {
    return new SpotMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotMarket {
    return new SpotMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotMarket {
    return new SpotMarket().fromJsonString(jsonString, options);
  }

  static equals(a: SpotMarket | PlainMessage<SpotMarket> | undefined, b: SpotMarket | PlainMessage<SpotMarket> | undefined): boolean {
    return proto3.util.equals(SpotMarket, a, b);
  }
}

/**
 * An object describing a binary options market in Injective Protocol.
 *
 * @generated from message injective.exchange.v2.BinaryOptionsMarket
 */
export class BinaryOptionsMarket extends Message<BinaryOptionsMarket> {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Oracle symbol
   *
   * @generated from field: string oracle_symbol = 2;
   */
  oracleSymbol = "";

  /**
   * Oracle Provider
   *
   * @generated from field: string oracle_provider = 3;
   */
  oracleProvider = "";

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 5;
   */
  oracleScaleFactor = 0;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 expiration_timestamp = 6;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration timestamp
   *
   * @generated from field: int64 settlement_timestamp = 7;
   */
  settlementTimestamp = protoInt64.zero;

  /**
   * admin of the market
   *
   * @generated from field: string admin = 8;
   */
  admin = "";

  /**
   * Address of the quote currency denomination for the binary options contract
   *
   * @generated from field: string quote_denom = 9;
   */
  quoteDenom = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 10;
   */
  marketId = "";

  /**
   * maker_fee_rate defines the maker fee rate of a binary options market
   *
   * @generated from field: string maker_fee_rate = 11;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from field: string taker_fee_rate = 12;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 13;
   */
  relayerFeeShareRate = "";

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v2.MarketStatus status = 14;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market (in human readable format)
   *
   * @generated from field: string min_price_tick_size = 15;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market (in human readable format)
   *
   * @generated from field: string min_quantity_tick_size = 16;
   */
  minQuantityTickSize = "";

  /**
   * settlement_price defines the settlement price of the binary options market
   * (in human readable format)
   *
   * @generated from field: string settlement_price = 17;
   */
  settlementPrice = "";

  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market (in human readable format)
   *
   * @generated from field: string min_notional = 18;
   */
  minNotional = "";

  /**
   * level of admin permissions
   *
   * @generated from field: uint32 admin_permissions = 19;
   */
  adminPermissions = 0;

  /**
   * quote token decimals
   *
   * @generated from field: uint32 quote_decimals = 20;
   */
  quoteDecimals = 0;

  /**
   * open_notional_cap defines the maximum open notional for the market
   *
   * @generated from field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 21;
   */
  openNotionalCap?: OpenNotionalCap;

  constructor(data?: PartialMessage<BinaryOptionsMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BinaryOptionsMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_provider", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "settlement_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "min_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "open_notional_cap", kind: "message", T: OpenNotionalCap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOptionsMarket {
    return new BinaryOptionsMarket().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOptionsMarket | PlainMessage<BinaryOptionsMarket> | undefined, b: BinaryOptionsMarket | PlainMessage<BinaryOptionsMarket> | undefined): boolean {
    return proto3.util.equals(BinaryOptionsMarket, a, b);
  }
}

/**
 * An object describing a derivative market in the Injective Futures Protocol.
 *
 * @generated from message injective.exchange.v2.DerivativeMarket
 */
export class DerivativeMarket extends Message<DerivativeMarket> {
  /**
   * Ticker for the derivative contract.
   *
   * @generated from field: string ticker = 1;
   */
  ticker = "";

  /**
   * Oracle base currency
   *
   * @generated from field: string oracle_base = 2;
   */
  oracleBase = "";

  /**
   * Oracle quote currency
   *
   * @generated from field: string oracle_quote = 3;
   */
  oracleQuote = "";

  /**
   * Oracle type
   *
   * @generated from field: injective.oracle.v1beta1.OracleType oracle_type = 4;
   */
  oracleType = OracleType.Unspecified;

  /**
   * Scale factor for oracle prices.
   *
   * @generated from field: uint32 oracle_scale_factor = 5;
   */
  oracleScaleFactor = 0;

  /**
   * Address of the quote currency denomination for the derivative contract
   *
   * @generated from field: string quote_denom = 6;
   */
  quoteDenom = "";

  /**
   * Unique market ID.
   *
   * @generated from field: string market_id = 7;
   */
  marketId = "";

  /**
   * initial_margin_ratio defines the initial margin ratio of a derivative
   * market
   *
   * @generated from field: string initial_margin_ratio = 8;
   */
  initialMarginRatio = "";

  /**
   * maintenance_margin_ratio defines the maintenance margin ratio of a
   * derivative market
   *
   * @generated from field: string maintenance_margin_ratio = 9;
   */
  maintenanceMarginRatio = "";

  /**
   * maker_fee_rate defines the maker fee rate of a derivative market
   *
   * @generated from field: string maker_fee_rate = 10;
   */
  makerFeeRate = "";

  /**
   * taker_fee_rate defines the taker fee rate of a derivative market
   *
   * @generated from field: string taker_fee_rate = 11;
   */
  takerFeeRate = "";

  /**
   * relayer_fee_share_rate defines the percentage of the transaction fee shared
   * with the relayer in a derivative market
   *
   * @generated from field: string relayer_fee_share_rate = 12;
   */
  relayerFeeShareRate = "";

  /**
   * true if the market is a perpetual market. false if the market is an expiry
   * futures market
   *
   * @generated from field: bool isPerpetual = 13;
   */
  isPerpetual = false;

  /**
   * Status of the market
   *
   * @generated from field: injective.exchange.v2.MarketStatus status = 14;
   */
  status = MarketStatus.Unspecified;

  /**
   * min_price_tick_size defines the minimum tick size that the price and margin
   * required for orders in the market (in human readable format)
   *
   * @generated from field: string min_price_tick_size = 15;
   */
  minPriceTickSize = "";

  /**
   * min_quantity_tick_size defines the minimum tick size of the quantity
   * required for orders in the market (in human readable format)
   *
   * @generated from field: string min_quantity_tick_size = 16;
   */
  minQuantityTickSize = "";

  /**
   * min_notional defines the minimum notional (in quote asset) required for
   * orders in the market (in human readable format)
   *
   * @generated from field: string min_notional = 17;
   */
  minNotional = "";

  /**
   * current market admin
   *
   * @generated from field: string admin = 18;
   */
  admin = "";

  /**
   * level of admin permissions
   *
   * @generated from field: uint32 admin_permissions = 19;
   */
  adminPermissions = 0;

  /**
   * quote token decimals
   *
   * @generated from field: uint32 quote_decimals = 20;
   */
  quoteDecimals = 0;

  /**
   * reduce_margin_ratio defines the ratio of the margin that is reduced
   *
   * @generated from field: string reduce_margin_ratio = 21;
   */
  reduceMarginRatio = "";

  /**
   * open_notional_cap defines the maximum open notional for the market
   *
   * @generated from field: injective.exchange.v2.OpenNotionalCap open_notional_cap = 22;
   */
  openNotionalCap?: OpenNotionalCap;

  constructor(data?: PartialMessage<DerivativeMarket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeMarket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ticker", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "oracle_base", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "oracle_quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "oracle_type", kind: "enum", T: proto3.getEnumType(OracleType) },
    { no: 5, name: "oracle_scale_factor", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "quote_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "isPerpetual", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 14, name: "status", kind: "enum", T: proto3.getEnumType(MarketStatus) },
    { no: 15, name: "min_price_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "min_quantity_tick_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 17, name: "min_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 19, name: "admin_permissions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 20, name: "quote_decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 21, name: "reduce_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "open_notional_cap", kind: "message", T: OpenNotionalCap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarket {
    return new DerivativeMarket().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarket | PlainMessage<DerivativeMarket> | undefined, b: DerivativeMarket | PlainMessage<DerivativeMarket> | undefined): boolean {
    return proto3.util.equals(DerivativeMarket, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativeMarketSettlementInfo
 */
export class DerivativeMarketSettlementInfo extends Message<DerivativeMarketSettlementInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * settlement_price defines the settlement price
   *
   * @generated from field: string settlement_price = 2;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<DerivativeMarketSettlementInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeMarketSettlementInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketSettlementInfo {
    return new DerivativeMarketSettlementInfo().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketSettlementInfo | PlainMessage<DerivativeMarketSettlementInfo> | undefined, b: DerivativeMarketSettlementInfo | PlainMessage<DerivativeMarketSettlementInfo> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketSettlementInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.MarketVolume
 */
export class MarketVolume extends Message<MarketVolume> {
  /**
   * the market ID
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * the market volume
   *
   * @generated from field: injective.exchange.v2.VolumeRecord volume = 2;
   */
  volume?: VolumeRecord;

  constructor(data?: PartialMessage<MarketVolume>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.MarketVolume";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "volume", kind: "message", T: VolumeRecord },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketVolume {
    return new MarketVolume().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketVolume {
    return new MarketVolume().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketVolume {
    return new MarketVolume().fromJsonString(jsonString, options);
  }

  static equals(a: MarketVolume | PlainMessage<MarketVolume> | undefined, b: MarketVolume | PlainMessage<MarketVolume> | undefined): boolean {
    return proto3.util.equals(MarketVolume, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.VolumeRecord
 */
export class VolumeRecord extends Message<VolumeRecord> {
  /**
   * the market's maker volume (in human readable format)
   *
   * @generated from field: string maker_volume = 1;
   */
  makerVolume = "";

  /**
   * the market's taker volume (in human readable format)
   *
   * @generated from field: string taker_volume = 2;
   */
  takerVolume = "";

  constructor(data?: PartialMessage<VolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.VolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VolumeRecord {
    return new VolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VolumeRecord {
    return new VolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VolumeRecord {
    return new VolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: VolumeRecord | PlainMessage<VolumeRecord> | undefined, b: VolumeRecord | PlainMessage<VolumeRecord> | undefined): boolean {
    return proto3.util.equals(VolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.ExpiryFuturesMarketInfoState
 */
export class ExpiryFuturesMarketInfoState extends Message<ExpiryFuturesMarketInfoState> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v2.ExpiryFuturesMarketInfo market_info = 2;
   */
  marketInfo?: ExpiryFuturesMarketInfo;

  constructor(data?: PartialMessage<ExpiryFuturesMarketInfoState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.ExpiryFuturesMarketInfoState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_info", kind: "message", T: ExpiryFuturesMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfoState {
    return new ExpiryFuturesMarketInfoState().fromJsonString(jsonString, options);
  }

  static equals(a: ExpiryFuturesMarketInfoState | PlainMessage<ExpiryFuturesMarketInfoState> | undefined, b: ExpiryFuturesMarketInfoState | PlainMessage<ExpiryFuturesMarketInfoState> | undefined): boolean {
    return proto3.util.equals(ExpiryFuturesMarketInfoState, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.PerpetualMarketFundingState
 */
export class PerpetualMarketFundingState extends Message<PerpetualMarketFundingState> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v2.PerpetualMarketFunding funding = 2;
   */
  funding?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<PerpetualMarketFundingState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.PerpetualMarketFundingState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "funding", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketFundingState {
    return new PerpetualMarketFundingState().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketFundingState | PlainMessage<PerpetualMarketFundingState> | undefined, b: PerpetualMarketFundingState | PlainMessage<PerpetualMarketFundingState> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketFundingState, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.ExpiryFuturesMarketInfo
 */
export class ExpiryFuturesMarketInfo extends Message<ExpiryFuturesMarketInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * expiration_timestamp defines the expiration time for a time expiry futures
   * market.
   *
   * @generated from field: int64 expiration_timestamp = 2;
   */
  expirationTimestamp = protoInt64.zero;

  /**
   * expiration_twap_start_timestamp defines the start time of the TWAP
   * calculation window
   *
   * @generated from field: int64 twap_start_timestamp = 3;
   */
  twapStartTimestamp = protoInt64.zero;

  /**
   * expiration_twap_start_price_cumulative defines the cumulative price for the
   * start of the TWAP window (in human readable format)
   *
   * @generated from field: string expiration_twap_start_price_cumulative = 4;
   */
  expirationTwapStartPriceCumulative = "";

  /**
   * settlement_price defines the settlement price for a time expiry futures
   * market (in human readable format)
   *
   * @generated from field: string settlement_price = 5;
   */
  settlementPrice = "";

  constructor(data?: PartialMessage<ExpiryFuturesMarketInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.ExpiryFuturesMarketInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "expiration_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "twap_start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "expiration_twap_start_price_cumulative", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "settlement_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpiryFuturesMarketInfo {
    return new ExpiryFuturesMarketInfo().fromJsonString(jsonString, options);
  }

  static equals(a: ExpiryFuturesMarketInfo | PlainMessage<ExpiryFuturesMarketInfo> | undefined, b: ExpiryFuturesMarketInfo | PlainMessage<ExpiryFuturesMarketInfo> | undefined): boolean {
    return proto3.util.equals(ExpiryFuturesMarketInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.PerpetualMarketInfo
 */
export class PerpetualMarketInfo extends Message<PerpetualMarketInfo> {
  /**
   * market ID.
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * hourly_funding_rate_cap defines the maximum absolute value of the hourly
   * funding rate
   *
   * @generated from field: string hourly_funding_rate_cap = 2;
   */
  hourlyFundingRateCap = "";

  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from field: string hourly_interest_rate = 3;
   */
  hourlyInterestRate = "";

  /**
   * next_funding_timestamp defines the next funding timestamp in seconds of a
   * perpetual market
   *
   * @generated from field: int64 next_funding_timestamp = 4;
   */
  nextFundingTimestamp = protoInt64.zero;

  /**
   * funding_interval defines the next funding interval in seconds of a
   * perpetual market.
   *
   * @generated from field: int64 funding_interval = 5;
   */
  fundingInterval = protoInt64.zero;

  constructor(data?: PartialMessage<PerpetualMarketInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.PerpetualMarketInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "next_funding_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketInfo {
    return new PerpetualMarketInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketInfo | PlainMessage<PerpetualMarketInfo> | undefined, b: PerpetualMarketInfo | PlainMessage<PerpetualMarketInfo> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.PerpetualMarketFunding
 */
export class PerpetualMarketFunding extends Message<PerpetualMarketFunding> {
  /**
   * cumulative_funding defines the cumulative funding of a perpetual market.
   *
   * @generated from field: string cumulative_funding = 1;
   */
  cumulativeFunding = "";

  /**
   * cumulative_price defines the running time-integral of the perp premium
   * ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
   * used to compute the intervalâ€™s average premium for funding
   *
   * @generated from field: string cumulative_price = 2;
   */
  cumulativePrice = "";

  /**
   * the last funding timestamp in seconds
   *
   * @generated from field: int64 last_timestamp = 3;
   */
  lastTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<PerpetualMarketFunding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.PerpetualMarketFunding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cumulative_funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cumulative_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PerpetualMarketFunding {
    return new PerpetualMarketFunding().fromJsonString(jsonString, options);
  }

  static equals(a: PerpetualMarketFunding | PlainMessage<PerpetualMarketFunding> | undefined, b: PerpetualMarketFunding | PlainMessage<PerpetualMarketFunding> | undefined): boolean {
    return proto3.util.equals(PerpetualMarketFunding, a, b);
  }
}

