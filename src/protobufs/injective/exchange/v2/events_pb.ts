// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v2/events.proto (package injective.exchange.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AccountRewards, CampaignRewardPool, DepositUpdate, DerivativePosition, DerivativeTradeLog, ExecutionType, FeeDiscountSchedule, GrantAuthorization, Level, SubaccountPosition, TradeLog, TradingRewardCampaignInfo } from "./exchange_pb.js";
import { BinaryOptionsMarket, DerivativeMarket, ExpiryFuturesMarketInfo, MarketFeeMultiplier, PerpetualMarketFunding, PerpetualMarketInfo, SpotMarket } from "./market_pb.js";
import { DerivativeLimitOrder, DerivativeMarketOrder, DerivativeOrder, SpotLimitOrder } from "./order_pb.js";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from message injective.exchange.v2.EventBatchSpotExecution
 */
export class EventBatchSpotExecution extends Message<EventBatchSpotExecution> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: injective.exchange.v2.ExecutionType executionType = 3;
   */
  executionType = ExecutionType.UnspecifiedExecutionType;

  /**
   * @generated from field: repeated injective.exchange.v2.TradeLog trades = 4;
   */
  trades: TradeLog[] = [];

  constructor(data?: PartialMessage<EventBatchSpotExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventBatchSpotExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "executionType", kind: "enum", T: proto3.getEnumType(ExecutionType) },
    { no: 4, name: "trades", kind: "message", T: TradeLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchSpotExecution {
    return new EventBatchSpotExecution().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchSpotExecution | PlainMessage<EventBatchSpotExecution> | undefined, b: EventBatchSpotExecution | PlainMessage<EventBatchSpotExecution> | undefined): boolean {
    return proto3.util.equals(EventBatchSpotExecution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventBatchDerivativeExecution
 */
export class EventBatchDerivativeExecution extends Message<EventBatchDerivativeExecution> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool is_buy = 2;
   */
  isBuy = false;

  /**
   * @generated from field: bool is_liquidation = 3;
   */
  isLiquidation = false;

  /**
   * nil for time expiry futures
   *
   * @generated from field: string cumulative_funding = 4;
   */
  cumulativeFunding = "";

  /**
   * @generated from field: injective.exchange.v2.ExecutionType executionType = 5;
   */
  executionType = ExecutionType.UnspecifiedExecutionType;

  /**
   * @generated from field: repeated injective.exchange.v2.DerivativeTradeLog trades = 6;
   */
  trades: DerivativeTradeLog[] = [];

  constructor(data?: PartialMessage<EventBatchDerivativeExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventBatchDerivativeExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_buy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "is_liquidation", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "cumulative_funding", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "executionType", kind: "enum", T: proto3.getEnumType(ExecutionType) },
    { no: 6, name: "trades", kind: "message", T: DerivativeTradeLog, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDerivativeExecution {
    return new EventBatchDerivativeExecution().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDerivativeExecution | PlainMessage<EventBatchDerivativeExecution> | undefined, b: EventBatchDerivativeExecution | PlainMessage<EventBatchDerivativeExecution> | undefined): boolean {
    return proto3.util.equals(EventBatchDerivativeExecution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventLostFundsFromLiquidation
 */
export class EventLostFundsFromLiquidation extends Message<EventLostFundsFromLiquidation> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string lost_funds_from_available_during_payout = 3;
   */
  lostFundsFromAvailableDuringPayout = "";

  /**
   * @generated from field: string lost_funds_from_order_cancels = 4;
   */
  lostFundsFromOrderCancels = "";

  constructor(data?: PartialMessage<EventLostFundsFromLiquidation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventLostFundsFromLiquidation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "lost_funds_from_available_during_payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "lost_funds_from_order_cancels", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventLostFundsFromLiquidation {
    return new EventLostFundsFromLiquidation().fromJsonString(jsonString, options);
  }

  static equals(a: EventLostFundsFromLiquidation | PlainMessage<EventLostFundsFromLiquidation> | undefined, b: EventLostFundsFromLiquidation | PlainMessage<EventLostFundsFromLiquidation> | undefined): boolean {
    return proto3.util.equals(EventLostFundsFromLiquidation, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventBatchDerivativePosition
 */
export class EventBatchDerivativePosition extends Message<EventBatchDerivativePosition> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.SubaccountPosition positions = 2;
   */
  positions: SubaccountPosition[] = [];

  constructor(data?: PartialMessage<EventBatchDerivativePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventBatchDerivativePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "positions", kind: "message", T: SubaccountPosition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDerivativePosition {
    return new EventBatchDerivativePosition().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDerivativePosition | PlainMessage<EventBatchDerivativePosition> | undefined, b: EventBatchDerivativePosition | PlainMessage<EventBatchDerivativePosition> | undefined): boolean {
    return proto3.util.equals(EventBatchDerivativePosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventDerivativeMarketPaused
 */
export class EventDerivativeMarketPaused extends Message<EventDerivativeMarketPaused> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string total_missing_funds = 3;
   */
  totalMissingFunds = "";

  /**
   * @generated from field: string missing_funds_rate = 4;
   */
  missingFundsRate = "";

  constructor(data?: PartialMessage<EventDerivativeMarketPaused>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventDerivativeMarketPaused";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_missing_funds", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "missing_funds_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventDerivativeMarketPaused {
    return new EventDerivativeMarketPaused().fromJsonString(jsonString, options);
  }

  static equals(a: EventDerivativeMarketPaused | PlainMessage<EventDerivativeMarketPaused> | undefined, b: EventDerivativeMarketPaused | PlainMessage<EventDerivativeMarketPaused> | undefined): boolean {
    return proto3.util.equals(EventDerivativeMarketPaused, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSettledMarketBalance
 */
export class EventSettledMarketBalance extends Message<EventSettledMarketBalance> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<EventSettledMarketBalance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSettledMarketBalance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSettledMarketBalance {
    return new EventSettledMarketBalance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSettledMarketBalance {
    return new EventSettledMarketBalance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSettledMarketBalance {
    return new EventSettledMarketBalance().fromJsonString(jsonString, options);
  }

  static equals(a: EventSettledMarketBalance | PlainMessage<EventSettledMarketBalance> | undefined, b: EventSettledMarketBalance | PlainMessage<EventSettledMarketBalance> | undefined): boolean {
    return proto3.util.equals(EventSettledMarketBalance, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventNotSettledMarketBalance
 */
export class EventNotSettledMarketBalance extends Message<EventNotSettledMarketBalance> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<EventNotSettledMarketBalance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventNotSettledMarketBalance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNotSettledMarketBalance {
    return new EventNotSettledMarketBalance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNotSettledMarketBalance {
    return new EventNotSettledMarketBalance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNotSettledMarketBalance {
    return new EventNotSettledMarketBalance().fromJsonString(jsonString, options);
  }

  static equals(a: EventNotSettledMarketBalance | PlainMessage<EventNotSettledMarketBalance> | undefined, b: EventNotSettledMarketBalance | PlainMessage<EventNotSettledMarketBalance> | undefined): boolean {
    return proto3.util.equals(EventNotSettledMarketBalance, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventMarketBeyondBankruptcy
 */
export class EventMarketBeyondBankruptcy extends Message<EventMarketBeyondBankruptcy> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string missing_market_funds = 3;
   */
  missingMarketFunds = "";

  constructor(data?: PartialMessage<EventMarketBeyondBankruptcy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventMarketBeyondBankruptcy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "missing_market_funds", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventMarketBeyondBankruptcy {
    return new EventMarketBeyondBankruptcy().fromJsonString(jsonString, options);
  }

  static equals(a: EventMarketBeyondBankruptcy | PlainMessage<EventMarketBeyondBankruptcy> | undefined, b: EventMarketBeyondBankruptcy | PlainMessage<EventMarketBeyondBankruptcy> | undefined): boolean {
    return proto3.util.equals(EventMarketBeyondBankruptcy, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventAllPositionsHaircut
 */
export class EventAllPositionsHaircut extends Message<EventAllPositionsHaircut> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string settle_price = 2;
   */
  settlePrice = "";

  /**
   * @generated from field: string missing_funds_rate = 3;
   */
  missingFundsRate = "";

  constructor(data?: PartialMessage<EventAllPositionsHaircut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventAllPositionsHaircut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "settle_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "missing_funds_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAllPositionsHaircut {
    return new EventAllPositionsHaircut().fromJsonString(jsonString, options);
  }

  static equals(a: EventAllPositionsHaircut | PlainMessage<EventAllPositionsHaircut> | undefined, b: EventAllPositionsHaircut | PlainMessage<EventAllPositionsHaircut> | undefined): boolean {
    return proto3.util.equals(EventAllPositionsHaircut, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventBinaryOptionsMarketUpdate
 */
export class EventBinaryOptionsMarketUpdate extends Message<EventBinaryOptionsMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v2.BinaryOptionsMarket market = 1;
   */
  market?: BinaryOptionsMarket;

  constructor(data?: PartialMessage<EventBinaryOptionsMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventBinaryOptionsMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: BinaryOptionsMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBinaryOptionsMarketUpdate {
    return new EventBinaryOptionsMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventBinaryOptionsMarketUpdate | PlainMessage<EventBinaryOptionsMarketUpdate> | undefined, b: EventBinaryOptionsMarketUpdate | PlainMessage<EventBinaryOptionsMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventBinaryOptionsMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventNewSpotOrders
 */
export class EventNewSpotOrders extends Message<EventNewSpotOrders> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.SpotLimitOrder buy_orders = 2;
   */
  buyOrders: SpotLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.SpotLimitOrder sell_orders = 3;
   */
  sellOrders: SpotLimitOrder[] = [];

  constructor(data?: PartialMessage<EventNewSpotOrders>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventNewSpotOrders";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_orders", kind: "message", T: SpotLimitOrder, repeated: true },
    { no: 3, name: "sell_orders", kind: "message", T: SpotLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewSpotOrders {
    return new EventNewSpotOrders().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewSpotOrders | PlainMessage<EventNewSpotOrders> | undefined, b: EventNewSpotOrders | PlainMessage<EventNewSpotOrders> | undefined): boolean {
    return proto3.util.equals(EventNewSpotOrders, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventNewDerivativeOrders
 */
export class EventNewDerivativeOrders extends Message<EventNewDerivativeOrders> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.DerivativeLimitOrder buy_orders = 2;
   */
  buyOrders: DerivativeLimitOrder[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.DerivativeLimitOrder sell_orders = 3;
   */
  sellOrders: DerivativeLimitOrder[] = [];

  constructor(data?: PartialMessage<EventNewDerivativeOrders>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventNewDerivativeOrders";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
    { no: 3, name: "sell_orders", kind: "message", T: DerivativeLimitOrder, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewDerivativeOrders {
    return new EventNewDerivativeOrders().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewDerivativeOrders | PlainMessage<EventNewDerivativeOrders> | undefined, b: EventNewDerivativeOrders | PlainMessage<EventNewDerivativeOrders> | undefined): boolean {
    return proto3.util.equals(EventNewDerivativeOrders, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventCancelSpotOrder
 */
export class EventCancelSpotOrder extends Message<EventCancelSpotOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v2.SpotLimitOrder order = 2;
   */
  order?: SpotLimitOrder;

  constructor(data?: PartialMessage<EventCancelSpotOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventCancelSpotOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: SpotLimitOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelSpotOrder {
    return new EventCancelSpotOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelSpotOrder | PlainMessage<EventCancelSpotOrder> | undefined, b: EventCancelSpotOrder | PlainMessage<EventCancelSpotOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelSpotOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSpotMarketUpdate
 */
export class EventSpotMarketUpdate extends Message<EventSpotMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v2.SpotMarket market = 1;
   */
  market?: SpotMarket;

  constructor(data?: PartialMessage<EventSpotMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSpotMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: SpotMarket },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSpotMarketUpdate {
    return new EventSpotMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventSpotMarketUpdate | PlainMessage<EventSpotMarketUpdate> | undefined, b: EventSpotMarketUpdate | PlainMessage<EventSpotMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventSpotMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventPerpetualMarketUpdate
 */
export class EventPerpetualMarketUpdate extends Message<EventPerpetualMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v2.DerivativeMarket market = 1;
   */
  market?: DerivativeMarket;

  /**
   * @generated from field: injective.exchange.v2.PerpetualMarketInfo perpetual_market_info = 2;
   */
  perpetualMarketInfo?: PerpetualMarketInfo;

  /**
   * @generated from field: injective.exchange.v2.PerpetualMarketFunding funding = 3;
   */
  funding?: PerpetualMarketFunding;

  constructor(data?: PartialMessage<EventPerpetualMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventPerpetualMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 2, name: "perpetual_market_info", kind: "message", T: PerpetualMarketInfo },
    { no: 3, name: "funding", kind: "message", T: PerpetualMarketFunding },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventPerpetualMarketUpdate {
    return new EventPerpetualMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventPerpetualMarketUpdate | PlainMessage<EventPerpetualMarketUpdate> | undefined, b: EventPerpetualMarketUpdate | PlainMessage<EventPerpetualMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventPerpetualMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventExpiryFuturesMarketUpdate
 */
export class EventExpiryFuturesMarketUpdate extends Message<EventExpiryFuturesMarketUpdate> {
  /**
   * @generated from field: injective.exchange.v2.DerivativeMarket market = 1;
   */
  market?: DerivativeMarket;

  /**
   * @generated from field: injective.exchange.v2.ExpiryFuturesMarketInfo expiry_futures_market_info = 3;
   */
  expiryFuturesMarketInfo?: ExpiryFuturesMarketInfo;

  constructor(data?: PartialMessage<EventExpiryFuturesMarketUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventExpiryFuturesMarketUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market", kind: "message", T: DerivativeMarket },
    { no: 3, name: "expiry_futures_market_info", kind: "message", T: ExpiryFuturesMarketInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventExpiryFuturesMarketUpdate {
    return new EventExpiryFuturesMarketUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventExpiryFuturesMarketUpdate | PlainMessage<EventExpiryFuturesMarketUpdate> | undefined, b: EventExpiryFuturesMarketUpdate | PlainMessage<EventExpiryFuturesMarketUpdate> | undefined): boolean {
    return proto3.util.equals(EventExpiryFuturesMarketUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventPerpetualMarketFundingUpdate
 */
export class EventPerpetualMarketFundingUpdate extends Message<EventPerpetualMarketFundingUpdate> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v2.PerpetualMarketFunding funding = 2;
   */
  funding?: PerpetualMarketFunding;

  /**
   * @generated from field: bool is_hourly_funding = 3;
   */
  isHourlyFunding = false;

  /**
   * @generated from field: string funding_rate = 4;
   */
  fundingRate = "";

  /**
   * @generated from field: string mark_price = 5;
   */
  markPrice = "";

  constructor(data?: PartialMessage<EventPerpetualMarketFundingUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventPerpetualMarketFundingUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "funding", kind: "message", T: PerpetualMarketFunding },
    { no: 3, name: "is_hourly_funding", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "funding_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventPerpetualMarketFundingUpdate {
    return new EventPerpetualMarketFundingUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventPerpetualMarketFundingUpdate | PlainMessage<EventPerpetualMarketFundingUpdate> | undefined, b: EventPerpetualMarketFundingUpdate | PlainMessage<EventPerpetualMarketFundingUpdate> | undefined): boolean {
    return proto3.util.equals(EventPerpetualMarketFundingUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSubaccountDeposit
 */
export class EventSubaccountDeposit extends Message<EventSubaccountDeposit> {
  /**
   * @generated from field: string src_address = 1;
   */
  srcAddress = "";

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountDeposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSubaccountDeposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountDeposit {
    return new EventSubaccountDeposit().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountDeposit | PlainMessage<EventSubaccountDeposit> | undefined, b: EventSubaccountDeposit | PlainMessage<EventSubaccountDeposit> | undefined): boolean {
    return proto3.util.equals(EventSubaccountDeposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSubaccountWithdraw
 */
export class EventSubaccountWithdraw extends Message<EventSubaccountWithdraw> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string dst_address = 2;
   */
  dstAddress = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountWithdraw>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSubaccountWithdraw";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "dst_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountWithdraw {
    return new EventSubaccountWithdraw().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountWithdraw | PlainMessage<EventSubaccountWithdraw> | undefined, b: EventSubaccountWithdraw | PlainMessage<EventSubaccountWithdraw> | undefined): boolean {
    return proto3.util.equals(EventSubaccountWithdraw, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSubaccountBalanceTransfer
 */
export class EventSubaccountBalanceTransfer extends Message<EventSubaccountBalanceTransfer> {
  /**
   * @generated from field: string src_subaccount_id = 1;
   */
  srcSubaccountId = "";

  /**
   * @generated from field: string dst_subaccount_id = 2;
   */
  dstSubaccountId = "";

  /**
   * @generated from field: cosmos.base.v1beta1.Coin amount = 3;
   */
  amount?: Coin;

  constructor(data?: PartialMessage<EventSubaccountBalanceTransfer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSubaccountBalanceTransfer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "src_subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dst_subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSubaccountBalanceTransfer {
    return new EventSubaccountBalanceTransfer().fromJsonString(jsonString, options);
  }

  static equals(a: EventSubaccountBalanceTransfer | PlainMessage<EventSubaccountBalanceTransfer> | undefined, b: EventSubaccountBalanceTransfer | PlainMessage<EventSubaccountBalanceTransfer> | undefined): boolean {
    return proto3.util.equals(EventSubaccountBalanceTransfer, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventBatchDepositUpdate
 */
export class EventBatchDepositUpdate extends Message<EventBatchDepositUpdate> {
  /**
   * @generated from field: repeated injective.exchange.v2.DepositUpdate deposit_updates = 1;
   */
  depositUpdates: DepositUpdate[] = [];

  constructor(data?: PartialMessage<EventBatchDepositUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventBatchDepositUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deposit_updates", kind: "message", T: DepositUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventBatchDepositUpdate {
    return new EventBatchDepositUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventBatchDepositUpdate | PlainMessage<EventBatchDepositUpdate> | undefined, b: EventBatchDepositUpdate | PlainMessage<EventBatchDepositUpdate> | undefined): boolean {
    return proto3.util.equals(EventBatchDepositUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativeMarketOrderCancel
 */
export class DerivativeMarketOrderCancel extends Message<DerivativeMarketOrderCancel> {
  /**
   * @generated from field: injective.exchange.v2.DerivativeMarketOrder market_order = 1;
   */
  marketOrder?: DerivativeMarketOrder;

  /**
   * @generated from field: string cancel_quantity = 2;
   */
  cancelQuantity = "";

  constructor(data?: PartialMessage<DerivativeMarketOrderCancel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeMarketOrderCancel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_order", kind: "message", T: DerivativeMarketOrder },
    { no: 2, name: "cancel_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeMarketOrderCancel {
    return new DerivativeMarketOrderCancel().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeMarketOrderCancel | PlainMessage<DerivativeMarketOrderCancel> | undefined, b: DerivativeMarketOrderCancel | PlainMessage<DerivativeMarketOrderCancel> | undefined): boolean {
    return proto3.util.equals(DerivativeMarketOrderCancel, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventCancelDerivativeOrder
 */
export class EventCancelDerivativeOrder extends Message<EventCancelDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isLimitCancel = 2;
   */
  isLimitCancel = false;

  /**
   * @generated from field: injective.exchange.v2.DerivativeLimitOrder limit_order = 3;
   */
  limitOrder?: DerivativeLimitOrder;

  /**
   * @generated from field: injective.exchange.v2.DerivativeMarketOrderCancel market_order_cancel = 4;
   */
  marketOrderCancel?: DerivativeMarketOrderCancel;

  constructor(data?: PartialMessage<EventCancelDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventCancelDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "limit_order", kind: "message", T: DerivativeLimitOrder },
    { no: 4, name: "market_order_cancel", kind: "message", T: DerivativeMarketOrderCancel },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelDerivativeOrder {
    return new EventCancelDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelDerivativeOrder | PlainMessage<EventCancelDerivativeOrder> | undefined, b: EventCancelDerivativeOrder | PlainMessage<EventCancelDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventFeeDiscountSchedule
 */
export class EventFeeDiscountSchedule extends Message<EventFeeDiscountSchedule> {
  /**
   * @generated from field: injective.exchange.v2.FeeDiscountSchedule schedule = 1;
   */
  schedule?: FeeDiscountSchedule;

  constructor(data?: PartialMessage<EventFeeDiscountSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventFeeDiscountSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule", kind: "message", T: FeeDiscountSchedule },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventFeeDiscountSchedule {
    return new EventFeeDiscountSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: EventFeeDiscountSchedule | PlainMessage<EventFeeDiscountSchedule> | undefined, b: EventFeeDiscountSchedule | PlainMessage<EventFeeDiscountSchedule> | undefined): boolean {
    return proto3.util.equals(EventFeeDiscountSchedule, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventTradingRewardCampaignUpdate
 */
export class EventTradingRewardCampaignUpdate extends Message<EventTradingRewardCampaignUpdate> {
  /**
   * @generated from field: injective.exchange.v2.TradingRewardCampaignInfo campaign_info = 1;
   */
  campaignInfo?: TradingRewardCampaignInfo;

  /**
   * @generated from field: repeated injective.exchange.v2.CampaignRewardPool campaign_reward_pools = 2;
   */
  campaignRewardPools: CampaignRewardPool[] = [];

  constructor(data?: PartialMessage<EventTradingRewardCampaignUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventTradingRewardCampaignUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "campaign_info", kind: "message", T: TradingRewardCampaignInfo },
    { no: 2, name: "campaign_reward_pools", kind: "message", T: CampaignRewardPool, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTradingRewardCampaignUpdate {
    return new EventTradingRewardCampaignUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventTradingRewardCampaignUpdate | PlainMessage<EventTradingRewardCampaignUpdate> | undefined, b: EventTradingRewardCampaignUpdate | PlainMessage<EventTradingRewardCampaignUpdate> | undefined): boolean {
    return proto3.util.equals(EventTradingRewardCampaignUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventTradingRewardDistribution
 */
export class EventTradingRewardDistribution extends Message<EventTradingRewardDistribution> {
  /**
   * @generated from field: repeated injective.exchange.v2.AccountRewards account_rewards = 1;
   */
  accountRewards: AccountRewards[] = [];

  constructor(data?: PartialMessage<EventTradingRewardDistribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventTradingRewardDistribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_rewards", kind: "message", T: AccountRewards, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTradingRewardDistribution {
    return new EventTradingRewardDistribution().fromJsonString(jsonString, options);
  }

  static equals(a: EventTradingRewardDistribution | PlainMessage<EventTradingRewardDistribution> | undefined, b: EventTradingRewardDistribution | PlainMessage<EventTradingRewardDistribution> | undefined): boolean {
    return proto3.util.equals(EventTradingRewardDistribution, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventNewConditionalDerivativeOrder
 */
export class EventNewConditionalDerivativeOrder extends Message<EventNewConditionalDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: injective.exchange.v2.DerivativeOrder order = 2;
   */
  order?: DerivativeOrder;

  /**
   * @generated from field: bytes hash = 3;
   */
  hash = new Uint8Array(0);

  /**
   * @generated from field: bool is_market = 4;
   */
  isMarket = false;

  constructor(data?: PartialMessage<EventNewConditionalDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventNewConditionalDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "order", kind: "message", T: DerivativeOrder },
    { no: 3, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "is_market", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventNewConditionalDerivativeOrder {
    return new EventNewConditionalDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventNewConditionalDerivativeOrder | PlainMessage<EventNewConditionalDerivativeOrder> | undefined, b: EventNewConditionalDerivativeOrder | PlainMessage<EventNewConditionalDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventNewConditionalDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventCancelConditionalDerivativeOrder
 */
export class EventCancelConditionalDerivativeOrder extends Message<EventCancelConditionalDerivativeOrder> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isLimitCancel = 2;
   */
  isLimitCancel = false;

  /**
   * @generated from field: injective.exchange.v2.DerivativeLimitOrder limit_order = 3;
   */
  limitOrder?: DerivativeLimitOrder;

  /**
   * @generated from field: injective.exchange.v2.DerivativeMarketOrder market_order = 4;
   */
  marketOrder?: DerivativeMarketOrder;

  constructor(data?: PartialMessage<EventCancelConditionalDerivativeOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventCancelConditionalDerivativeOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isLimitCancel", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "limit_order", kind: "message", T: DerivativeLimitOrder },
    { no: 4, name: "market_order", kind: "message", T: DerivativeMarketOrder },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventCancelConditionalDerivativeOrder {
    return new EventCancelConditionalDerivativeOrder().fromJsonString(jsonString, options);
  }

  static equals(a: EventCancelConditionalDerivativeOrder | PlainMessage<EventCancelConditionalDerivativeOrder> | undefined, b: EventCancelConditionalDerivativeOrder | PlainMessage<EventCancelConditionalDerivativeOrder> | undefined): boolean {
    return proto3.util.equals(EventCancelConditionalDerivativeOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventConditionalDerivativeOrderTrigger
 */
export class EventConditionalDerivativeOrderTrigger extends Message<EventConditionalDerivativeOrderTrigger> {
  /**
   * @generated from field: bytes market_id = 1;
   */
  marketId = new Uint8Array(0);

  /**
   * @generated from field: bool isLimitTrigger = 2;
   */
  isLimitTrigger = false;

  /**
   * @generated from field: bytes triggered_order_hash = 3;
   */
  triggeredOrderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes placed_order_hash = 4;
   */
  placedOrderHash = new Uint8Array(0);

  /**
   * @generated from field: string triggered_order_cid = 5;
   */
  triggeredOrderCid = "";

  constructor(data?: PartialMessage<EventConditionalDerivativeOrderTrigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventConditionalDerivativeOrderTrigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "isLimitTrigger", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "triggered_order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "placed_order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "triggered_order_cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventConditionalDerivativeOrderTrigger {
    return new EventConditionalDerivativeOrderTrigger().fromJsonString(jsonString, options);
  }

  static equals(a: EventConditionalDerivativeOrderTrigger | PlainMessage<EventConditionalDerivativeOrderTrigger> | undefined, b: EventConditionalDerivativeOrderTrigger | PlainMessage<EventConditionalDerivativeOrderTrigger> | undefined): boolean {
    return proto3.util.equals(EventConditionalDerivativeOrderTrigger, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventOrderFail
 */
export class EventOrderFail extends Message<EventOrderFail> {
  /**
   * @generated from field: bytes account = 1;
   */
  account = new Uint8Array(0);

  /**
   * @generated from field: repeated bytes hashes = 2;
   */
  hashes: Uint8Array[] = [];

  /**
   * @generated from field: repeated uint32 flags = 3;
   */
  flags: number[] = [];

  /**
   * @generated from field: repeated string cids = 4;
   */
  cids: string[] = [];

  constructor(data?: PartialMessage<EventOrderFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventOrderFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "hashes", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 3, name: "flags", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
    { no: 4, name: "cids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOrderFail {
    return new EventOrderFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOrderFail {
    return new EventOrderFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOrderFail {
    return new EventOrderFail().fromJsonString(jsonString, options);
  }

  static equals(a: EventOrderFail | PlainMessage<EventOrderFail> | undefined, b: EventOrderFail | PlainMessage<EventOrderFail> | undefined): boolean {
    return proto3.util.equals(EventOrderFail, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventAtomicMarketOrderFeeMultipliersUpdated
 */
export class EventAtomicMarketOrderFeeMultipliersUpdated extends Message<EventAtomicMarketOrderFeeMultipliersUpdated> {
  /**
   * @generated from field: repeated injective.exchange.v2.MarketFeeMultiplier market_fee_multipliers = 1;
   */
  marketFeeMultipliers: MarketFeeMultiplier[] = [];

  constructor(data?: PartialMessage<EventAtomicMarketOrderFeeMultipliersUpdated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventAtomicMarketOrderFeeMultipliersUpdated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_fee_multipliers", kind: "message", T: MarketFeeMultiplier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventAtomicMarketOrderFeeMultipliersUpdated {
    return new EventAtomicMarketOrderFeeMultipliersUpdated().fromJsonString(jsonString, options);
  }

  static equals(a: EventAtomicMarketOrderFeeMultipliersUpdated | PlainMessage<EventAtomicMarketOrderFeeMultipliersUpdated> | undefined, b: EventAtomicMarketOrderFeeMultipliersUpdated | PlainMessage<EventAtomicMarketOrderFeeMultipliersUpdated> | undefined): boolean {
    return proto3.util.equals(EventAtomicMarketOrderFeeMultipliersUpdated, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventOrderbookUpdate
 */
export class EventOrderbookUpdate extends Message<EventOrderbookUpdate> {
  /**
   * @generated from field: repeated injective.exchange.v2.OrderbookUpdate spot_updates = 1;
   */
  spotUpdates: OrderbookUpdate[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.OrderbookUpdate derivative_updates = 2;
   */
  derivativeUpdates: OrderbookUpdate[] = [];

  constructor(data?: PartialMessage<EventOrderbookUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventOrderbookUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spot_updates", kind: "message", T: OrderbookUpdate, repeated: true },
    { no: 2, name: "derivative_updates", kind: "message", T: OrderbookUpdate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOrderbookUpdate {
    return new EventOrderbookUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: EventOrderbookUpdate | PlainMessage<EventOrderbookUpdate> | undefined, b: EventOrderbookUpdate | PlainMessage<EventOrderbookUpdate> | undefined): boolean {
    return proto3.util.equals(EventOrderbookUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.OrderbookUpdate
 */
export class OrderbookUpdate extends Message<OrderbookUpdate> {
  /**
   * @generated from field: uint64 seq = 1;
   */
  seq = protoInt64.zero;

  /**
   * @generated from field: injective.exchange.v2.Orderbook orderbook = 2;
   */
  orderbook?: Orderbook;

  constructor(data?: PartialMessage<OrderbookUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.OrderbookUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "seq", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "orderbook", kind: "message", T: Orderbook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrderbookUpdate {
    return new OrderbookUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined, b: OrderbookUpdate | PlainMessage<OrderbookUpdate> | undefined): boolean {
    return proto3.util.equals(OrderbookUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.Orderbook
 */
export class Orderbook extends Message<Orderbook> {
  /**
   * @generated from field: bytes market_id = 1;
   */
  marketId = new Uint8Array(0);

  /**
   * @generated from field: repeated injective.exchange.v2.Level buy_levels = 2;
   */
  buyLevels: Level[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.Level sell_levels = 3;
   */
  sellLevels: Level[] = [];

  constructor(data?: PartialMessage<Orderbook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Orderbook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "buy_levels", kind: "message", T: Level, repeated: true },
    { no: 3, name: "sell_levels", kind: "message", T: Level, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Orderbook {
    return new Orderbook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Orderbook {
    return new Orderbook().fromJsonString(jsonString, options);
  }

  static equals(a: Orderbook | PlainMessage<Orderbook> | undefined, b: Orderbook | PlainMessage<Orderbook> | undefined): boolean {
    return proto3.util.equals(Orderbook, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventGrantAuthorizations
 */
export class EventGrantAuthorizations extends Message<EventGrantAuthorizations> {
  /**
   * @generated from field: string granter = 1;
   */
  granter = "";

  /**
   * @generated from field: repeated injective.exchange.v2.GrantAuthorization grants = 2;
   */
  grants: GrantAuthorization[] = [];

  constructor(data?: PartialMessage<EventGrantAuthorizations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventGrantAuthorizations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "grants", kind: "message", T: GrantAuthorization, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventGrantAuthorizations {
    return new EventGrantAuthorizations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventGrantAuthorizations {
    return new EventGrantAuthorizations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventGrantAuthorizations {
    return new EventGrantAuthorizations().fromJsonString(jsonString, options);
  }

  static equals(a: EventGrantAuthorizations | PlainMessage<EventGrantAuthorizations> | undefined, b: EventGrantAuthorizations | PlainMessage<EventGrantAuthorizations> | undefined): boolean {
    return proto3.util.equals(EventGrantAuthorizations, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventGrantActivation
 */
export class EventGrantActivation extends Message<EventGrantActivation> {
  /**
   * @generated from field: string grantee = 1;
   */
  grantee = "";

  /**
   * @generated from field: string granter = 2;
   */
  granter = "";

  /**
   * @generated from field: string amount = 3;
   */
  amount = "";

  constructor(data?: PartialMessage<EventGrantActivation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventGrantActivation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventGrantActivation {
    return new EventGrantActivation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventGrantActivation {
    return new EventGrantActivation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventGrantActivation {
    return new EventGrantActivation().fromJsonString(jsonString, options);
  }

  static equals(a: EventGrantActivation | PlainMessage<EventGrantActivation> | undefined, b: EventGrantActivation | PlainMessage<EventGrantActivation> | undefined): boolean {
    return proto3.util.equals(EventGrantActivation, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventInvalidGrant
 */
export class EventInvalidGrant extends Message<EventInvalidGrant> {
  /**
   * @generated from field: string grantee = 1;
   */
  grantee = "";

  /**
   * @generated from field: string granter = 2;
   */
  granter = "";

  constructor(data?: PartialMessage<EventInvalidGrant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventInvalidGrant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventInvalidGrant {
    return new EventInvalidGrant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventInvalidGrant {
    return new EventInvalidGrant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventInvalidGrant {
    return new EventInvalidGrant().fromJsonString(jsonString, options);
  }

  static equals(a: EventInvalidGrant | PlainMessage<EventInvalidGrant> | undefined, b: EventInvalidGrant | PlainMessage<EventInvalidGrant> | undefined): boolean {
    return proto3.util.equals(EventInvalidGrant, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventOrderCancelFail
 */
export class EventOrderCancelFail extends Message<EventOrderCancelFail> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * @generated from field: string order_hash = 3;
   */
  orderHash = "";

  /**
   * @generated from field: string cid = 4;
   */
  cid = "";

  /**
   * @generated from field: string description = 5;
   */
  description = "";

  constructor(data?: PartialMessage<EventOrderCancelFail>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventOrderCancelFail";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventOrderCancelFail {
    return new EventOrderCancelFail().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventOrderCancelFail {
    return new EventOrderCancelFail().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventOrderCancelFail {
    return new EventOrderCancelFail().fromJsonString(jsonString, options);
  }

  static equals(a: EventOrderCancelFail | PlainMessage<EventOrderCancelFail> | undefined, b: EventOrderCancelFail | PlainMessage<EventOrderCancelFail> | undefined): boolean {
    return proto3.util.equals(EventOrderCancelFail, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventDerivativeOrdersV2Migration
 */
export class EventDerivativeOrdersV2Migration extends Message<EventDerivativeOrdersV2Migration> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.DerivativeOrderV2Changes buy_order_changes = 2;
   */
  buyOrderChanges: DerivativeOrderV2Changes[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.DerivativeOrderV2Changes sell_order_changes = 3;
   */
  sellOrderChanges: DerivativeOrderV2Changes[] = [];

  constructor(data?: PartialMessage<EventDerivativeOrdersV2Migration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventDerivativeOrdersV2Migration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_order_changes", kind: "message", T: DerivativeOrderV2Changes, repeated: true },
    { no: 3, name: "sell_order_changes", kind: "message", T: DerivativeOrderV2Changes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventDerivativeOrdersV2Migration {
    return new EventDerivativeOrdersV2Migration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventDerivativeOrdersV2Migration {
    return new EventDerivativeOrdersV2Migration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventDerivativeOrdersV2Migration {
    return new EventDerivativeOrdersV2Migration().fromJsonString(jsonString, options);
  }

  static equals(a: EventDerivativeOrdersV2Migration | PlainMessage<EventDerivativeOrdersV2Migration> | undefined, b: EventDerivativeOrdersV2Migration | PlainMessage<EventDerivativeOrdersV2Migration> | undefined): boolean {
    return proto3.util.equals(EventDerivativeOrdersV2Migration, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativeOrderV2Changes
 */
export class DerivativeOrderV2Changes extends Message<DerivativeOrderV2Changes> {
  /**
   * @generated from field: string cid = 1;
   */
  cid = "";

  /**
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  /**
   * price of the order
   *
   * @generated from field: string p = 3;
   */
  p = "";

  /**
   * quantity of the order
   *
   * @generated from field: string q = 4;
   */
  q = "";

  /**
   * margin of the order
   *
   * @generated from field: string m = 5;
   */
  m = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string f = 6;
   */
  f = "";

  /**
   * trigger price of the order
   *
   * @generated from field: string tp = 7;
   */
  tp = "";

  constructor(data?: PartialMessage<DerivativeOrderV2Changes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeOrderV2Changes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "m", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "f", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "tp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeOrderV2Changes {
    return new DerivativeOrderV2Changes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeOrderV2Changes {
    return new DerivativeOrderV2Changes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeOrderV2Changes {
    return new DerivativeOrderV2Changes().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeOrderV2Changes | PlainMessage<DerivativeOrderV2Changes> | undefined, b: DerivativeOrderV2Changes | PlainMessage<DerivativeOrderV2Changes> | undefined): boolean {
    return proto3.util.equals(DerivativeOrderV2Changes, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventSpotOrdersV2Migration
 */
export class EventSpotOrdersV2Migration extends Message<EventSpotOrdersV2Migration> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.SpotOrderV2Changes buy_order_changes = 2;
   */
  buyOrderChanges: SpotOrderV2Changes[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.SpotOrderV2Changes sell_order_changes = 3;
   */
  sellOrderChanges: SpotOrderV2Changes[] = [];

  constructor(data?: PartialMessage<EventSpotOrdersV2Migration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventSpotOrdersV2Migration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "buy_order_changes", kind: "message", T: SpotOrderV2Changes, repeated: true },
    { no: 3, name: "sell_order_changes", kind: "message", T: SpotOrderV2Changes, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventSpotOrdersV2Migration {
    return new EventSpotOrdersV2Migration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventSpotOrdersV2Migration {
    return new EventSpotOrdersV2Migration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventSpotOrdersV2Migration {
    return new EventSpotOrdersV2Migration().fromJsonString(jsonString, options);
  }

  static equals(a: EventSpotOrdersV2Migration | PlainMessage<EventSpotOrdersV2Migration> | undefined, b: EventSpotOrdersV2Migration | PlainMessage<EventSpotOrdersV2Migration> | undefined): boolean {
    return proto3.util.equals(EventSpotOrdersV2Migration, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventTriggerConditionalMarketOrderFailed
 */
export class EventTriggerConditionalMarketOrderFailed extends Message<EventTriggerConditionalMarketOrderFailed> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * @generated from field: string mark_price = 3;
   */
  markPrice = "";

  /**
   * @generated from field: bytes order_hash = 4;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: string trigger_err = 5;
   */
  triggerErr = "";

  constructor(data?: PartialMessage<EventTriggerConditionalMarketOrderFailed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventTriggerConditionalMarketOrderFailed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "trigger_err", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTriggerConditionalMarketOrderFailed {
    return new EventTriggerConditionalMarketOrderFailed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTriggerConditionalMarketOrderFailed {
    return new EventTriggerConditionalMarketOrderFailed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTriggerConditionalMarketOrderFailed {
    return new EventTriggerConditionalMarketOrderFailed().fromJsonString(jsonString, options);
  }

  static equals(a: EventTriggerConditionalMarketOrderFailed | PlainMessage<EventTriggerConditionalMarketOrderFailed> | undefined, b: EventTriggerConditionalMarketOrderFailed | PlainMessage<EventTriggerConditionalMarketOrderFailed> | undefined): boolean {
    return proto3.util.equals(EventTriggerConditionalMarketOrderFailed, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventTriggerConditionalLimitOrderFailed
 */
export class EventTriggerConditionalLimitOrderFailed extends Message<EventTriggerConditionalLimitOrderFailed> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: string subaccount_id = 2;
   */
  subaccountId = "";

  /**
   * @generated from field: string mark_price = 3;
   */
  markPrice = "";

  /**
   * @generated from field: bytes order_hash = 4;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: string trigger_err = 5;
   */
  triggerErr = "";

  constructor(data?: PartialMessage<EventTriggerConditionalLimitOrderFailed>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventTriggerConditionalLimitOrderFailed";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "trigger_err", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventTriggerConditionalLimitOrderFailed {
    return new EventTriggerConditionalLimitOrderFailed().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventTriggerConditionalLimitOrderFailed {
    return new EventTriggerConditionalLimitOrderFailed().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventTriggerConditionalLimitOrderFailed {
    return new EventTriggerConditionalLimitOrderFailed().fromJsonString(jsonString, options);
  }

  static equals(a: EventTriggerConditionalLimitOrderFailed | PlainMessage<EventTriggerConditionalLimitOrderFailed> | undefined, b: EventTriggerConditionalLimitOrderFailed | PlainMessage<EventTriggerConditionalLimitOrderFailed> | undefined): boolean {
    return proto3.util.equals(EventTriggerConditionalLimitOrderFailed, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SpotOrderV2Changes
 */
export class SpotOrderV2Changes extends Message<SpotOrderV2Changes> {
  /**
   * @generated from field: string cid = 1;
   */
  cid = "";

  /**
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  /**
   * price of the order
   *
   * @generated from field: string p = 3;
   */
  p = "";

  /**
   * quantity of the order
   *
   * @generated from field: string q = 4;
   */
  q = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string f = 5;
   */
  f = "";

  /**
   * trigger_price is the trigger price used by stop/take orders
   *
   * @generated from field: string tp = 6;
   */
  tp = "";

  constructor(data?: PartialMessage<SpotOrderV2Changes>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SpotOrderV2Changes";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "f", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "tp", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpotOrderV2Changes {
    return new SpotOrderV2Changes().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpotOrderV2Changes {
    return new SpotOrderV2Changes().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpotOrderV2Changes {
    return new SpotOrderV2Changes().fromJsonString(jsonString, options);
  }

  static equals(a: SpotOrderV2Changes | PlainMessage<SpotOrderV2Changes> | undefined, b: SpotOrderV2Changes | PlainMessage<SpotOrderV2Changes> | undefined): boolean {
    return proto3.util.equals(SpotOrderV2Changes, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EventDerivativePositionV2Migration
 */
export class EventDerivativePositionV2Migration extends Message<EventDerivativePositionV2Migration> {
  /**
   * @generated from field: injective.exchange.v2.DerivativePosition position = 1;
   */
  position?: DerivativePosition;

  constructor(data?: PartialMessage<EventDerivativePositionV2Migration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EventDerivativePositionV2Migration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: DerivativePosition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventDerivativePositionV2Migration {
    return new EventDerivativePositionV2Migration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventDerivativePositionV2Migration {
    return new EventDerivativePositionV2Migration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventDerivativePositionV2Migration {
    return new EventDerivativePositionV2Migration().fromJsonString(jsonString, options);
  }

  static equals(a: EventDerivativePositionV2Migration | PlainMessage<EventDerivativePositionV2Migration> | undefined, b: EventDerivativePositionV2Migration | PlainMessage<EventDerivativePositionV2Migration> | undefined): boolean {
    return proto3.util.equals(EventDerivativePositionV2Migration, a, b);
  }
}

