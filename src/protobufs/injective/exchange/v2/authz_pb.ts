// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v2/authz.proto (package injective.exchange.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * spot authz messages
 *
 * @generated from message injective.exchange.v2.CreateSpotLimitOrderAuthz
 */
export class CreateSpotLimitOrderAuthz extends Message<CreateSpotLimitOrderAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CreateSpotLimitOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CreateSpotLimitOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSpotLimitOrderAuthz {
    return new CreateSpotLimitOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSpotLimitOrderAuthz {
    return new CreateSpotLimitOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSpotLimitOrderAuthz {
    return new CreateSpotLimitOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSpotLimitOrderAuthz | PlainMessage<CreateSpotLimitOrderAuthz> | undefined, b: CreateSpotLimitOrderAuthz | PlainMessage<CreateSpotLimitOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CreateSpotLimitOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.CreateSpotMarketOrderAuthz
 */
export class CreateSpotMarketOrderAuthz extends Message<CreateSpotMarketOrderAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CreateSpotMarketOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CreateSpotMarketOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSpotMarketOrderAuthz {
    return new CreateSpotMarketOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSpotMarketOrderAuthz {
    return new CreateSpotMarketOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSpotMarketOrderAuthz {
    return new CreateSpotMarketOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSpotMarketOrderAuthz | PlainMessage<CreateSpotMarketOrderAuthz> | undefined, b: CreateSpotMarketOrderAuthz | PlainMessage<CreateSpotMarketOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CreateSpotMarketOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.BatchCreateSpotLimitOrdersAuthz
 */
export class BatchCreateSpotLimitOrdersAuthz extends Message<BatchCreateSpotLimitOrdersAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<BatchCreateSpotLimitOrdersAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BatchCreateSpotLimitOrdersAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCreateSpotLimitOrdersAuthz {
    return new BatchCreateSpotLimitOrdersAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCreateSpotLimitOrdersAuthz {
    return new BatchCreateSpotLimitOrdersAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCreateSpotLimitOrdersAuthz {
    return new BatchCreateSpotLimitOrdersAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCreateSpotLimitOrdersAuthz | PlainMessage<BatchCreateSpotLimitOrdersAuthz> | undefined, b: BatchCreateSpotLimitOrdersAuthz | PlainMessage<BatchCreateSpotLimitOrdersAuthz> | undefined): boolean {
    return proto3.util.equals(BatchCreateSpotLimitOrdersAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.CancelSpotOrderAuthz
 */
export class CancelSpotOrderAuthz extends Message<CancelSpotOrderAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CancelSpotOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CancelSpotOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelSpotOrderAuthz {
    return new CancelSpotOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelSpotOrderAuthz {
    return new CancelSpotOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelSpotOrderAuthz {
    return new CancelSpotOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CancelSpotOrderAuthz | PlainMessage<CancelSpotOrderAuthz> | undefined, b: CancelSpotOrderAuthz | PlainMessage<CancelSpotOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CancelSpotOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.BatchCancelSpotOrdersAuthz
 */
export class BatchCancelSpotOrdersAuthz extends Message<BatchCancelSpotOrdersAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<BatchCancelSpotOrdersAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BatchCancelSpotOrdersAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCancelSpotOrdersAuthz {
    return new BatchCancelSpotOrdersAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCancelSpotOrdersAuthz {
    return new BatchCancelSpotOrdersAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCancelSpotOrdersAuthz {
    return new BatchCancelSpotOrdersAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCancelSpotOrdersAuthz | PlainMessage<BatchCancelSpotOrdersAuthz> | undefined, b: BatchCancelSpotOrdersAuthz | PlainMessage<BatchCancelSpotOrdersAuthz> | undefined): boolean {
    return proto3.util.equals(BatchCancelSpotOrdersAuthz, a, b);
  }
}

/**
 * derivative authz messages
 *
 * @generated from message injective.exchange.v2.CreateDerivativeLimitOrderAuthz
 */
export class CreateDerivativeLimitOrderAuthz extends Message<CreateDerivativeLimitOrderAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CreateDerivativeLimitOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CreateDerivativeLimitOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDerivativeLimitOrderAuthz {
    return new CreateDerivativeLimitOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDerivativeLimitOrderAuthz {
    return new CreateDerivativeLimitOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDerivativeLimitOrderAuthz {
    return new CreateDerivativeLimitOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDerivativeLimitOrderAuthz | PlainMessage<CreateDerivativeLimitOrderAuthz> | undefined, b: CreateDerivativeLimitOrderAuthz | PlainMessage<CreateDerivativeLimitOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CreateDerivativeLimitOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.CreateDerivativeMarketOrderAuthz
 */
export class CreateDerivativeMarketOrderAuthz extends Message<CreateDerivativeMarketOrderAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CreateDerivativeMarketOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CreateDerivativeMarketOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDerivativeMarketOrderAuthz {
    return new CreateDerivativeMarketOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDerivativeMarketOrderAuthz {
    return new CreateDerivativeMarketOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDerivativeMarketOrderAuthz {
    return new CreateDerivativeMarketOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDerivativeMarketOrderAuthz | PlainMessage<CreateDerivativeMarketOrderAuthz> | undefined, b: CreateDerivativeMarketOrderAuthz | PlainMessage<CreateDerivativeMarketOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CreateDerivativeMarketOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.BatchCreateDerivativeLimitOrdersAuthz
 */
export class BatchCreateDerivativeLimitOrdersAuthz extends Message<BatchCreateDerivativeLimitOrdersAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<BatchCreateDerivativeLimitOrdersAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BatchCreateDerivativeLimitOrdersAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCreateDerivativeLimitOrdersAuthz {
    return new BatchCreateDerivativeLimitOrdersAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCreateDerivativeLimitOrdersAuthz {
    return new BatchCreateDerivativeLimitOrdersAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCreateDerivativeLimitOrdersAuthz {
    return new BatchCreateDerivativeLimitOrdersAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCreateDerivativeLimitOrdersAuthz | PlainMessage<BatchCreateDerivativeLimitOrdersAuthz> | undefined, b: BatchCreateDerivativeLimitOrdersAuthz | PlainMessage<BatchCreateDerivativeLimitOrdersAuthz> | undefined): boolean {
    return proto3.util.equals(BatchCreateDerivativeLimitOrdersAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.CancelDerivativeOrderAuthz
 */
export class CancelDerivativeOrderAuthz extends Message<CancelDerivativeOrderAuthz> {
  /**
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<CancelDerivativeOrderAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CancelDerivativeOrderAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelDerivativeOrderAuthz {
    return new CancelDerivativeOrderAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelDerivativeOrderAuthz {
    return new CancelDerivativeOrderAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelDerivativeOrderAuthz {
    return new CancelDerivativeOrderAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: CancelDerivativeOrderAuthz | PlainMessage<CancelDerivativeOrderAuthz> | undefined, b: CancelDerivativeOrderAuthz | PlainMessage<CancelDerivativeOrderAuthz> | undefined): boolean {
    return proto3.util.equals(CancelDerivativeOrderAuthz, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.BatchCancelDerivativeOrdersAuthz
 */
export class BatchCancelDerivativeOrdersAuthz extends Message<BatchCancelDerivativeOrdersAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market IDs
   *
   * @generated from field: repeated string market_ids = 2;
   */
  marketIds: string[] = [];

  constructor(data?: PartialMessage<BatchCancelDerivativeOrdersAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BatchCancelDerivativeOrdersAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCancelDerivativeOrdersAuthz {
    return new BatchCancelDerivativeOrdersAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCancelDerivativeOrdersAuthz {
    return new BatchCancelDerivativeOrdersAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCancelDerivativeOrdersAuthz {
    return new BatchCancelDerivativeOrdersAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCancelDerivativeOrdersAuthz | PlainMessage<BatchCancelDerivativeOrdersAuthz> | undefined, b: BatchCancelDerivativeOrdersAuthz | PlainMessage<BatchCancelDerivativeOrdersAuthz> | undefined): boolean {
    return proto3.util.equals(BatchCancelDerivativeOrdersAuthz, a, b);
  }
}

/**
 * common authz message used in both spot & derivative markets
 *
 * @generated from message injective.exchange.v2.BatchUpdateOrdersAuthz
 */
export class BatchUpdateOrdersAuthz extends Message<BatchUpdateOrdersAuthz> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the spot market IDs
   *
   * @generated from field: repeated string spot_markets = 2;
   */
  spotMarkets: string[] = [];

  /**
   * the derivative market IDs
   *
   * @generated from field: repeated string derivative_markets = 3;
   */
  derivativeMarkets: string[] = [];

  constructor(data?: PartialMessage<BatchUpdateOrdersAuthz>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.BatchUpdateOrdersAuthz";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spot_markets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "derivative_markets", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchUpdateOrdersAuthz {
    return new BatchUpdateOrdersAuthz().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchUpdateOrdersAuthz {
    return new BatchUpdateOrdersAuthz().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchUpdateOrdersAuthz {
    return new BatchUpdateOrdersAuthz().fromJsonString(jsonString, options);
  }

  static equals(a: BatchUpdateOrdersAuthz | PlainMessage<BatchUpdateOrdersAuthz> | undefined, b: BatchUpdateOrdersAuthz | PlainMessage<BatchUpdateOrdersAuthz> | undefined): boolean {
    return proto3.util.equals(BatchUpdateOrdersAuthz, a, b);
  }
}

/**
 * GenericExchangeAuthorization gives the grantee permissions to execute
 * the provided Exchange method on behalf of the granter's account.
 *
 * @generated from message injective.exchange.v2.GenericExchangeAuthorization
 */
export class GenericExchangeAuthorization extends Message<GenericExchangeAuthorization> {
  /**
   * Msg, identified by it's type URL, to grant permissions to the grantee
   *
   * @generated from field: string msg = 1;
   */
  msg = "";

  /**
   * SpendLimit is the maximum amount of tokens that the grantee can spend on
   * behalf of the granter. If not set, there is no spend limit.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin spend_limit = 2;
   */
  spendLimit: Coin[] = [];

  constructor(data?: PartialMessage<GenericExchangeAuthorization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.GenericExchangeAuthorization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msg", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "spend_limit", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenericExchangeAuthorization {
    return new GenericExchangeAuthorization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenericExchangeAuthorization {
    return new GenericExchangeAuthorization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenericExchangeAuthorization {
    return new GenericExchangeAuthorization().fromJsonString(jsonString, options);
  }

  static equals(a: GenericExchangeAuthorization | PlainMessage<GenericExchangeAuthorization> | undefined, b: GenericExchangeAuthorization | PlainMessage<GenericExchangeAuthorization> | undefined): boolean {
    return proto3.util.equals(GenericExchangeAuthorization, a, b);
  }
}

