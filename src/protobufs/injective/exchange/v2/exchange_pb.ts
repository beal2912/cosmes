// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/exchange/v2/exchange.proto (package injective.exchange.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { AtomicMarketOrderAccessLevel } from "./order_pb.js";
import { MarketVolume } from "./market_pb.js";

/**
 * @generated from enum injective.exchange.v2.ExecutionType
 */
export enum ExecutionType {
  /**
   * @generated from enum value: UnspecifiedExecutionType = 0;
   */
  UnspecifiedExecutionType = 0,

  /**
   * @generated from enum value: Market = 1;
   */
  Market = 1,

  /**
   * @generated from enum value: LimitFill = 2;
   */
  LimitFill = 2,

  /**
   * @generated from enum value: LimitMatchRestingOrder = 3;
   */
  LimitMatchRestingOrder = 3,

  /**
   * @generated from enum value: LimitMatchNewOrder = 4;
   */
  LimitMatchNewOrder = 4,

  /**
   * @generated from enum value: MarketLiquidation = 5;
   */
  MarketLiquidation = 5,

  /**
   * @generated from enum value: ExpiryMarketSettlement = 6;
   */
  ExpiryMarketSettlement = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecutionType)
proto3.util.setEnumType(ExecutionType, "injective.exchange.v2.ExecutionType", [
  { no: 0, name: "UnspecifiedExecutionType" },
  { no: 1, name: "Market" },
  { no: 2, name: "LimitFill" },
  { no: 3, name: "LimitMatchRestingOrder" },
  { no: 4, name: "LimitMatchNewOrder" },
  { no: 5, name: "MarketLiquidation" },
  { no: 6, name: "ExpiryMarketSettlement" },
]);

/**
 * @generated from message injective.exchange.v2.Params
 */
export class Params extends Message<Params> {
  /**
   * spot_market_instant_listing_fee defines the expedited fee in INJ required
   * to create a spot market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin spot_market_instant_listing_fee = 1;
   */
  spotMarketInstantListingFee?: Coin;

  /**
   * derivative_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin derivative_market_instant_listing_fee = 2;
   */
  derivativeMarketInstantListingFee?: Coin;

  /**
   * default_spot_maker_fee defines the default exchange trade fee for makers on
   * a spot market
   *
   * @generated from field: string default_spot_maker_fee_rate = 3;
   */
  defaultSpotMakerFeeRate = "";

  /**
   * default_spot_taker_fee_rate defines the default exchange trade fee rate for
   * takers on a new spot market
   *
   * @generated from field: string default_spot_taker_fee_rate = 4;
   */
  defaultSpotTakerFeeRate = "";

  /**
   * default_derivative_maker_fee defines the default exchange trade fee for
   * makers on a new derivative market
   *
   * @generated from field: string default_derivative_maker_fee_rate = 5;
   */
  defaultDerivativeMakerFeeRate = "";

  /**
   * default_derivative_taker_fee defines the default exchange trade fee for
   * takers on a new derivative market
   *
   * @generated from field: string default_derivative_taker_fee_rate = 6;
   */
  defaultDerivativeTakerFeeRate = "";

  /**
   * default_initial_margin_ratio defines the default initial margin ratio on a
   * new derivative market
   *
   * @generated from field: string default_initial_margin_ratio = 7;
   */
  defaultInitialMarginRatio = "";

  /**
   * default_maintenance_margin_ratio defines the default maintenance margin
   * ratio on a new derivative market
   *
   * @generated from field: string default_maintenance_margin_ratio = 8;
   */
  defaultMaintenanceMarginRatio = "";

  /**
   * default_funding_interval defines the default funding interval on a
   * derivative market
   *
   * @generated from field: int64 default_funding_interval = 9;
   */
  defaultFundingInterval = protoInt64.zero;

  /**
   * funding_multiple defines the timestamp multiple that the funding timestamp
   * should be a multiple of
   *
   * @generated from field: int64 funding_multiple = 10;
   */
  fundingMultiple = protoInt64.zero;

  /**
   * relayer_fee_share_rate defines the trade fee share percentage that goes to
   * relayers
   *
   * @generated from field: string relayer_fee_share_rate = 11;
   */
  relayerFeeShareRate = "";

  /**
   * default_hourly_funding_rate_cap defines the default maximum absolute value
   * of the hourly funding rate
   *
   * @generated from field: string default_hourly_funding_rate_cap = 12;
   */
  defaultHourlyFundingRateCap = "";

  /**
   * hourly_interest_rate defines the hourly interest rate
   *
   * @generated from field: string default_hourly_interest_rate = 13;
   */
  defaultHourlyInterestRate = "";

  /**
   * max_derivative_order_side_count defines the maximum number of derivative
   * active orders a subaccount can have for a given orderbook side
   *
   * @generated from field: uint32 max_derivative_order_side_count = 14;
   */
  maxDerivativeOrderSideCount = 0;

  /**
   * inj_reward_staked_requirement_threshold defines the threshold on INJ
   * rewards after which one also needs staked INJ to receive more
   *
   * @generated from field: string inj_reward_staked_requirement_threshold = 15;
   */
  injRewardStakedRequirementThreshold = "";

  /**
   * the trading_rewards_vesting_duration defines the vesting times for trading
   * rewards
   *
   * @generated from field: int64 trading_rewards_vesting_duration = 16;
   */
  tradingRewardsVestingDuration = protoInt64.zero;

  /**
   * liquidator_reward_share_rate defines the ratio of the split of the surplus
   * collateral that goes to the liquidator
   *
   * @generated from field: string liquidator_reward_share_rate = 17;
   */
  liquidatorRewardShareRate = "";

  /**
   * binary_options_market_instant_listing_fee defines the expedited fee in INJ
   * required to create a derivative market by bypassing governance
   *
   * @generated from field: cosmos.base.v1beta1.Coin binary_options_market_instant_listing_fee = 18;
   */
  binaryOptionsMarketInstantListingFee?: Coin;

  /**
   * atomic_market_order_access_level defines the required access permissions
   * for executing atomic market orders
   *
   * @generated from field: injective.exchange.v2.AtomicMarketOrderAccessLevel atomic_market_order_access_level = 19;
   */
  atomicMarketOrderAccessLevel = AtomicMarketOrderAccessLevel.Nobody;

  /**
   * spot_atomic_market_order_fee_multiplier defines the default multiplier for
   * executing atomic market orders in spot markets
   *
   * @generated from field: string spot_atomic_market_order_fee_multiplier = 20;
   */
  spotAtomicMarketOrderFeeMultiplier = "";

  /**
   * derivative_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in derivative markets
   *
   * @generated from field: string derivative_atomic_market_order_fee_multiplier = 21;
   */
  derivativeAtomicMarketOrderFeeMultiplier = "";

  /**
   * binary_options_atomic_market_order_fee_multiplier defines the default
   * multiplier for executing atomic market orders in binary markets
   *
   * @generated from field: string binary_options_atomic_market_order_fee_multiplier = 22;
   */
  binaryOptionsAtomicMarketOrderFeeMultiplier = "";

  /**
   * minimal_protocol_fee_rate defines the minimal protocol fee rate
   *
   * @generated from field: string minimal_protocol_fee_rate = 23;
   */
  minimalProtocolFeeRate = "";

  /**
   * is_instant_derivative_market_launch_enabled defines whether instant
   * derivative market launch is enabled
   *
   * @generated from field: bool is_instant_derivative_market_launch_enabled = 24;
   */
  isInstantDerivativeMarketLaunchEnabled = false;

  /**
   * @generated from field: int64 post_only_mode_height_threshold = 25;
   */
  postOnlyModeHeightThreshold = protoInt64.zero;

  /**
   * Maximum time in seconds since the last mark price update to allow a
   * decrease in margin
   *
   * @generated from field: int64 margin_decrease_price_timestamp_threshold_seconds = 26;
   */
  marginDecreasePriceTimestampThresholdSeconds = protoInt64.zero;

  /**
   * List of addresses that are allowed to perform exchange admin operations
   *
   * @generated from field: repeated string exchange_admins = 27;
   */
  exchangeAdmins: string[] = [];

  /**
   * inj_auction_max_cap defines the maximum cap for INJ sent to auction
   *
   * @generated from field: string inj_auction_max_cap = 28;
   */
  injAuctionMaxCap = "";

  /**
   * fixed_gas_enabled indicates if msg server will consume fixed gas amount for
   * certain msg types
   *
   * @generated from field: bool fixed_gas_enabled = 29;
   */
  fixedGasEnabled = false;

  /**
   * emit_legacy_version_events indicates if events of legacy version types
   * should be emitted in parallel to the new version events
   *
   * @generated from field: bool emit_legacy_version_events = 30;
   */
  emitLegacyVersionEvents = false;

  /**
   * default_reduce_margin_ratio defines the default reduce margin ratio on a
   * new derivative market
   *
   * @generated from field: string default_reduce_margin_ratio = 31;
   */
  defaultReduceMarginRatio = "";

  /**
   * human_readable_upgrade_block_height defines the block height at which the
   * human readable upgrade took place
   *
   * @generated from field: int64 human_readable_upgrade_block_height = 32;
   */
  humanReadableUpgradeBlockHeight = protoInt64.zero;

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "spot_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 2, name: "derivative_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 3, name: "default_spot_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "default_spot_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "default_derivative_maker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "default_derivative_taker_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "default_initial_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "default_maintenance_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "default_funding_interval", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "funding_multiple", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "relayer_fee_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "default_hourly_funding_rate_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "default_hourly_interest_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "max_derivative_order_side_count", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 15, name: "inj_reward_staked_requirement_threshold", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 16, name: "trading_rewards_vesting_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 17, name: "liquidator_reward_share_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 18, name: "binary_options_market_instant_listing_fee", kind: "message", T: Coin },
    { no: 19, name: "atomic_market_order_access_level", kind: "enum", T: proto3.getEnumType(AtomicMarketOrderAccessLevel) },
    { no: 20, name: "spot_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 21, name: "derivative_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 22, name: "binary_options_atomic_market_order_fee_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 23, name: "minimal_protocol_fee_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 24, name: "is_instant_derivative_market_launch_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 25, name: "post_only_mode_height_threshold", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 26, name: "margin_decrease_price_timestamp_threshold_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 27, name: "exchange_admins", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 28, name: "inj_auction_max_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 29, name: "fixed_gas_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 30, name: "emit_legacy_version_events", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 31, name: "default_reduce_margin_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 32, name: "human_readable_upgrade_block_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.NextFundingTimestamp
 */
export class NextFundingTimestamp extends Message<NextFundingTimestamp> {
  /**
   * @generated from field: int64 next_timestamp = 1;
   */
  nextTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<NextFundingTimestamp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.NextFundingTimestamp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NextFundingTimestamp {
    return new NextFundingTimestamp().fromJsonString(jsonString, options);
  }

  static equals(a: NextFundingTimestamp | PlainMessage<NextFundingTimestamp> | undefined, b: NextFundingTimestamp | PlainMessage<NextFundingTimestamp> | undefined): boolean {
    return proto3.util.equals(NextFundingTimestamp, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.MidPriceAndTOB
 */
export class MidPriceAndTOB extends Message<MidPriceAndTOB> {
  /**
   * mid price of the market (in human readable format)
   *
   * @generated from field: string mid_price = 1;
   */
  midPrice = "";

  /**
   * best buy price of the market (in human readable format)
   *
   * @generated from field: string best_buy_price = 2;
   */
  bestBuyPrice = "";

  /**
   * best sell price of the market (in human readable format)
   *
   * @generated from field: string best_sell_price = 3;
   */
  bestSellPrice = "";

  constructor(data?: PartialMessage<MidPriceAndTOB>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.MidPriceAndTOB";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mid_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "best_buy_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "best_sell_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MidPriceAndTOB {
    return new MidPriceAndTOB().fromJsonString(jsonString, options);
  }

  static equals(a: MidPriceAndTOB | PlainMessage<MidPriceAndTOB> | undefined, b: MidPriceAndTOB | PlainMessage<MidPriceAndTOB> | undefined): boolean {
    return proto3.util.equals(MidPriceAndTOB, a, b);
  }
}

/**
 * A subaccount's deposit for a given base currency
 *
 * @generated from message injective.exchange.v2.Deposit
 */
export class Deposit extends Message<Deposit> {
  /**
   * the available balance (in chain format)
   *
   * @generated from field: string available_balance = 1;
   */
  availableBalance = "";

  /**
   * the total balance (in chain format)
   *
   * @generated from field: string total_balance = 2;
   */
  totalBalance = "";

  constructor(data?: PartialMessage<Deposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Deposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "available_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "total_balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Deposit {
    return new Deposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Deposit {
    return new Deposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Deposit {
    return new Deposit().fromJsonString(jsonString, options);
  }

  static equals(a: Deposit | PlainMessage<Deposit> | undefined, b: Deposit | PlainMessage<Deposit> | undefined): boolean {
    return proto3.util.equals(Deposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountTradeNonce
 */
export class SubaccountTradeNonce extends Message<SubaccountTradeNonce> {
  /**
   * @generated from field: uint32 nonce = 1;
   */
  nonce = 0;

  constructor(data?: PartialMessage<SubaccountTradeNonce>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountTradeNonce";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountTradeNonce {
    return new SubaccountTradeNonce().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountTradeNonce | PlainMessage<SubaccountTradeNonce> | undefined, b: SubaccountTradeNonce | PlainMessage<SubaccountTradeNonce> | undefined): boolean {
    return proto3.util.equals(SubaccountTradeNonce, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountOrder
 */
export class SubaccountOrder extends Message<SubaccountOrder> {
  /**
   * price of the order
   *
   * @generated from field: string price = 1;
   */
  price = "";

  /**
   * the amount of the quantity remaining fillable
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * @generated from field: bool isReduceOnly = 3;
   */
  isReduceOnly = false;

  /**
   * @generated from field: string cid = 4;
   */
  cid = "";

  constructor(data?: PartialMessage<SubaccountOrder>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountOrder";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "isReduceOnly", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrder {
    return new SubaccountOrder().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrder | PlainMessage<SubaccountOrder> | undefined, b: SubaccountOrder | PlainMessage<SubaccountOrder> | undefined): boolean {
    return proto3.util.equals(SubaccountOrder, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountOrderData
 */
export class SubaccountOrderData extends Message<SubaccountOrderData> {
  /**
   * @generated from field: injective.exchange.v2.SubaccountOrder order = 1;
   */
  order?: SubaccountOrder;

  /**
   * @generated from field: bytes order_hash = 2;
   */
  orderHash = new Uint8Array(0);

  constructor(data?: PartialMessage<SubaccountOrderData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountOrderData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "order", kind: "message", T: SubaccountOrder },
    { no: 2, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountOrderData {
    return new SubaccountOrderData().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountOrderData | PlainMessage<SubaccountOrderData> | undefined, b: SubaccountOrderData | PlainMessage<SubaccountOrderData> | undefined): boolean {
    return proto3.util.equals(SubaccountOrderData, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.Position
 */
export class Position extends Message<Position> {
  /**
   * True if the position is long. False if the position is short.
   *
   * @generated from field: bool isLong = 1;
   */
  isLong = false;

  /**
   * The quantity of the position (in human readable format)
   *
   * @generated from field: string quantity = 2;
   */
  quantity = "";

  /**
   * The entry price of the position (in human readable format)
   *
   * @generated from field: string entry_price = 3;
   */
  entryPrice = "";

  /**
   * The margin of the position (in human readable format)
   *
   * @generated from field: string margin = 4;
   */
  margin = "";

  /**
   * The cumulative funding
   *
   * @generated from field: string cumulative_funding_entry = 5;
   */
  cumulativeFundingEntry = "";

  constructor(data?: PartialMessage<Position>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Position";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "isLong", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "entry_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "cumulative_funding_entry", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJsonString(jsonString, options);
  }

  static equals(a: Position | PlainMessage<Position> | undefined, b: Position | PlainMessage<Position> | undefined): boolean {
    return proto3.util.equals(Position, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.Balance
 */
export class Balance extends Message<Balance> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the denom of the balance
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * the token deposits details
   *
   * @generated from field: injective.exchange.v2.Deposit deposits = 3;
   */
  deposits?: Deposit;

  constructor(data?: PartialMessage<Balance>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Balance";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "deposits", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Balance {
    return new Balance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Balance {
    return new Balance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Balance {
    return new Balance().fromJsonString(jsonString, options);
  }

  static equals(a: Balance | PlainMessage<Balance> | undefined, b: Balance | PlainMessage<Balance> | undefined): boolean {
    return proto3.util.equals(Balance, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativePosition
 */
export class DerivativePosition extends Message<DerivativePosition> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the market ID
   *
   * @generated from field: string market_id = 2;
   */
  marketId = "";

  /**
   * the position details
   *
   * @generated from field: injective.exchange.v2.Position position = 3;
   */
  position?: Position;

  constructor(data?: PartialMessage<DerivativePosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativePosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "position", kind: "message", T: Position },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativePosition {
    return new DerivativePosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativePosition {
    return new DerivativePosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativePosition {
    return new DerivativePosition().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativePosition | PlainMessage<DerivativePosition> | undefined, b: DerivativePosition | PlainMessage<DerivativePosition> | undefined): boolean {
    return proto3.util.equals(DerivativePosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.MarketOrderIndicator
 */
export class MarketOrderIndicator extends Message<MarketOrderIndicator> {
  /**
   * market_id represents the unique ID of the market
   *
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: bool isBuy = 2;
   */
  isBuy = false;

  constructor(data?: PartialMessage<MarketOrderIndicator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.MarketOrderIndicator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "isBuy", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MarketOrderIndicator {
    return new MarketOrderIndicator().fromJsonString(jsonString, options);
  }

  static equals(a: MarketOrderIndicator | PlainMessage<MarketOrderIndicator> | undefined, b: MarketOrderIndicator | PlainMessage<MarketOrderIndicator> | undefined): boolean {
    return proto3.util.equals(MarketOrderIndicator, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.TradeLog
 */
export class TradeLog extends Message<TradeLog> {
  /**
   * @generated from field: string quantity = 1;
   */
  quantity = "";

  /**
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * bytes32 subaccount ID that executed the trade
   *
   * @generated from field: bytes subaccount_id = 3;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: string fee = 4;
   */
  fee = "";

  /**
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes fee_recipient_address = 6;
   */
  feeRecipientAddress = new Uint8Array(0);

  /**
   * @generated from field: string cid = 7;
   */
  cid = "";

  constructor(data?: PartialMessage<TradeLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.TradeLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeLog {
    return new TradeLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeLog {
    return new TradeLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeLog {
    return new TradeLog().fromJsonString(jsonString, options);
  }

  static equals(a: TradeLog | PlainMessage<TradeLog> | undefined, b: TradeLog | PlainMessage<TradeLog> | undefined): boolean {
    return proto3.util.equals(TradeLog, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.PositionDelta
 */
export class PositionDelta extends Message<PositionDelta> {
  /**
   * @generated from field: bool is_long = 1;
   */
  isLong = false;

  /**
   * @generated from field: string execution_quantity = 2;
   */
  executionQuantity = "";

  /**
   * @generated from field: string execution_margin = 3;
   */
  executionMargin = "";

  /**
   * @generated from field: string execution_price = 4;
   */
  executionPrice = "";

  constructor(data?: PartialMessage<PositionDelta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.PositionDelta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_long", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "execution_quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "execution_margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "execution_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PositionDelta {
    return new PositionDelta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PositionDelta {
    return new PositionDelta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PositionDelta {
    return new PositionDelta().fromJsonString(jsonString, options);
  }

  static equals(a: PositionDelta | PlainMessage<PositionDelta> | undefined, b: PositionDelta | PlainMessage<PositionDelta> | undefined): boolean {
    return proto3.util.equals(PositionDelta, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DerivativeTradeLog
 */
export class DerivativeTradeLog extends Message<DerivativeTradeLog> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: injective.exchange.v2.PositionDelta position_delta = 2;
   */
  positionDelta?: PositionDelta;

  /**
   * @generated from field: string payout = 3;
   */
  payout = "";

  /**
   * @generated from field: string fee = 4;
   */
  fee = "";

  /**
   * @generated from field: bytes order_hash = 5;
   */
  orderHash = new Uint8Array(0);

  /**
   * @generated from field: bytes fee_recipient_address = 6;
   */
  feeRecipientAddress = new Uint8Array(0);

  /**
   * @generated from field: string cid = 7;
   */
  cid = "";

  /**
   * @generated from field: string pnl = 8;
   */
  pnl = "";

  constructor(data?: PartialMessage<DerivativeTradeLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DerivativeTradeLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "position_delta", kind: "message", T: PositionDelta },
    { no: 3, name: "payout", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "order_hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "fee_recipient_address", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "cid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "pnl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DerivativeTradeLog {
    return new DerivativeTradeLog().fromJsonString(jsonString, options);
  }

  static equals(a: DerivativeTradeLog | PlainMessage<DerivativeTradeLog> | undefined, b: DerivativeTradeLog | PlainMessage<DerivativeTradeLog> | undefined): boolean {
    return proto3.util.equals(DerivativeTradeLog, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountPosition
 */
export class SubaccountPosition extends Message<SubaccountPosition> {
  /**
   * @generated from field: injective.exchange.v2.Position position = 1;
   */
  position?: Position;

  /**
   * @generated from field: bytes subaccount_id = 2;
   */
  subaccountId = new Uint8Array(0);

  constructor(data?: PartialMessage<SubaccountPosition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountPosition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "position", kind: "message", T: Position },
    { no: 2, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountPosition {
    return new SubaccountPosition().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountPosition | PlainMessage<SubaccountPosition> | undefined, b: SubaccountPosition | PlainMessage<SubaccountPosition> | undefined): boolean {
    return proto3.util.equals(SubaccountPosition, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountDeposit
 */
export class SubaccountDeposit extends Message<SubaccountDeposit> {
  /**
   * @generated from field: bytes subaccount_id = 1;
   */
  subaccountId = new Uint8Array(0);

  /**
   * @generated from field: injective.exchange.v2.Deposit deposit = 2;
   */
  deposit?: Deposit;

  constructor(data?: PartialMessage<SubaccountDeposit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountDeposit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "deposit", kind: "message", T: Deposit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountDeposit {
    return new SubaccountDeposit().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined, b: SubaccountDeposit | PlainMessage<SubaccountDeposit> | undefined): boolean {
    return proto3.util.equals(SubaccountDeposit, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DepositUpdate
 */
export class DepositUpdate extends Message<DepositUpdate> {
  /**
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * @generated from field: repeated injective.exchange.v2.SubaccountDeposit deposits = 2;
   */
  deposits: SubaccountDeposit[] = [];

  constructor(data?: PartialMessage<DepositUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DepositUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "deposits", kind: "message", T: SubaccountDeposit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DepositUpdate {
    return new DepositUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DepositUpdate {
    return new DepositUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DepositUpdate {
    return new DepositUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: DepositUpdate | PlainMessage<DepositUpdate> | undefined, b: DepositUpdate | PlainMessage<DepositUpdate> | undefined): boolean {
    return proto3.util.equals(DepositUpdate, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.PointsMultiplier
 */
export class PointsMultiplier extends Message<PointsMultiplier> {
  /**
   * @generated from field: string maker_points_multiplier = 1;
   */
  makerPointsMultiplier = "";

  /**
   * @generated from field: string taker_points_multiplier = 2;
   */
  takerPointsMultiplier = "";

  constructor(data?: PartialMessage<PointsMultiplier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.PointsMultiplier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_points_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PointsMultiplier {
    return new PointsMultiplier().fromJsonString(jsonString, options);
  }

  static equals(a: PointsMultiplier | PlainMessage<PointsMultiplier> | undefined, b: PointsMultiplier | PlainMessage<PointsMultiplier> | undefined): boolean {
    return proto3.util.equals(PointsMultiplier, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.TradingRewardCampaignBoostInfo
 */
export class TradingRewardCampaignBoostInfo extends Message<TradingRewardCampaignBoostInfo> {
  /**
   * @generated from field: repeated string boosted_spot_market_ids = 1;
   */
  boostedSpotMarketIds: string[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.PointsMultiplier spot_market_multipliers = 2;
   */
  spotMarketMultipliers: PointsMultiplier[] = [];

  /**
   * @generated from field: repeated string boosted_derivative_market_ids = 3;
   */
  boostedDerivativeMarketIds: string[] = [];

  /**
   * @generated from field: repeated injective.exchange.v2.PointsMultiplier derivative_market_multipliers = 4;
   */
  derivativeMarketMultipliers: PointsMultiplier[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignBoostInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.TradingRewardCampaignBoostInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "boosted_spot_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "spot_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
    { no: 3, name: "boosted_derivative_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "derivative_market_multipliers", kind: "message", T: PointsMultiplier, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignBoostInfo {
    return new TradingRewardCampaignBoostInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignBoostInfo | PlainMessage<TradingRewardCampaignBoostInfo> | undefined, b: TradingRewardCampaignBoostInfo | PlainMessage<TradingRewardCampaignBoostInfo> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignBoostInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.CampaignRewardPool
 */
export class CampaignRewardPool extends Message<CampaignRewardPool> {
  /**
   * the campaign start timestamp in seconds
   *
   * @generated from field: int64 start_timestamp = 1;
   */
  startTimestamp = protoInt64.zero;

  /**
   * max_campaign_rewards are the maximum reward amounts to be disbursed at the
   * end of the campaign
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin max_campaign_rewards = 2;
   */
  maxCampaignRewards: Coin[] = [];

  constructor(data?: PartialMessage<CampaignRewardPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.CampaignRewardPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "max_campaign_rewards", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CampaignRewardPool {
    return new CampaignRewardPool().fromJsonString(jsonString, options);
  }

  static equals(a: CampaignRewardPool | PlainMessage<CampaignRewardPool> | undefined, b: CampaignRewardPool | PlainMessage<CampaignRewardPool> | undefined): boolean {
    return proto3.util.equals(CampaignRewardPool, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.TradingRewardCampaignInfo
 */
export class TradingRewardCampaignInfo extends Message<TradingRewardCampaignInfo> {
  /**
   * number of seconds of the duration of each campaign
   *
   * @generated from field: int64 campaign_duration_seconds = 1;
   */
  campaignDurationSeconds = protoInt64.zero;

  /**
   * the trading fee quote denoms which will be counted for the rewards
   *
   * @generated from field: repeated string quote_denoms = 2;
   */
  quoteDenoms: string[] = [];

  /**
   * the optional boost info for markets
   *
   * @generated from field: injective.exchange.v2.TradingRewardCampaignBoostInfo trading_reward_boost_info = 3;
   */
  tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo;

  /**
   * the marketIDs which are disqualified from being rewarded
   *
   * @generated from field: repeated string disqualified_market_ids = 4;
   */
  disqualifiedMarketIds: string[] = [];

  constructor(data?: PartialMessage<TradingRewardCampaignInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.TradingRewardCampaignInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "campaign_duration_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "trading_reward_boost_info", kind: "message", T: TradingRewardCampaignBoostInfo },
    { no: 4, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradingRewardCampaignInfo {
    return new TradingRewardCampaignInfo().fromJsonString(jsonString, options);
  }

  static equals(a: TradingRewardCampaignInfo | PlainMessage<TradingRewardCampaignInfo> | undefined, b: TradingRewardCampaignInfo | PlainMessage<TradingRewardCampaignInfo> | undefined): boolean {
    return proto3.util.equals(TradingRewardCampaignInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.FeeDiscountTierInfo
 */
export class FeeDiscountTierInfo extends Message<FeeDiscountTierInfo> {
  /**
   * the maker discount rate
   *
   * @generated from field: string maker_discount_rate = 1;
   */
  makerDiscountRate = "";

  /**
   * the taker discount rate
   *
   * @generated from field: string taker_discount_rate = 2;
   */
  takerDiscountRate = "";

  /**
   * the staked amount required to qualify for the discount (in chain format)
   *
   * @generated from field: string staked_amount = 3;
   */
  stakedAmount = "";

  /**
   * the volume required to qualify for the discount (in human readable format)
   *
   * @generated from field: string volume = 4;
   */
  volume = "";

  constructor(data?: PartialMessage<FeeDiscountTierInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.FeeDiscountTierInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "taker_discount_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "staked_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "volume", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountTierInfo {
    return new FeeDiscountTierInfo().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountTierInfo | PlainMessage<FeeDiscountTierInfo> | undefined, b: FeeDiscountTierInfo | PlainMessage<FeeDiscountTierInfo> | undefined): boolean {
    return proto3.util.equals(FeeDiscountTierInfo, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.FeeDiscountSchedule
 */
export class FeeDiscountSchedule extends Message<FeeDiscountSchedule> {
  /**
   * the bucket number
   *
   * @generated from field: uint64 bucket_count = 1;
   */
  bucketCount = protoInt64.zero;

  /**
   * the bucket duration in seconds
   *
   * @generated from field: int64 bucket_duration = 2;
   */
  bucketDuration = protoInt64.zero;

  /**
   * the trading fee quote denoms which will be counted for the fee paid
   * contribution
   *
   * @generated from field: repeated string quote_denoms = 3;
   */
  quoteDenoms: string[] = [];

  /**
   * the fee discount tiers
   *
   * @generated from field: repeated injective.exchange.v2.FeeDiscountTierInfo tier_infos = 4;
   */
  tierInfos: FeeDiscountTierInfo[] = [];

  /**
   * the marketIDs which are disqualified from contributing to the fee paid
   * amount
   *
   * @generated from field: repeated string disqualified_market_ids = 5;
   */
  disqualifiedMarketIds: string[] = [];

  constructor(data?: PartialMessage<FeeDiscountSchedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.FeeDiscountSchedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "bucket_duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "quote_denoms", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "tier_infos", kind: "message", T: FeeDiscountTierInfo, repeated: true },
    { no: 5, name: "disqualified_market_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountSchedule {
    return new FeeDiscountSchedule().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountSchedule | PlainMessage<FeeDiscountSchedule> | undefined, b: FeeDiscountSchedule | PlainMessage<FeeDiscountSchedule> | undefined): boolean {
    return proto3.util.equals(FeeDiscountSchedule, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.FeeDiscountTierTTL
 */
export class FeeDiscountTierTTL extends Message<FeeDiscountTierTTL> {
  /**
   * the tier number
   *
   * @generated from field: uint64 tier = 1;
   */
  tier = protoInt64.zero;

  /**
   * the TTL timestamp in seconds
   *
   * @generated from field: int64 ttl_timestamp = 2;
   */
  ttlTimestamp = protoInt64.zero;

  constructor(data?: PartialMessage<FeeDiscountTierTTL>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.FeeDiscountTierTTL";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "ttl_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeeDiscountTierTTL {
    return new FeeDiscountTierTTL().fromJsonString(jsonString, options);
  }

  static equals(a: FeeDiscountTierTTL | PlainMessage<FeeDiscountTierTTL> | undefined, b: FeeDiscountTierTTL | PlainMessage<FeeDiscountTierTTL> | undefined): boolean {
    return proto3.util.equals(FeeDiscountTierTTL, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.AccountRewards
 */
export class AccountRewards extends Message<AccountRewards> {
  /**
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * @generated from field: repeated cosmos.base.v1beta1.Coin rewards = 2;
   */
  rewards: Coin[] = [];

  constructor(data?: PartialMessage<AccountRewards>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.AccountRewards";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rewards", kind: "message", T: Coin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccountRewards {
    return new AccountRewards().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccountRewards {
    return new AccountRewards().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccountRewards {
    return new AccountRewards().fromJsonString(jsonString, options);
  }

  static equals(a: AccountRewards | PlainMessage<AccountRewards> | undefined, b: AccountRewards | PlainMessage<AccountRewards> | undefined): boolean {
    return proto3.util.equals(AccountRewards, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.TradeRecords
 */
export class TradeRecords extends Message<TradeRecords> {
  /**
   * @generated from field: string market_id = 1;
   */
  marketId = "";

  /**
   * @generated from field: repeated injective.exchange.v2.TradeRecord latest_trade_records = 2;
   */
  latestTradeRecords: TradeRecord[] = [];

  constructor(data?: PartialMessage<TradeRecords>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.TradeRecords";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "market_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "latest_trade_records", kind: "message", T: TradeRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeRecords {
    return new TradeRecords().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeRecords {
    return new TradeRecords().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeRecords {
    return new TradeRecords().fromJsonString(jsonString, options);
  }

  static equals(a: TradeRecords | PlainMessage<TradeRecords> | undefined, b: TradeRecords | PlainMessage<TradeRecords> | undefined): boolean {
    return proto3.util.equals(TradeRecords, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.SubaccountIDs
 */
export class SubaccountIDs extends Message<SubaccountIDs> {
  /**
   * @generated from field: repeated bytes subaccount_ids = 1;
   */
  subaccountIds: Uint8Array[] = [];

  constructor(data?: PartialMessage<SubaccountIDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.SubaccountIDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_ids", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubaccountIDs {
    return new SubaccountIDs().fromJsonString(jsonString, options);
  }

  static equals(a: SubaccountIDs | PlainMessage<SubaccountIDs> | undefined, b: SubaccountIDs | PlainMessage<SubaccountIDs> | undefined): boolean {
    return proto3.util.equals(SubaccountIDs, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.TradeRecord
 */
export class TradeRecord extends Message<TradeRecord> {
  /**
   * the timestamp of the trade
   *
   * @generated from field: int64 timestamp = 1;
   */
  timestamp = protoInt64.zero;

  /**
   * the price of the trade (in human readable format)
   *
   * @generated from field: string price = 2;
   */
  price = "";

  /**
   * the quantity of the trade (in human readable format)
   *
   * @generated from field: string quantity = 3;
   */
  quantity = "";

  constructor(data?: PartialMessage<TradeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.TradeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quantity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TradeRecord {
    return new TradeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TradeRecord {
    return new TradeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TradeRecord {
    return new TradeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: TradeRecord | PlainMessage<TradeRecord> | undefined, b: TradeRecord | PlainMessage<TradeRecord> | undefined): boolean {
    return proto3.util.equals(TradeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.Level
 */
export class Level extends Message<Level> {
  /**
   * price (in human readable format)
   *
   * @generated from field: string p = 1;
   */
  p = "";

  /**
   * quantity (in human readable format)
   *
   * @generated from field: string q = 2;
   */
  q = "";

  constructor(data?: PartialMessage<Level>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.Level";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "p", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "q", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Level {
    return new Level().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Level {
    return new Level().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Level {
    return new Level().fromJsonString(jsonString, options);
  }

  static equals(a: Level | PlainMessage<Level> | undefined, b: Level | PlainMessage<Level> | undefined): boolean {
    return proto3.util.equals(Level, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.AggregateSubaccountVolumeRecord
 */
export class AggregateSubaccountVolumeRecord extends Message<AggregateSubaccountVolumeRecord> {
  /**
   * the subaccount ID
   *
   * @generated from field: string subaccount_id = 1;
   */
  subaccountId = "";

  /**
   * the subaccount volumes for each market
   *
   * @generated from field: repeated injective.exchange.v2.MarketVolume market_volumes = 2;
   */
  marketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<AggregateSubaccountVolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.AggregateSubaccountVolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subaccount_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateSubaccountVolumeRecord {
    return new AggregateSubaccountVolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateSubaccountVolumeRecord | PlainMessage<AggregateSubaccountVolumeRecord> | undefined, b: AggregateSubaccountVolumeRecord | PlainMessage<AggregateSubaccountVolumeRecord> | undefined): boolean {
    return proto3.util.equals(AggregateSubaccountVolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.AggregateAccountVolumeRecord
 */
export class AggregateAccountVolumeRecord extends Message<AggregateAccountVolumeRecord> {
  /**
   * account the volume belongs to
   *
   * @generated from field: string account = 1;
   */
  account = "";

  /**
   * the aggregate volumes for each market
   *
   * @generated from field: repeated injective.exchange.v2.MarketVolume market_volumes = 2;
   */
  marketVolumes: MarketVolume[] = [];

  constructor(data?: PartialMessage<AggregateAccountVolumeRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.AggregateAccountVolumeRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "market_volumes", kind: "message", T: MarketVolume, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateAccountVolumeRecord {
    return new AggregateAccountVolumeRecord().fromJsonString(jsonString, options);
  }

  static equals(a: AggregateAccountVolumeRecord | PlainMessage<AggregateAccountVolumeRecord> | undefined, b: AggregateAccountVolumeRecord | PlainMessage<AggregateAccountVolumeRecord> | undefined): boolean {
    return proto3.util.equals(AggregateAccountVolumeRecord, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DenomDecimals
 */
export class DenomDecimals extends Message<DenomDecimals> {
  /**
   * the denom of the token
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * the decimals of the token
   *
   * @generated from field: uint64 decimals = 2;
   */
  decimals = protoInt64.zero;

  constructor(data?: PartialMessage<DenomDecimals>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DenomDecimals";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "decimals", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomDecimals {
    return new DenomDecimals().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomDecimals {
    return new DenomDecimals().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomDecimals {
    return new DenomDecimals().fromJsonString(jsonString, options);
  }

  static equals(a: DenomDecimals | PlainMessage<DenomDecimals> | undefined, b: DenomDecimals | PlainMessage<DenomDecimals> | undefined): boolean {
    return proto3.util.equals(DenomDecimals, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.GrantAuthorization
 */
export class GrantAuthorization extends Message<GrantAuthorization> {
  /**
   * the grantee address
   *
   * @generated from field: string grantee = 1;
   */
  grantee = "";

  /**
   * the amount of stake granted (INJ in chain format)
   *
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<GrantAuthorization>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.GrantAuthorization";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GrantAuthorization {
    return new GrantAuthorization().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GrantAuthorization {
    return new GrantAuthorization().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GrantAuthorization {
    return new GrantAuthorization().fromJsonString(jsonString, options);
  }

  static equals(a: GrantAuthorization | PlainMessage<GrantAuthorization> | undefined, b: GrantAuthorization | PlainMessage<GrantAuthorization> | undefined): boolean {
    return proto3.util.equals(GrantAuthorization, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.ActiveGrant
 */
export class ActiveGrant extends Message<ActiveGrant> {
  /**
   * @generated from field: string granter = 1;
   */
  granter = "";

  /**
   * @generated from field: string amount = 2;
   */
  amount = "";

  constructor(data?: PartialMessage<ActiveGrant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.ActiveGrant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActiveGrant {
    return new ActiveGrant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActiveGrant {
    return new ActiveGrant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActiveGrant {
    return new ActiveGrant().fromJsonString(jsonString, options);
  }

  static equals(a: ActiveGrant | PlainMessage<ActiveGrant> | undefined, b: ActiveGrant | PlainMessage<ActiveGrant> | undefined): boolean {
    return proto3.util.equals(ActiveGrant, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.EffectiveGrant
 */
export class EffectiveGrant extends Message<EffectiveGrant> {
  /**
   * @generated from field: string granter = 1;
   */
  granter = "";

  /**
   * @generated from field: string net_granted_stake = 2;
   */
  netGrantedStake = "";

  /**
   * @generated from field: bool is_valid = 3;
   */
  isValid = false;

  constructor(data?: PartialMessage<EffectiveGrant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.EffectiveGrant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "granter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "net_granted_stake", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EffectiveGrant {
    return new EffectiveGrant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EffectiveGrant {
    return new EffectiveGrant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EffectiveGrant {
    return new EffectiveGrant().fromJsonString(jsonString, options);
  }

  static equals(a: EffectiveGrant | PlainMessage<EffectiveGrant> | undefined, b: EffectiveGrant | PlainMessage<EffectiveGrant> | undefined): boolean {
    return proto3.util.equals(EffectiveGrant, a, b);
  }
}

/**
 * @generated from message injective.exchange.v2.DenomMinNotional
 */
export class DenomMinNotional extends Message<DenomMinNotional> {
  /**
   * the denom of the token
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * the minimum notional value for the token (in human readable format)
   *
   * @generated from field: string min_notional = 2;
   */
  minNotional = "";

  constructor(data?: PartialMessage<DenomMinNotional>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.exchange.v2.DenomMinNotional";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "min_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenomMinNotional {
    return new DenomMinNotional().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenomMinNotional {
    return new DenomMinNotional().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenomMinNotional {
    return new DenomMinNotional().fromJsonString(jsonString, options);
  }

  static equals(a: DenomMinNotional | PlainMessage<DenomMinNotional> | undefined, b: DenomMinNotional | PlainMessage<DenomMinNotional> | undefined): boolean {
    return proto3.util.equals(DenomMinNotional, a, b);
  }
}

