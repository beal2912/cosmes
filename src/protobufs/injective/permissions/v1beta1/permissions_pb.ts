// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/permissions/v1beta1/permissions.proto (package injective.permissions.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * each Action enum value should be a power of two
 *
 * @generated from enum injective.permissions.v1beta1.Action
 */
export enum Action {
  /**
   * 0 is reserved for ACTION_UNSPECIFIED
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * 1 is reserved for MINT
   *
   * @generated from enum value: MINT = 1;
   */
  MINT = 1,

  /**
   * 2 is reserved for RECEIVE
   *
   * @generated from enum value: RECEIVE = 2;
   */
  RECEIVE = 2,

  /**
   * 4 is reserved for BURN
   *
   * @generated from enum value: BURN = 4;
   */
  BURN = 4,

  /**
   * 8 is reserved for SEND
   *
   * @generated from enum value: SEND = 8;
   */
  SEND = 8,

  /**
   * 16 is reserved for SUPER_BURN
   *
   * @generated from enum value: SUPER_BURN = 16;
   */
  SUPER_BURN = 16,

  /**
   * 2^27 is reserved for MODIFY_POLICY_MANAGERS
   *
   * 2^27 or 134217728
   *
   * @generated from enum value: MODIFY_POLICY_MANAGERS = 134217728;
   */
  MODIFY_POLICY_MANAGERS = 134217728,

  /**
   * 2^28 is reserved for MODIFY_CONTRACT_HOOK
   *
   * 2^28 or 268435456
   *
   * @generated from enum value: MODIFY_CONTRACT_HOOK = 268435456;
   */
  MODIFY_CONTRACT_HOOK = 268435456,

  /**
   * 2^29 is reserved for MODIFY_ROLE_PERMISSIONS
   *
   * 2^29 or 536870912
   *
   * @generated from enum value: MODIFY_ROLE_PERMISSIONS = 536870912;
   */
  MODIFY_ROLE_PERMISSIONS = 536870912,

  /**
   * 2^30 is reserved for MODIFY_ROLE_MANAGERS
   *
   * 2^30 or 1073741824
   *
   * @generated from enum value: MODIFY_ROLE_MANAGERS = 1073741824;
   */
  MODIFY_ROLE_MANAGERS = 1073741824,
}
// Retrieve enum metadata with: proto3.getEnumType(Action)
proto3.util.setEnumType(Action, "injective.permissions.v1beta1.Action", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "MINT" },
  { no: 2, name: "RECEIVE" },
  { no: 4, name: "BURN" },
  { no: 8, name: "SEND" },
  { no: 16, name: "SUPER_BURN" },
  { no: 134217728, name: "MODIFY_POLICY_MANAGERS" },
  { no: 268435456, name: "MODIFY_CONTRACT_HOOK" },
  { no: 536870912, name: "MODIFY_ROLE_PERMISSIONS" },
  { no: 1073741824, name: "MODIFY_ROLE_MANAGERS" },
]);

/**
 * Namespace defines a permissions namespace
 *
 * @generated from message injective.permissions.v1beta1.Namespace
 */
export class Namespace extends Message<Namespace> {
  /**
   * The tokenfactory denom to which this namespace applies to
   *
   * @generated from field: string denom = 1;
   */
  denom = "";

  /**
   * The address of smart contract to apply code-based restrictions
   *
   * @generated from field: string contract_hook = 2;
   */
  contractHook = "";

  /**
   * permissions for each role
   *
   * @generated from field: repeated injective.permissions.v1beta1.Role role_permissions = 3;
   */
  rolePermissions: Role[] = [];

  /**
   * roles for each actor
   *
   * @generated from field: repeated injective.permissions.v1beta1.ActorRoles actor_roles = 4;
   */
  actorRoles: ActorRoles[] = [];

  /**
   * managers for each role
   *
   * @generated from field: repeated injective.permissions.v1beta1.RoleManager role_managers = 5;
   */
  roleManagers: RoleManager[] = [];

  /**
   * status for each policy
   *
   * @generated from field: repeated injective.permissions.v1beta1.PolicyStatus policy_statuses = 6;
   */
  policyStatuses: PolicyStatus[] = [];

  /**
   * capabilities for each manager for each policy
   *
   * @generated from field: repeated injective.permissions.v1beta1.PolicyManagerCapability policy_manager_capabilities = 7;
   */
  policyManagerCapabilities: PolicyManagerCapability[] = [];

  constructor(data?: PartialMessage<Namespace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.Namespace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "contract_hook", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "role_permissions", kind: "message", T: Role, repeated: true },
    { no: 4, name: "actor_roles", kind: "message", T: ActorRoles, repeated: true },
    { no: 5, name: "role_managers", kind: "message", T: RoleManager, repeated: true },
    { no: 6, name: "policy_statuses", kind: "message", T: PolicyStatus, repeated: true },
    { no: 7, name: "policy_manager_capabilities", kind: "message", T: PolicyManagerCapability, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Namespace {
    return new Namespace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Namespace {
    return new Namespace().fromJsonString(jsonString, options);
  }

  static equals(a: Namespace | PlainMessage<Namespace> | undefined, b: Namespace | PlainMessage<Namespace> | undefined): boolean {
    return proto3.util.equals(Namespace, a, b);
  }
}

/**
 * AddressRoles defines roles for an actor
 *
 * @generated from message injective.permissions.v1beta1.ActorRoles
 */
export class ActorRoles extends Message<ActorRoles> {
  /**
   * The actor name
   *
   * @generated from field: string actor = 1;
   */
  actor = "";

  /**
   * The roles for the actor
   *
   * @generated from field: repeated string roles = 2;
   */
  roles: string[] = [];

  constructor(data?: PartialMessage<ActorRoles>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.ActorRoles";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "actor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActorRoles {
    return new ActorRoles().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActorRoles {
    return new ActorRoles().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActorRoles {
    return new ActorRoles().fromJsonString(jsonString, options);
  }

  static equals(a: ActorRoles | PlainMessage<ActorRoles> | undefined, b: ActorRoles | PlainMessage<ActorRoles> | undefined): boolean {
    return proto3.util.equals(ActorRoles, a, b);
  }
}

/**
 * RoleActors defines actors for a role
 *
 * @generated from message injective.permissions.v1beta1.RoleActors
 */
export class RoleActors extends Message<RoleActors> {
  /**
   * The role name
   *
   * @generated from field: string role = 1;
   */
  role = "";

  /**
   * List of actor names associated with the role
   *
   * @generated from field: repeated string actors = 2;
   */
  actors: string[] = [];

  constructor(data?: PartialMessage<RoleActors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.RoleActors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "actors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleActors {
    return new RoleActors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleActors {
    return new RoleActors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleActors {
    return new RoleActors().fromJsonString(jsonString, options);
  }

  static equals(a: RoleActors | PlainMessage<RoleActors> | undefined, b: RoleActors | PlainMessage<RoleActors> | undefined): boolean {
    return proto3.util.equals(RoleActors, a, b);
  }
}

/**
 * RoleManager defines roles for a manager address
 *
 * @generated from message injective.permissions.v1beta1.RoleManager
 */
export class RoleManager extends Message<RoleManager> {
  /**
   * The manager name
   *
   * @generated from field: string manager = 1;
   */
  manager = "";

  /**
   * List of roles associated with the manager
   *
   * @generated from field: repeated string roles = 2;
   */
  roles: string[] = [];

  constructor(data?: PartialMessage<RoleManager>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.RoleManager";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "roles", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleManager {
    return new RoleManager().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleManager {
    return new RoleManager().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleManager {
    return new RoleManager().fromJsonString(jsonString, options);
  }

  static equals(a: RoleManager | PlainMessage<RoleManager> | undefined, b: RoleManager | PlainMessage<RoleManager> | undefined): boolean {
    return proto3.util.equals(RoleManager, a, b);
  }
}

/**
 * PolicyStatus defines the status of a policy
 *
 * @generated from message injective.permissions.v1beta1.PolicyStatus
 */
export class PolicyStatus extends Message<PolicyStatus> {
  /**
   * The action code number
   *
   * @generated from field: injective.permissions.v1beta1.Action action = 1;
   */
  action = Action.UNSPECIFIED;

  /**
   * Whether the policy is disabled
   *
   * @generated from field: bool is_disabled = 2;
   */
  isDisabled = false;

  /**
   * Whether the policy is sealed
   *
   * @generated from field: bool is_sealed = 3;
   */
  isSealed = false;

  constructor(data?: PartialMessage<PolicyStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.PolicyStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "action", kind: "enum", T: proto3.getEnumType(Action) },
    { no: 2, name: "is_disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "is_sealed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PolicyStatus {
    return new PolicyStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PolicyStatus {
    return new PolicyStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PolicyStatus {
    return new PolicyStatus().fromJsonString(jsonString, options);
  }

  static equals(a: PolicyStatus | PlainMessage<PolicyStatus> | undefined, b: PolicyStatus | PlainMessage<PolicyStatus> | undefined): boolean {
    return proto3.util.equals(PolicyStatus, a, b);
  }
}

/**
 * Role is only used for storage
 *
 * @generated from message injective.permissions.v1beta1.Role
 */
export class Role extends Message<Role> {
  /**
   * The role name
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The role ID
   *
   * @generated from field: uint32 role_id = 2;
   */
  roleId = 0;

  /**
   * Integer representing the bitwise combination of all actions assigned to the
   * role
   *
   * @generated from field: uint32 permissions = 3;
   */
  permissions = 0;

  constructor(data?: PartialMessage<Role>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.Role";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "role_id", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "permissions", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Role {
    return new Role().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Role {
    return new Role().fromJsonString(jsonString, options);
  }

  static equals(a: Role | PlainMessage<Role> | undefined, b: Role | PlainMessage<Role> | undefined): boolean {
    return proto3.util.equals(Role, a, b);
  }
}

/**
 * PolicyManagerCapability defines the capabilities of a manager for a policy
 *
 * @generated from message injective.permissions.v1beta1.PolicyManagerCapability
 */
export class PolicyManagerCapability extends Message<PolicyManagerCapability> {
  /**
   * The manager name
   *
   * @generated from field: string manager = 1;
   */
  manager = "";

  /**
   * The action code number
   *
   * @generated from field: injective.permissions.v1beta1.Action action = 2;
   */
  action = Action.UNSPECIFIED;

  /**
   * Whether the manager can disable the policy
   *
   * @generated from field: bool can_disable = 3;
   */
  canDisable = false;

  /**
   * Whether the manager can seal the policy
   *
   * @generated from field: bool can_seal = 4;
   */
  canSeal = false;

  constructor(data?: PartialMessage<PolicyManagerCapability>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.PolicyManagerCapability";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "manager", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action", kind: "enum", T: proto3.getEnumType(Action) },
    { no: 3, name: "can_disable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "can_seal", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PolicyManagerCapability {
    return new PolicyManagerCapability().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PolicyManagerCapability {
    return new PolicyManagerCapability().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PolicyManagerCapability {
    return new PolicyManagerCapability().fromJsonString(jsonString, options);
  }

  static equals(a: PolicyManagerCapability | PlainMessage<PolicyManagerCapability> | undefined, b: PolicyManagerCapability | PlainMessage<PolicyManagerCapability> | undefined): boolean {
    return proto3.util.equals(PolicyManagerCapability, a, b);
  }
}

/**
 * used in storage
 *
 * @generated from message injective.permissions.v1beta1.RoleIDs
 */
export class RoleIDs extends Message<RoleIDs> {
  /**
   * @generated from field: repeated uint32 role_ids = 1;
   */
  roleIds: number[] = [];

  constructor(data?: PartialMessage<RoleIDs>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.RoleIDs";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "role_ids", kind: "scalar", T: 13 /* ScalarType.UINT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoleIDs {
    return new RoleIDs().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoleIDs {
    return new RoleIDs().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoleIDs {
    return new RoleIDs().fromJsonString(jsonString, options);
  }

  static equals(a: RoleIDs | PlainMessage<RoleIDs> | undefined, b: RoleIDs | PlainMessage<RoleIDs> | undefined): boolean {
    return proto3.util.equals(RoleIDs, a, b);
  }
}

/**
 * AddressVoucher is used to represent a voucher for a specific address
 *
 * @generated from message injective.permissions.v1beta1.AddressVoucher
 */
export class AddressVoucher extends Message<AddressVoucher> {
  /**
   * The Injective address that the voucher is for
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The voucher amount
   *
   * @generated from field: cosmos.base.v1beta1.Coin voucher = 2;
   */
  voucher?: Coin;

  constructor(data?: PartialMessage<AddressVoucher>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.permissions.v1beta1.AddressVoucher";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "voucher", kind: "message", T: Coin },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddressVoucher {
    return new AddressVoucher().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddressVoucher {
    return new AddressVoucher().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddressVoucher {
    return new AddressVoucher().fromJsonString(jsonString, options);
  }

  static equals(a: AddressVoucher | PlainMessage<AddressVoucher> | undefined, b: AddressVoucher | PlainMessage<AddressVoucher> | undefined): boolean {
    return proto3.util.equals(AddressVoucher, a, b);
  }
}

