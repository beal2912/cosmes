// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file injective/tokenfactory/v1beta1/tx.proto (package injective.tokenfactory.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js";
import { Metadata } from "../../../cosmos/bank/v1beta1/bank_pb.js";
import { Params } from "./params_pb.js";

/**
 * MsgCreateDenom defines the message structure for the CreateDenom gRPC service
 * method. It allows an account to create a new denom. It requires a sender
 * address and a sub denomination. The (sender_address, sub_denomination) tuple
 * must be unique and cannot be re-used.
 *
 * The resulting denom created is defined as
 * <factory/{creatorAddress}/{subdenom}>. The resulting denom's admin is
 * originally set to be the creator, but this can be changed later. The token
 * denom does not indicate the current admin.
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgCreateDenom
 */
export class MsgCreateDenom extends Message<MsgCreateDenom> {
  /**
   * The sender's Injective address
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * subdenom can be up to 44 "alphanumeric" characters long.
   *
   * @generated from field: string subdenom = 2;
   */
  subdenom = "";

  /**
   * The name
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The symbol
   *
   * @generated from field: string symbol = 4;
   */
  symbol = "";

  /**
   * The number of decimals
   *
   * @generated from field: uint32 decimals = 5;
   */
  decimals = 0;

  /**
   * true if admins are allowed to burn tokens from other addresses
   *
   * @generated from field: bool allow_admin_burn = 6;
   */
  allowAdminBurn = false;

  constructor(data?: PartialMessage<MsgCreateDenom>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgCreateDenom";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subdenom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "symbol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "decimals", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "allow_admin_burn", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDenom {
    return new MsgCreateDenom().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDenom | PlainMessage<MsgCreateDenom> | undefined, b: MsgCreateDenom | PlainMessage<MsgCreateDenom> | undefined): boolean {
    return proto3.util.equals(MsgCreateDenom, a, b);
  }
}

/**
 * MsgCreateDenomResponse is the return value of MsgCreateDenom
 * It returns the full string of the newly created denom
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgCreateDenomResponse
 */
export class MsgCreateDenomResponse extends Message<MsgCreateDenomResponse> {
  /**
   * @generated from field: string new_token_denom = 1;
   */
  newTokenDenom = "";

  constructor(data?: PartialMessage<MsgCreateDenomResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgCreateDenomResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_token_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgCreateDenomResponse {
    return new MsgCreateDenomResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgCreateDenomResponse | PlainMessage<MsgCreateDenomResponse> | undefined, b: MsgCreateDenomResponse | PlainMessage<MsgCreateDenomResponse> | undefined): boolean {
    return proto3.util.equals(MsgCreateDenomResponse, a, b);
  }
}

/**
 * MsgMint is the sdk.Msg type for allowing an admin account or other permitted
 * accounts to mint more of a token.
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgMint
 */
export class MsgMint extends Message<MsgMint> {
  /**
   * The sender's Injective address
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * The amount of tokens to mint
   *
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  /**
   * The Injective address to receive the tokens
   *
   * @generated from field: string receiver = 3;
   */
  receiver = "";

  constructor(data?: PartialMessage<MsgMint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgMint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
    { no: 3, name: "receiver", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMint {
    return new MsgMint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMint {
    return new MsgMint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMint {
    return new MsgMint().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMint | PlainMessage<MsgMint> | undefined, b: MsgMint | PlainMessage<MsgMint> | undefined): boolean {
    return proto3.util.equals(MsgMint, a, b);
  }
}

/**
 * @generated from message injective.tokenfactory.v1beta1.MsgMintResponse
 */
export class MsgMintResponse extends Message<MsgMintResponse> {
  constructor(data?: PartialMessage<MsgMintResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgMintResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgMintResponse {
    return new MsgMintResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgMintResponse | PlainMessage<MsgMintResponse> | undefined, b: MsgMintResponse | PlainMessage<MsgMintResponse> | undefined): boolean {
    return proto3.util.equals(MsgMintResponse, a, b);
  }
}

/**
 * MsgBurn is the sdk.Msg type for allowing an admin account to burn
 * a token.
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgBurn
 */
export class MsgBurn extends Message<MsgBurn> {
  /**
   * The sender's Injective address
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * The amount of tokens to burn
   *
   * @generated from field: cosmos.base.v1beta1.Coin amount = 2;
   */
  amount?: Coin;

  /**
   * The Injective address to burn the tokens from
   *
   * @generated from field: string burnFromAddress = 3;
   */
  burnFromAddress = "";

  constructor(data?: PartialMessage<MsgBurn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgBurn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "amount", kind: "message", T: Coin },
    { no: 3, name: "burnFromAddress", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurn {
    return new MsgBurn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurn {
    return new MsgBurn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurn {
    return new MsgBurn().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurn | PlainMessage<MsgBurn> | undefined, b: MsgBurn | PlainMessage<MsgBurn> | undefined): boolean {
    return proto3.util.equals(MsgBurn, a, b);
  }
}

/**
 * @generated from message injective.tokenfactory.v1beta1.MsgBurnResponse
 */
export class MsgBurnResponse extends Message<MsgBurnResponse> {
  constructor(data?: PartialMessage<MsgBurnResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgBurnResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgBurnResponse {
    return new MsgBurnResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgBurnResponse | PlainMessage<MsgBurnResponse> | undefined, b: MsgBurnResponse | PlainMessage<MsgBurnResponse> | undefined): boolean {
    return proto3.util.equals(MsgBurnResponse, a, b);
  }
}

/**
 * MsgChangeAdmin is the sdk.Msg type for allowing an admin account to reassign
 * adminship of a denom to a new account
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgChangeAdmin
 */
export class MsgChangeAdmin extends Message<MsgChangeAdmin> {
  /**
   * The sender's Injective address
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * The denom
   *
   * @generated from field: string denom = 2;
   */
  denom = "";

  /**
   * The new admin's Injective address
   *
   * @generated from field: string new_admin = 3;
   */
  newAdmin = "";

  constructor(data?: PartialMessage<MsgChangeAdmin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgChangeAdmin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "new_admin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgChangeAdmin {
    return new MsgChangeAdmin().fromJsonString(jsonString, options);
  }

  static equals(a: MsgChangeAdmin | PlainMessage<MsgChangeAdmin> | undefined, b: MsgChangeAdmin | PlainMessage<MsgChangeAdmin> | undefined): boolean {
    return proto3.util.equals(MsgChangeAdmin, a, b);
  }
}

/**
 * MsgChangeAdminResponse defines the response structure for an executed
 * MsgChangeAdmin message.
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgChangeAdminResponse
 */
export class MsgChangeAdminResponse extends Message<MsgChangeAdminResponse> {
  constructor(data?: PartialMessage<MsgChangeAdminResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgChangeAdminResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgChangeAdminResponse {
    return new MsgChangeAdminResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgChangeAdminResponse | PlainMessage<MsgChangeAdminResponse> | undefined, b: MsgChangeAdminResponse | PlainMessage<MsgChangeAdminResponse> | undefined): boolean {
    return proto3.util.equals(MsgChangeAdminResponse, a, b);
  }
}

/**
 * MsgSetDenomMetadata is the sdk.Msg type for allowing an admin account to set
 * the denom's bank metadata
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgSetDenomMetadata
 */
export class MsgSetDenomMetadata extends Message<MsgSetDenomMetadata> {
  /**
   * The sender's Injective address
   *
   * @generated from field: string sender = 1;
   */
  sender = "";

  /**
   * The metadata
   *
   * @generated from field: cosmos.bank.v1beta1.Metadata metadata = 2;
   */
  metadata?: Metadata;

  /**
   * @generated from field: injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled admin_burn_disabled = 3;
   */
  adminBurnDisabled?: MsgSetDenomMetadata_AdminBurnDisabled;

  constructor(data?: PartialMessage<MsgSetDenomMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgSetDenomMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sender", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metadata", kind: "message", T: Metadata },
    { no: 3, name: "admin_burn_disabled", kind: "message", T: MsgSetDenomMetadata_AdminBurnDisabled },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata {
    return new MsgSetDenomMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomMetadata | PlainMessage<MsgSetDenomMetadata> | undefined, b: MsgSetDenomMetadata | PlainMessage<MsgSetDenomMetadata> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomMetadata, a, b);
  }
}

/**
 * @generated from message injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled
 */
export class MsgSetDenomMetadata_AdminBurnDisabled extends Message<MsgSetDenomMetadata_AdminBurnDisabled> {
  /**
   * true if the admin burn capability should be disabled
   *
   * @generated from field: bool should_disable = 1;
   */
  shouldDisable = false;

  constructor(data?: PartialMessage<MsgSetDenomMetadata_AdminBurnDisabled>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgSetDenomMetadata.AdminBurnDisabled";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "should_disable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomMetadata_AdminBurnDisabled {
    return new MsgSetDenomMetadata_AdminBurnDisabled().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata_AdminBurnDisabled {
    return new MsgSetDenomMetadata_AdminBurnDisabled().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomMetadata_AdminBurnDisabled {
    return new MsgSetDenomMetadata_AdminBurnDisabled().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomMetadata_AdminBurnDisabled | PlainMessage<MsgSetDenomMetadata_AdminBurnDisabled> | undefined, b: MsgSetDenomMetadata_AdminBurnDisabled | PlainMessage<MsgSetDenomMetadata_AdminBurnDisabled> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomMetadata_AdminBurnDisabled, a, b);
  }
}

/**
 * MsgSetDenomMetadataResponse defines the response structure for an executed
 * MsgSetDenomMetadata message.
 *
 * @generated from message injective.tokenfactory.v1beta1.MsgSetDenomMetadataResponse
 */
export class MsgSetDenomMetadataResponse extends Message<MsgSetDenomMetadataResponse> {
  constructor(data?: PartialMessage<MsgSetDenomMetadataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgSetDenomMetadataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgSetDenomMetadataResponse {
    return new MsgSetDenomMetadataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgSetDenomMetadataResponse | PlainMessage<MsgSetDenomMetadataResponse> | undefined, b: MsgSetDenomMetadataResponse | PlainMessage<MsgSetDenomMetadataResponse> | undefined): boolean {
    return proto3.util.equals(MsgSetDenomMetadataResponse, a, b);
  }
}

/**
 * @generated from message injective.tokenfactory.v1beta1.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address of the governance account.
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the tokenfactory parameters to update.
   *
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: injective.tokenfactory.v1beta1.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * @generated from message injective.tokenfactory.v1beta1.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "injective.tokenfactory.v1beta1.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

