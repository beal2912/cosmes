// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file sunrise/swap/route.proto (package sunrise.swap, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Coin } from "../../cosmos/base/v1beta1/coin_pb.js";

/**
 * @generated from message sunrise.swap.RoutePool
 */
export class RoutePool extends Message<RoutePool> {
  /**
   * @generated from field: uint64 pool_id = 1;
   */
  poolId = protoInt64.zero;

  constructor(data?: PartialMessage<RoutePool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RoutePool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RoutePool {
    return new RoutePool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RoutePool {
    return new RoutePool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RoutePool {
    return new RoutePool().fromJsonString(jsonString, options);
  }

  static equals(a: RoutePool | PlainMessage<RoutePool> | undefined, b: RoutePool | PlainMessage<RoutePool> | undefined): boolean {
    return proto3.util.equals(RoutePool, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteSeries
 */
export class RouteSeries extends Message<RouteSeries> {
  /**
   * @generated from field: repeated sunrise.swap.Route routes = 1;
   */
  routes: Route[] = [];

  constructor(data?: PartialMessage<RouteSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "routes", kind: "message", T: Route, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteSeries {
    return new RouteSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteSeries {
    return new RouteSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteSeries {
    return new RouteSeries().fromJsonString(jsonString, options);
  }

  static equals(a: RouteSeries | PlainMessage<RouteSeries> | undefined, b: RouteSeries | PlainMessage<RouteSeries> | undefined): boolean {
    return proto3.util.equals(RouteSeries, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteParallel
 */
export class RouteParallel extends Message<RouteParallel> {
  /**
   * @generated from field: repeated sunrise.swap.Route routes = 1;
   */
  routes: Route[] = [];

  /**
   * @generated from field: repeated string weights = 2;
   */
  weights: string[] = [];

  constructor(data?: PartialMessage<RouteParallel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteParallel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "routes", kind: "message", T: Route, repeated: true },
    { no: 2, name: "weights", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteParallel {
    return new RouteParallel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteParallel {
    return new RouteParallel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteParallel {
    return new RouteParallel().fromJsonString(jsonString, options);
  }

  static equals(a: RouteParallel | PlainMessage<RouteParallel> | undefined, b: RouteParallel | PlainMessage<RouteParallel> | undefined): boolean {
    return proto3.util.equals(RouteParallel, a, b);
  }
}

/**
 * @generated from message sunrise.swap.Route
 */
export class Route extends Message<Route> {
  /**
   * @generated from field: string denom_in = 1;
   */
  denomIn = "";

  /**
   * @generated from field: string denom_out = 2;
   */
  denomOut = "";

  /**
   * @generated from oneof sunrise.swap.Route.strategy
   */
  strategy: {
    /**
     * @generated from field: sunrise.swap.RoutePool pool = 3;
     */
    value: RoutePool;
    case: "pool";
  } | {
    /**
     * @generated from field: sunrise.swap.RouteSeries series = 4;
     */
    value: RouteSeries;
    case: "series";
  } | {
    /**
     * @generated from field: sunrise.swap.RouteParallel parallel = 5;
     */
    value: RouteParallel;
    case: "parallel";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Route>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.Route";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "denom_in", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "denom_out", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "pool", kind: "message", T: RoutePool, oneof: "strategy" },
    { no: 4, name: "series", kind: "message", T: RouteSeries, oneof: "strategy" },
    { no: 5, name: "parallel", kind: "message", T: RouteParallel, oneof: "strategy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Route {
    return new Route().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Route {
    return new Route().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Route {
    return new Route().fromJsonString(jsonString, options);
  }

  static equals(a: Route | PlainMessage<Route> | undefined, b: Route | PlainMessage<Route> | undefined): boolean {
    return proto3.util.equals(Route, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteResultPool
 */
export class RouteResultPool extends Message<RouteResultPool> {
  /**
   * @generated from field: uint64 pool_id = 1;
   */
  poolId = protoInt64.zero;

  constructor(data?: PartialMessage<RouteResultPool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteResultPool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pool_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteResultPool {
    return new RouteResultPool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteResultPool {
    return new RouteResultPool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteResultPool {
    return new RouteResultPool().fromJsonString(jsonString, options);
  }

  static equals(a: RouteResultPool | PlainMessage<RouteResultPool> | undefined, b: RouteResultPool | PlainMessage<RouteResultPool> | undefined): boolean {
    return proto3.util.equals(RouteResultPool, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteResultSeries
 */
export class RouteResultSeries extends Message<RouteResultSeries> {
  /**
   * @generated from field: repeated sunrise.swap.RouteResult route_results = 1;
   */
  routeResults: RouteResult[] = [];

  constructor(data?: PartialMessage<RouteResultSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteResultSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "route_results", kind: "message", T: RouteResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteResultSeries {
    return new RouteResultSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteResultSeries {
    return new RouteResultSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteResultSeries {
    return new RouteResultSeries().fromJsonString(jsonString, options);
  }

  static equals(a: RouteResultSeries | PlainMessage<RouteResultSeries> | undefined, b: RouteResultSeries | PlainMessage<RouteResultSeries> | undefined): boolean {
    return proto3.util.equals(RouteResultSeries, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteResultParallel
 */
export class RouteResultParallel extends Message<RouteResultParallel> {
  /**
   * @generated from field: repeated sunrise.swap.RouteResult route_results = 1;
   */
  routeResults: RouteResult[] = [];

  constructor(data?: PartialMessage<RouteResultParallel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteResultParallel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "route_results", kind: "message", T: RouteResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteResultParallel {
    return new RouteResultParallel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteResultParallel {
    return new RouteResultParallel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteResultParallel {
    return new RouteResultParallel().fromJsonString(jsonString, options);
  }

  static equals(a: RouteResultParallel | PlainMessage<RouteResultParallel> | undefined, b: RouteResultParallel | PlainMessage<RouteResultParallel> | undefined): boolean {
    return proto3.util.equals(RouteResultParallel, a, b);
  }
}

/**
 * @generated from message sunrise.swap.RouteResult
 */
export class RouteResult extends Message<RouteResult> {
  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_in = 1;
   */
  tokenIn?: Coin;

  /**
   * @generated from field: cosmos.base.v1beta1.Coin token_out = 2;
   */
  tokenOut?: Coin;

  /**
   * @generated from oneof sunrise.swap.RouteResult.strategy
   */
  strategy: {
    /**
     * @generated from field: sunrise.swap.RouteResultPool pool = 3;
     */
    value: RouteResultPool;
    case: "pool";
  } | {
    /**
     * @generated from field: sunrise.swap.RouteResultSeries series = 4;
     */
    value: RouteResultSeries;
    case: "series";
  } | {
    /**
     * @generated from field: sunrise.swap.RouteResultParallel parallel = 5;
     */
    value: RouteResultParallel;
    case: "parallel";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RouteResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sunrise.swap.RouteResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token_in", kind: "message", T: Coin },
    { no: 2, name: "token_out", kind: "message", T: Coin },
    { no: 3, name: "pool", kind: "message", T: RouteResultPool, oneof: "strategy" },
    { no: 4, name: "series", kind: "message", T: RouteResultSeries, oneof: "strategy" },
    { no: 5, name: "parallel", kind: "message", T: RouteResultParallel, oneof: "strategy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteResult {
    return new RouteResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteResult {
    return new RouteResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteResult {
    return new RouteResult().fromJsonString(jsonString, options);
  }

  static equals(a: RouteResult | PlainMessage<RouteResult> | undefined, b: RouteResult | PlainMessage<RouteResult> | undefined): boolean {
    return proto3.util.equals(RouteResult, a, b);
  }
}

