// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file pryzm/icstaking/v1/host_chain.proto (package pryzm.icstaking.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { StakingParams } from "./params_pb.js";
import { Height } from "../../../ibc/core/client/v1/client_pb.js";

/**
 * The types of available connection protocols
 *
 * @generated from enum pryzm.icstaking.v1.ConnectionType
 */
export enum ConnectionType {
  /**
   * interchain account connection using ibc-go ICS-27
   *
   * @generated from enum value: ConnectionType_ICA = 0;
   */
  ConnectionType_ICA = 0,

  /**
   * connecting to the host chain using a trusted multi-sig account
   *
   * @generated from enum value: ConnectionType_MULTI_SIG = 1;
   */
  ConnectionType_MULTI_SIG = 1,

  /**
   * connection to the Pryzm itself
   *
   * @generated from enum value: ConnectionType_LOOP_BACK = 2;
   */
  ConnectionType_LOOP_BACK = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionType)
proto3.util.setEnumType(ConnectionType, "pryzm.icstaking.v1.ConnectionType", [
  { no: 0, name: "ConnectionType_ICA" },
  { no: 1, name: "ConnectionType_MULTI_SIG" },
  { no: 2, name: "ConnectionType_LOOP_BACK" },
]);

/**
 * Types of transfer channels
 *
 * @generated from enum pryzm.icstaking.v1.TransferChannelType
 */
export enum TransferChannelType {
  /**
   * IBC transfer
   *
   * @generated from enum value: TransferChannelType_IBC = 0;
   */
  TransferChannelType_IBC = 0,

  /**
   * transfer to Pryzm itself
   *
   * @generated from enum value: TransferChannelType_LOOP_BACK = 1;
   */
  TransferChannelType_LOOP_BACK = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(TransferChannelType)
proto3.util.setEnumType(TransferChannelType, "pryzm.icstaking.v1.TransferChannelType", [
  { no: 0, name: "TransferChannelType_IBC" },
  { no: 1, name: "TransferChannelType_LOOP_BACK" },
]);

/**
 * @generated from enum pryzm.icstaking.v1.AccountState
 */
export enum AccountState {
  /**
   * @generated from enum value: NOT_REGISTERED = 0;
   */
  NOT_REGISTERED = 0,

  /**
   * @generated from enum value: REGISTERING = 1;
   */
  REGISTERING = 1,

  /**
   * @generated from enum value: REGISTERED = 2;
   */
  REGISTERED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AccountState)
proto3.util.setEnumType(AccountState, "pryzm.icstaking.v1.AccountState", [
  { no: 0, name: "NOT_REGISTERED" },
  { no: 1, name: "REGISTERING" },
  { no: 2, name: "REGISTERED" },
]);

/**
 * @generated from enum pryzm.icstaking.v1.State
 */
export enum State {
  /**
   * @generated from enum value: INITIALIZING = 0;
   */
  INITIALIZING = 0,

  /**
   * @generated from enum value: IDLE = 1;
   */
  IDLE = 1,

  /**
   * @generated from enum value: TRANSFERRING = 2;
   */
  TRANSFERRING = 2,

  /**
   * @generated from enum value: DELEGATING = 3;
   */
  DELEGATING = 3,

  /**
   * @generated from enum value: UNDELEGATING = 4;
   */
  UNDELEGATING = 4,

  /**
   * @generated from enum value: REDELEGATING = 5;
   */
  REDELEGATING = 5,

  /**
   * @generated from enum value: COMPOUNDING = 6;
   */
  COMPOUNDING = 6,

  /**
   * @generated from enum value: COLLECTING = 7;
   */
  COLLECTING = 7,

  /**
   * @generated from enum value: SWEEPING = 8;
   */
  SWEEPING = 8,

  /**
   * @generated from enum value: LSM_REDEEMING = 9;
   */
  LSM_REDEEMING = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(State)
proto3.util.setEnumType(State, "pryzm.icstaking.v1.State", [
  { no: 0, name: "INITIALIZING" },
  { no: 1, name: "IDLE" },
  { no: 2, name: "TRANSFERRING" },
  { no: 3, name: "DELEGATING" },
  { no: 4, name: "UNDELEGATING" },
  { no: 5, name: "REDELEGATING" },
  { no: 6, name: "COMPOUNDING" },
  { no: 7, name: "COLLECTING" },
  { no: 8, name: "SWEEPING" },
  { no: 9, name: "LSM_REDEEMING" },
]);

/**
 * The properties of the target chain for staking
 *
 * @generated from message pryzm.icstaking.v1.HostChain
 */
export class HostChain extends Message<HostChain> {
  /**
   * A unique user-provided identifier. Is used in the cToken denom
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * connection type. connection type and connection id are unique together
   *
   * @generated from field: pryzm.icstaking.v1.ConnectionType connection_type = 2;
   */
  connectionType = ConnectionType.ConnectionType_ICA;

  /**
   * the identifier for connection. connection id and connection type are unique together
   *
   * @generated from field: string connection_id = 3;
   */
  connectionId = "";

  /**
   * the base denom of the token to be staked on the target chain
   *
   * @generated from field: string base_denom = 4;
   */
  baseDenom = "";

  /**
   * list of supported transfer channels for transferring the base_denom tokens between the host chain and Pryzm
   *
   * @generated from field: repeated pryzm.icstaking.v1.TransferChannel transfer_channels = 5;
   */
  transferChannels: TransferChannel[] = [];

  /**
   * Parameters for staking/unstaking on the host chain
   *
   * @generated from field: pryzm.icstaking.v1.StakingParams params = 6;
   */
  params?: StakingParams;

  /**
   * list of whitelisted validators to which Pryzm sends the staked funds.
   *
   * @generated from field: repeated pryzm.icstaking.v1.Validator validators = 7;
   */
  validators: Validator[] = [];

  /**
   * If true, Pryzm will allow users to stake using the LSM shares minted on the host chain.
   *
   * @generated from field: bool allow_lsm_shares = 8;
   */
  allowLsmShares = false;

  constructor(data?: PartialMessage<HostChain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.HostChain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_type", kind: "enum", T: proto3.getEnumType(ConnectionType) },
    { no: 3, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "base_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "transfer_channels", kind: "message", T: TransferChannel, repeated: true },
    { no: 6, name: "params", kind: "message", T: StakingParams },
    { no: 7, name: "validators", kind: "message", T: Validator, repeated: true },
    { no: 8, name: "allow_lsm_shares", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostChain {
    return new HostChain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostChain {
    return new HostChain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostChain {
    return new HostChain().fromJsonString(jsonString, options);
  }

  static equals(a: HostChain | PlainMessage<HostChain> | undefined, b: HostChain | PlainMessage<HostChain> | undefined): boolean {
    return proto3.util.equals(HostChain, a, b);
  }
}

/**
 * Properties of a transfer channel
 *
 * @generated from message pryzm.icstaking.v1.TransferChannel
 */
export class TransferChannel extends Message<TransferChannel> {
  /**
   * the type of the channel
   *
   * @generated from field: pryzm.icstaking.v1.TransferChannelType type = 1;
   */
  type = TransferChannelType.TransferChannelType_IBC;

  /**
   * the id of the channel. in the case of IBC channel type, this is the channel name.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  /**
   * Optional. This is the name of the token on the receiving chain.
   * This is useful when a bridge is being used and the underlying asset is wrapped on the bridge, like axlWETH.
   *
   * @generated from field: string wrapped_denom = 3;
   */
  wrappedDenom = "";

  /**
   * Optional. This is the name of the target chain.
   * This is useful when a bridge is being used and the host chain is different with the receiving chain.
   *
   * @generated from field: string destination_chain = 4;
   */
  destinationChain = "";

  constructor(data?: PartialMessage<TransferChannel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.TransferChannel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(TransferChannelType) },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "wrapped_denom", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "destination_chain", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferChannel {
    return new TransferChannel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferChannel {
    return new TransferChannel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferChannel {
    return new TransferChannel().fromJsonString(jsonString, options);
  }

  static equals(a: TransferChannel | PlainMessage<TransferChannel> | undefined, b: TransferChannel | PlainMessage<TransferChannel> | undefined): boolean {
    return proto3.util.equals(TransferChannel, a, b);
  }
}

/**
 * @generated from message pryzm.icstaking.v1.Validator
 */
export class Validator extends Message<Validator> {
  /**
   * validator's address on the host chain
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * The weight of delegation to the validator. Total weight of all validators per host chain must be equal to 1.
   *
   * @generated from field: string weight = 2;
   */
  weight = "";

  /**
   * whether users can stake the lsm shares minted from this validator
   *
   * @generated from field: bool allow_lsm_shares = 3;
   */
  allowLsmShares = false;

  constructor(data?: PartialMessage<Validator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.Validator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "allow_lsm_shares", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Validator {
    return new Validator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Validator {
    return new Validator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Validator {
    return new Validator().fromJsonString(jsonString, options);
  }

  static equals(a: Validator | PlainMessage<Validator> | undefined, b: Validator | PlainMessage<Validator> | undefined): boolean {
    return proto3.util.equals(Validator, a, b);
  }
}

/**
 * A subset of state on the host chain needed by Pryzm
 *
 * @generated from message pryzm.icstaking.v1.HostChainState
 */
export class HostChainState extends Message<HostChainState> {
  /**
   * The id of the chain
   *
   * @generated from field: string host_chain_id = 1;
   */
  hostChainId = "";

  /**
   * Information about the interchain accounts
   *
   * @generated from field: pryzm.icstaking.v1.HostAccounts host_accounts = 2;
   */
  hostAccounts?: HostAccounts;

  /**
   * list of validators and their state containing the delegation amount
   *
   * @generated from field: repeated pryzm.icstaking.v1.ValidatorState validator_states = 3;
   */
  validatorStates: ValidatorState[] = [];

  /**
   * The amount of assets that are in the delegation account and ready to be delegated
   *
   * @generated from field: string amount_to_be_delegated = 4;
   */
  amountToBeDelegated = "";

  /**
   * The amount of undelegated assets that are currently in the delegation account waiting to be collected
   *
   * @generated from field: string undelegated_amount_to_collect = 5;
   */
  undelegatedAmountToCollect = "";

  /**
   * The current exchange rate of cToken to the host chain staking token
   *
   * @generated from field: string exchange_rate = 6;
   */
  exchangeRate = "";

  /**
   * The current state of interchain operations state machine
   *
   * @generated from field: pryzm.icstaking.v1.State state = 7;
   */
  state = State.INITIALIZING;

  /**
   * The last host chain's block height in which PRYZM's state is changed to IDLE
   * setting state to IDLE happens when an ack/timeout received for an interchain operation,
   * so this is the height of the last received ack from host chain
   *
   * @generated from field: ibc.core.client.v1.Height last_idle_state_host_height = 8;
   */
  lastIdleStateHostHeight?: Height;

  /**
   * The amount of LSM tokens that are in queue to be transferred and redeemed on the host chain
   *
   * @generated from field: string locked_lsm_value = 9;
   */
  lockedLsmValue = "";

  /**
   * The amount of fee taken from rewards that is collected and waiting to be transferred from host chain to treasury
   *
   * @generated from field: string collected_fee = 10;
   */
  collectedFee = "";

  constructor(data?: PartialMessage<HostChainState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.HostChainState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host_chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "host_accounts", kind: "message", T: HostAccounts },
    { no: 3, name: "validator_states", kind: "message", T: ValidatorState, repeated: true },
    { no: 4, name: "amount_to_be_delegated", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "undelegated_amount_to_collect", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "exchange_rate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 8, name: "last_idle_state_host_height", kind: "message", T: Height },
    { no: 9, name: "locked_lsm_value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "collected_fee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostChainState {
    return new HostChainState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostChainState {
    return new HostChainState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostChainState {
    return new HostChainState().fromJsonString(jsonString, options);
  }

  static equals(a: HostChainState | PlainMessage<HostChainState> | undefined, b: HostChainState | PlainMessage<HostChainState> | undefined): boolean {
    return proto3.util.equals(HostChainState, a, b);
  }
}

/**
 * The interchain accounts
 *
 * @generated from message pryzm.icstaking.v1.HostAccounts
 */
export class HostAccounts extends Message<HostAccounts> {
  /**
   * @generated from field: pryzm.icstaking.v1.HostAccount delegation = 1;
   */
  delegation?: HostAccount;

  /**
   * @generated from field: pryzm.icstaking.v1.HostAccount reward = 2;
   */
  reward?: HostAccount;

  /**
   * @generated from field: pryzm.icstaking.v1.HostAccount sweep = 3;
   */
  sweep?: HostAccount;

  /**
   * This is the state of setting the reward account as the account which receives the staking rewards on host chain.
   * On cosmos based chains, the reward account is registered using MsgSetWithdrawAddress in distribution module.
   *
   * @generated from field: pryzm.icstaking.v1.AccountState reward_account_claiming_state = 4;
   */
  rewardAccountClaimingState = AccountState.NOT_REGISTERED;

  constructor(data?: PartialMessage<HostAccounts>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.HostAccounts";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "delegation", kind: "message", T: HostAccount },
    { no: 2, name: "reward", kind: "message", T: HostAccount },
    { no: 3, name: "sweep", kind: "message", T: HostAccount },
    { no: 4, name: "reward_account_claiming_state", kind: "enum", T: proto3.getEnumType(AccountState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostAccounts {
    return new HostAccounts().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostAccounts {
    return new HostAccounts().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostAccounts {
    return new HostAccounts().fromJsonString(jsonString, options);
  }

  static equals(a: HostAccounts | PlainMessage<HostAccounts> | undefined, b: HostAccounts | PlainMessage<HostAccounts> | undefined): boolean {
    return proto3.util.equals(HostAccounts, a, b);
  }
}

/**
 * @generated from message pryzm.icstaking.v1.HostAccount
 */
export class HostAccount extends Message<HostAccount> {
  /**
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * @generated from field: string balance = 2;
   */
  balance = "";

  /**
   * @generated from field: pryzm.icstaking.v1.AccountState state = 3;
   */
  state = AccountState.NOT_REGISTERED;

  constructor(data?: PartialMessage<HostAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.HostAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "balance", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(AccountState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HostAccount {
    return new HostAccount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HostAccount {
    return new HostAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HostAccount {
    return new HostAccount().fromJsonString(jsonString, options);
  }

  static equals(a: HostAccount | PlainMessage<HostAccount> | undefined, b: HostAccount | PlainMessage<HostAccount> | undefined): boolean {
    return proto3.util.equals(HostAccount, a, b);
  }
}

/**
 * @generated from message pryzm.icstaking.v1.ValidatorState
 */
export class ValidatorState extends Message<ValidatorState> {
  /**
   * the address of the validator
   *
   * @generated from field: string validator_address = 1;
   */
  validatorAddress = "";

  /**
   * the amount of tokens delegated to the validator by PRYZM
   *
   * @generated from field: string delegated_amount = 2;
   */
  delegatedAmount = "";

  /**
   * total tokens delegated to the validator by all delegators
   * this is used to calculate the value of the validator's lsm share
   *
   * @generated from field: string total_tokens = 3;
   */
  totalTokens = "";

  /**
   * total shares issued to the validator's delegators
   * this is used to calculate the value of the validator's lsm share
   *
   * @generated from field: string total_shares = 4;
   */
  totalShares = "";

  constructor(data?: PartialMessage<ValidatorState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "pryzm.icstaking.v1.ValidatorState";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "validator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "delegated_amount", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_tokens", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "total_shares", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidatorState {
    return new ValidatorState().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidatorState {
    return new ValidatorState().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidatorState {
    return new ValidatorState().fromJsonString(jsonString, options);
  }

  static equals(a: ValidatorState | PlainMessage<ValidatorState> | undefined, b: ValidatorState | PlainMessage<ValidatorState> | undefined): boolean {
    return proto3.util.equals(ValidatorState, a, b);
  }
}

