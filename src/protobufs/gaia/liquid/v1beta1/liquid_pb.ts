// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file gaia/liquid/v1beta1/liquid.proto (package gaia.liquid.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { DecCoin } from "../../../cosmos/base/v1beta1/coin_pb.js";

/**
 * TokenizeShareLockStatus indicates whether the address is able to tokenize
 * shares
 *
 * @generated from enum gaia.liquid.v1beta1.TokenizeShareLockStatus
 */
export enum TokenizeShareLockStatus {
  /**
   * UNSPECIFIED defines an empty tokenize share lock status
   *
   * @generated from enum value: TOKENIZE_SHARE_LOCK_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * LOCKED indicates the account is locked and cannot tokenize shares
   *
   * @generated from enum value: TOKENIZE_SHARE_LOCK_STATUS_LOCKED = 1;
   */
  LOCKED = 1,

  /**
   * UNLOCKED indicates the account is unlocked and can tokenize shares
   *
   * @generated from enum value: TOKENIZE_SHARE_LOCK_STATUS_UNLOCKED = 2;
   */
  UNLOCKED = 2,

  /**
   * LOCK_EXPIRING indicates the account is unable to tokenize shares, but
   * will be able to tokenize shortly (after 1 unbonding period)
   *
   * @generated from enum value: TOKENIZE_SHARE_LOCK_STATUS_LOCK_EXPIRING = 3;
   */
  LOCK_EXPIRING = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TokenizeShareLockStatus)
proto3.util.setEnumType(TokenizeShareLockStatus, "gaia.liquid.v1beta1.TokenizeShareLockStatus", [
  { no: 0, name: "TOKENIZE_SHARE_LOCK_STATUS_UNSPECIFIED" },
  { no: 1, name: "TOKENIZE_SHARE_LOCK_STATUS_LOCKED" },
  { no: 2, name: "TOKENIZE_SHARE_LOCK_STATUS_UNLOCKED" },
  { no: 3, name: "TOKENIZE_SHARE_LOCK_STATUS_LOCK_EXPIRING" },
]);

/**
 * Params defines the parameters for the x/liquid module.
 *
 * @generated from message gaia.liquid.v1beta1.Params
 */
export class Params extends Message<Params> {
  /**
   * global_liquid_staking_cap represents a cap on the portion of stake that
   * comes from liquid staking providers
   *
   * @generated from field: string global_liquid_staking_cap = 8;
   */
  globalLiquidStakingCap = "";

  /**
   * validator_liquid_staking_cap represents a cap on the portion of stake that
   * comes from liquid staking providers for a specific validator
   *
   * @generated from field: string validator_liquid_staking_cap = 9;
   */
  validatorLiquidStakingCap = "";

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gaia.liquid.v1beta1.Params";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "global_liquid_staking_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "validator_liquid_staking_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(a: Params | PlainMessage<Params> | undefined, b: Params | PlainMessage<Params> | undefined): boolean {
    return proto3.util.equals(Params, a, b);
  }
}

/**
 * TokenizeShareRecord represents a tokenized delegation
 *
 * @generated from message gaia.liquid.v1beta1.TokenizeShareRecord
 */
export class TokenizeShareRecord extends Message<TokenizeShareRecord> {
  /**
   * @generated from field: uint64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * @generated from field: string owner = 2;
   */
  owner = "";

  /**
   * module account take the role of delegator
   *
   * @generated from field: string module_account = 3;
   */
  moduleAccount = "";

  /**
   * validator delegated to for tokenize share record creation
   *
   * @generated from field: string validator = 4;
   */
  validator = "";

  constructor(data?: PartialMessage<TokenizeShareRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gaia.liquid.v1beta1.TokenizeShareRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "owner", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "module_account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "validator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenizeShareRecord {
    return new TokenizeShareRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenizeShareRecord {
    return new TokenizeShareRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenizeShareRecord {
    return new TokenizeShareRecord().fromJsonString(jsonString, options);
  }

  static equals(a: TokenizeShareRecord | PlainMessage<TokenizeShareRecord> | undefined, b: TokenizeShareRecord | PlainMessage<TokenizeShareRecord> | undefined): boolean {
    return proto3.util.equals(TokenizeShareRecord, a, b);
  }
}

/**
 * PendingTokenizeShareAuthorizations stores a list of addresses that have their
 * tokenize share enablement in progress
 *
 * @generated from message gaia.liquid.v1beta1.PendingTokenizeShareAuthorizations
 */
export class PendingTokenizeShareAuthorizations extends Message<PendingTokenizeShareAuthorizations> {
  /**
   * @generated from field: repeated string addresses = 1;
   */
  addresses: string[] = [];

  constructor(data?: PartialMessage<PendingTokenizeShareAuthorizations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gaia.liquid.v1beta1.PendingTokenizeShareAuthorizations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "addresses", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingTokenizeShareAuthorizations {
    return new PendingTokenizeShareAuthorizations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingTokenizeShareAuthorizations {
    return new PendingTokenizeShareAuthorizations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingTokenizeShareAuthorizations {
    return new PendingTokenizeShareAuthorizations().fromJsonString(jsonString, options);
  }

  static equals(a: PendingTokenizeShareAuthorizations | PlainMessage<PendingTokenizeShareAuthorizations> | undefined, b: PendingTokenizeShareAuthorizations | PlainMessage<PendingTokenizeShareAuthorizations> | undefined): boolean {
    return proto3.util.equals(PendingTokenizeShareAuthorizations, a, b);
  }
}

/**
 * TokenizeShareRecordReward represents the properties of tokenize share
 *
 * @generated from message gaia.liquid.v1beta1.TokenizeShareRecordReward
 */
export class TokenizeShareRecordReward extends Message<TokenizeShareRecordReward> {
  /**
   * @generated from field: uint64 record_id = 1;
   */
  recordId = protoInt64.zero;

  /**
   * @generated from field: repeated cosmos.base.v1beta1.DecCoin reward = 2;
   */
  reward: DecCoin[] = [];

  constructor(data?: PartialMessage<TokenizeShareRecordReward>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gaia.liquid.v1beta1.TokenizeShareRecordReward";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "record_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "reward", kind: "message", T: DecCoin, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TokenizeShareRecordReward {
    return new TokenizeShareRecordReward().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TokenizeShareRecordReward {
    return new TokenizeShareRecordReward().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TokenizeShareRecordReward {
    return new TokenizeShareRecordReward().fromJsonString(jsonString, options);
  }

  static equals(a: TokenizeShareRecordReward | PlainMessage<TokenizeShareRecordReward> | undefined, b: TokenizeShareRecordReward | PlainMessage<TokenizeShareRecordReward> | undefined): boolean {
    return proto3.util.equals(TokenizeShareRecordReward, a, b);
  }
}

/**
 * LiquidValidator is the storage layout for details about a validator's liquid
 * stake.
 *
 * @generated from message gaia.liquid.v1beta1.LiquidValidator
 */
export class LiquidValidator extends Message<LiquidValidator> {
  /**
   * operator_address defines the address of the validator's operator; bech
   * encoded in JSON.
   *
   * @generated from field: string operator_address = 1;
   */
  operatorAddress = "";

  /**
   * Number of shares either tokenized or owned by a liquid staking provider
   *
   * @generated from field: string liquid_shares = 3;
   */
  liquidShares = "";

  constructor(data?: PartialMessage<LiquidValidator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "gaia.liquid.v1beta1.LiquidValidator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "liquid_shares", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiquidValidator {
    return new LiquidValidator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiquidValidator {
    return new LiquidValidator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiquidValidator {
    return new LiquidValidator().fromJsonString(jsonString, options);
  }

  static equals(a: LiquidValidator | PlainMessage<LiquidValidator> | undefined, b: LiquidValidator | PlainMessage<LiquidValidator> | undefined): boolean {
    return proto3.util.equals(LiquidValidator, a, b);
  }
}

